use import std.array
use import std.fiber
use import std.math
use import std.mem.std_heap_allocator
use import std.printable
use import std.string
use import std.rc
use import std.thread

C    :: import std.c
fmt  :: import std.fmt
fs   :: import std.io.fs
io   :: import std.io
mem  :: import std.mem.allocator
util :: import std.util

use import logging.logger

use import ast
use import ast_cloner
use import ast_dumper
use import ast_pretty_printer
use import bytecode_generator
use import compiler
use import config
use import lexer
use import parser
use import scope
use import types
use import validator
use import value

#export_scope

CompilationJob :: trait {
    cancelled   : bool = false
    progressed  : bool = false
    done        : bool = false
    compiler    : ^mut Compiler = null
    workspace   : ^mut Workspace = null

    get_name :: (&Self) -> string;
    execute :: (&mut Self);
}

LoadFileJob :: struct CompilationJob {
    name : String
    path : String
}

impl LoadFileJob {
    new :: (path: String) -> LoadFileJob {
        return LoadFileJob(
            name = fmt.format("LoadFileJob '{}'", [path.slice()])
            path = path
        )
    }
}

ReplJob :: struct CompilationJob {
    stream : Rc[LexerInputStream]
}

impl ReplJob {
    new :: (stream: Rc[LexerInputStream]) -> ReplJob {
        return ReplJob(stream = stream)
    }
}

RunCodeJob :: struct CompilationJob {
    name        : String
    function    : ^AstFunction
}

impl RunCodeJob {
    new :: (function: ^AstFunction) -> RunCodeJob {
        return RunCodeJob(
            name        = fmt.format("RunCodeJob '{}'", [function.name])
            function    = function
        )
    }
}

EvaluateNodeJob :: struct CompilationJob {
    name : String
    node : &AstNode
}

impl EvaluateNodeJob {
    new :: (node: &AstNode) -> EvaluateNodeJob {
        return EvaluateNodeJob(
            name = fmt.format("EvaluateNodeJob #{}", [node.id])
            node = node
        )
    }
}

CompileGlobalNodeJob :: struct CompilationJob {
    name        : String
    node        : ^AstNode
    function    : ^AstFunction = null
}

impl CompileGlobalNodeJob {
    new :: (node: ^AstNode) -> CompileGlobalNodeJob {
        return CompileGlobalNodeJob(
            name = fmt.format("CompileGlobalNodeJob #{}", [node.id])
            node = node
        )
    }
}

CompileStructMemberJob :: struct CompilationJob {
    name    : String
    structt : ^AstStruct
    node    : ^AstNode
}

impl CompileStructMemberJob {
    new :: (structt: ^AstStruct, node: ^AstNode) -> CompileStructMemberJob {
        return CompileStructMemberJob(
            name    = fmt.format("CompileStructMemberJob #{}", [node.id])
            structt = structt
            node    = node
        )
    }
}

impl CompilationJob for CompileStructMemberJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_ENABLED { if DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[Workspace {}] [CompileStructMemberJob #{}] {}", [workspace.id, node.id, str])
        }}
    }

    execute :: (&mut Self) {
        debug_log("Begin compilation")

        compile_node := CompileNode(
            job         = ^*self
            compiler    = compiler
            workspace   = workspace
            node        = node
            function    = null
        )

        match node {
            AstDecl($decl) -> {
                compile_node.compile_node(&*decl, CNContext())
                structt.members.add(decl)
            }

            AstConstDecl($decl) -> {
                compile_node.compile_node(&*decl, CNContext())
                structt.constants.add(decl)
            }

            _ -> {
                node = ^*compile_node.evaluate_node(&*node, CNContext())
                if node.value == .Poison {
                    poison(&*node)
                    return
                }

                match node.typ {
                    TypeInfoString($ti) -> {
                        @assert(node.value == .String)
                        str := node.value.String
                        lexer := workspace.add_string_source(str)
                        parser := Parser.new(lexer.get_mut(), workspace.error_handler, workspace.ast_allocator, workspace.next_ast_id)
                        workspace.next_ast_id += 0xFFFFFFFF // ?

                        loop {
                            node := parser.parse_node()
                            if node == null then break

                            if const DEBUG_ENABLED { if DUMP_AST {
                                dump := dump_ast(&*node)
                                g_logger.log("[{}] {}", [self.name.slice(), dump])
                            }}
                            if const DEBUG_ENABLED { if PRINT_AST {
                                dump := pretty_print_ast(&*node)
                                g_logger.log("[{}] {}", [self.name.slice(), dump])
                            }}

                            node.scope = self.node.scope
                            job := workspace.create_job(CompileStructMemberJob.new(structt, node))
                            workspace.add_job(job)
                            wait_until(job.done, {
                            })
                        }
                    }
                }
            }
        }

        debug_log("Done")
    }
}

impl CompilationJob for CompileGlobalNodeJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_ENABLED { if DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[Workspace {}] [CompileGlobalNodeJob #{}] {}", [workspace.id, node.id, str])
        }}
    }

    execute :: (&mut Self) {
        debug_log("Begin compilation")

        compile_node := CompileNode(
            job         = ^*self
            compiler    = compiler
            workspace   = workspace
            node        = node
            function    = null
        )

        node.set_flags(.AllowPubModifier)
        node = ^*compile_node.compile_node(&*node, CNContext())

        if node.value == .Poison {
            debug_log("Failed. Got poison")
            return
        }

        if const VALIDATE_AST {
            debug_log("Validate node")
            if !validate_node(&*node, workspace.error_handler) {
                debug_log("Validation failed")
                return
            }
        }

        if const DEBUG_ENABLED { if PRINT_TYPED_AST {
            dump := pretty_print_typed_ast(&*node)
            g_logger.log("[{}] {}", [self.name.slice(), dump])
        }}

        debug_log("Done")
    }
}

impl CompilationJob for RunCodeJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_ENABLED { if DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[Workspace {}] [RunCodeJob '{}'] {}", [workspace.id, function.name, str])
        }}
    }

    execute :: (&mut Self) {
        if workspace.error_handler.has_errors() {
            return
        }
        debug_log("Begin execution")
        context := Fiber.user_data(FiberContext)
        context.interp.comp_call(&*function)
        match compiler.code_runner.get().run(&*context.interp) {
            .Error($msg) -> {
                frame := context.interp.top_frame()
                location := frame.func.debug_info.get_location_for_ip(frame.ip)
                workspace.error_handler.report_error_at(location, "{}", [msg])
            }
        }
        debug_log("Done")
    }
}

impl CompilationJob for EvaluateNodeJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_ENABLED { if DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[Workspace {}] [EvaluateNodeJob #{}] {}", [workspace.id, self.node.id, str])
        }}
    }

    execute :: (&mut Self) {
        debug_log("Begin evaluate node")
        wait_until(self.node.typ != null, {
            debug_log("cancelled due to errors")
            return
        })

        debug_log("Generate bytecode")
        code_gen := ByteCodeGenerator.new(&workspace.string_database, &*workspace.error_handler, workspace.bc_allocator)
        code := code_gen.get_mut().generate_code_for_expression(self.node)
        context := Fiber.user_data(FiberContext)
        context.interp.push_frame(code)
        defer context.interp.pop_frame()

        debug_log("Run bytecode")
        match compiler.code_runner.get().run(&*context.interp) {
            .Error($msg) -> {
                mut stacktrace := String.empty()
                context.interp.write_stacktrace(&mut stacktrace, self.workspace.get_compiler())
                frame := context.interp.top_frame()
                location := frame.func.debug_info.get_location_for_ip(frame.ip)
                workspace.error_handler.report_error_at(location, "{}", [msg], details = [("Stacktrace:`n{}", [stacktrace.slice()])])
            }

            .Done -> {
                frame := context.interp.top_frame()

                value := Any.from_pointers(cast(^void) frame.stack.data, self.node.typ)
                io.formatln("{}: {}", [value, self.node.typ])
            }
        }

        debug_log("Done")
    }
}

impl CompilationJob for LoadFileJob {
    get_name :: (&Self) -> string {
        return name.slice()
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_ENABLED { if DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[Workspace {}] [LoadFileJob '{}'] {}", [workspace.id, path.slice(), str])
        }}
    }

    execute :: (&mut Self) {
        debug_log("Begin loading")

        full_path := match fs.get_full_path(path.slice()) {
            Ok($p) -> workspace.string_database.intern(p.slice())
            Err(_) -> workspace.string_database.intern(path.slice())
        }

        match workspace.load_file(full_path) {
            Err(_) -> {
                workspace.error_handler.report_error("Failed to load file '{}'", [full_path])
                return
            }

            Ok($file) -> match file { Some($file) -> {
                // todo: workspace.string_database must be protected in multi threading
                lexer := Lexer.from_string(file.content, &workspace.string_database)
                lexer.get_mut().location.file = full_path
                parser := Parser.new(lexer.get_mut(), workspace.error_handler, workspace.ast_allocator, workspace.next_ast_id)
                workspace.next_ast_id += 0xFFFFFFFF // ?

                loop {
                    node := parser.parse_node()
                    if node == null then break

                    if const DEBUG_ENABLED { if DUMP_AST {
                        dump := dump_ast(&*node)
                        g_logger.log("[{}] {}", [self.name.slice(), dump])
                    }}
                    if const DEBUG_ENABLED { if PRINT_AST {
                        dump := pretty_print_ast(&*node)
                        g_logger.log("[{}] {}", [self.name.slice(), dump])
                    }}

                    node.scope = file.global_scope
                    file.nodes.add(node)

                    match node {
                        AstConstDecl($decl) -> {
                            define_const_decl(&*decl, &*self.workspace)
                        }
                        AstDecl($decl) -> {
                            define_decl(&*decl, &*self.workspace)
                        }
                    }
                }

                for(by_ref=false) node in &file.nodes {
                    match node {
                        AstImpl($imp) -> node.scope.register_impl(imp)
                        _ -> {}
                    }
                    workspace.add_job(workspace.create_job(CompileGlobalNodeJob.new(node)))
                }
            }}
        }

        debug_log("Done")
    }
}

impl CompilationJob for ReplJob {
    get_name :: (&Self) -> string {
        return "REPL"
    }

    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_ENABLED { if DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[Workspace {}] [ReplJob] {}", [workspace.id, str])
        }}
    }

    execute :: (&mut Self) {
        debug_log("Begin")

        // todo: workspace.string_database must be protected in multi threading
        mut lexer := Lexer.from_stream(self.stream.clone(), &workspace.string_database)
        lexer.get_mut().repl_mode = true
        mut parser := Parser.new(lexer.get_mut(), workspace.error_handler, workspace.ast_allocator, workspace.next_ast_id)
        workspace.next_ast_id += 0xFFFFFFFF // ?

        repl_scope := workspace.new_scope()
        workspace.define_builtin_types(&*repl_scope)
        repl_scope.mutex = Some(Mutex.new())

        loop {
            node := parser.parse_node()
            if node == null then break

            if const DEBUG_ENABLED { if DUMP_AST {
                dump := dump_ast(&*node)
                g_logger.log("[{}] {}", [self.get_name(), dump])
            }}
            if const DEBUG_ENABLED { if PRINT_AST {
                dump := pretty_print_ast(&*node)
                g_logger.log("[{}] {}", [self.get_name(), dump])
            }}

            node.scope = repl_scope

            match node {
                AstConstDecl($decl) -> {
                    define_const_decl(&*decl, &*self.workspace)
                }
                AstDecl($decl) -> {
                    define_decl(&*decl, &*self.workspace)
                }
                AstImpl($imp) -> node.scope.register_impl(imp)
                _ -> {}
            }

            workspace.create_and_add_job(CompileGlobalNodeJob.new(node))
            workspace.create_and_add_job(EvaluateNodeJob.new(&*node))
        }
    }
}

CompileNode :: struct {
    job         : ^CompilationJob
    compiler    : ^Compiler
    workspace   : ^Workspace
    node        : ^AstNode
    function    : ^AstFunction
}
CNContext :: struct #copy {
    expected : ^TypeInfo = null
}

impl CNContext {
    with_expected :: (mut self: Self, typ: ^TypeInfo) -> CNContext {
        self.expected = typ
        return self
    }
}

impl CompileNode {
    debug_log :: (&Self, msg: string, args: []^any = []) {
        if const DEBUG_ENABLED { if DEBUG_JOBS {
            str := fmt.format(msg, args)
            g_logger.log("[Workspace {}] [{}] {}", [workspace.id, job.get_name(), str])
        }}
    }

    evaluate_node :: (&mut Self, node: &mut AstNode, ctx: CNContext) -> &mut AstNode {
        // {
        //     dump := dump_ast(node, recurse = false)
        //     debug_log("evaluate_node: {}", [dump])
        // }
        if node.typ != null {
            return node
        }
        node.scope = workspace.new_scope(node.scope, constant = true)
        node <- compile_node(node, ctx)
        handle_poison(node, node)

        if node.value == .None {
            code_gen := ByteCodeGenerator.new(&workspace.string_database, &*workspace.error_handler, workspace.bc_allocator)
            code := code_gen.get_mut().generate_code_for_expression(node)
            context := Fiber.user_data(FiberContext)
            context.interp.push_frame(code)
            defer context.interp.pop_frame()
            match compiler.code_runner.get().run(&*context.interp) {
                .Error($msg) -> {
                    mut stacktrace := String.empty()
                    context.interp.write_stacktrace(&mut stacktrace, self.workspace.get_compiler())
                    frame := context.interp.top_frame()
                    location := frame.func.debug_info.get_location_for_ip(frame.ip)
                    workspace.error_handler.report_error_at(location, "{}", [msg], details = [("Stacktrace:`n{}", [stacktrace.slice()])])
                    poison(node)
                    return node
                }
            }

            frame := context.interp.top_frame()

            node.value = match &*node.typ {
                TypeInfoInt(_)      -> .Int(frame.get_local(0, int))
                TypeInfoFloat(_)    -> .Float(frame.get_local(0, f64))
                TypeInfoBool(_)     -> .Bool(frame.get_local(0, bool))
                TypeInfoString(_)   -> .String(frame.get_local(0, string))

                _ -> .None
            }
        }

        return node
    }

    compile_node :: (&mut Self, node: &mut AstNode, ctx: CNContext) -> &mut AstNode {
        // g_logger.log("compile_node"
        if node.typ != null {
            return node
        }

        {
            // dump := dump_ast(node, recurse = false)
            // debug_log("compile_node: {}", [dump])
        }

        return match node {
        // result : &AstNode = match node {
            AstArray($arr)          -> compile_array(arr, ctx)
            AstArrayType($arr)      -> compile_array_type(arr, ctx)
            AstAssignment($ass)     -> compile_assignment(ass, ctx)
            AstBinary($bin)         -> compile_binary(bin, ctx)
            AstBlock($block)        -> compile_block(block, ctx)
            AstBool($bol)           -> compile_bool(bol, ctx)
            AstBreak($brake)        -> compile_break(brake, ctx)
            AstCall($call)          -> compile_call(call, ctx)
            AstCast($cst)           -> compile_cast(cst, ctx)
            AstChar($cha)           -> compile_char(cha, ctx)
            AstConstDecl($decl)     -> compile_const_decl(decl, ctx)
            AstContinue($cont)      -> compile_continue(cont, ctx)
            AstDecl($decl)          -> compile_decl(decl, ctx)
            AstDefer($def)          -> compile_defer(def, ctx)
            AstDot($dot)            -> compile_dot(dot, ctx)
            AstFor($forr)           -> compile_for(forr, ctx)
            AstFunction($func)      -> compile_function(func, ctx)
            AstIdentifier($id)      -> compile_identifier(id, ctx)
            AstIf($iff)             -> compile_if(iff, ctx)
            AstImpl($imp)           -> compile_impl(imp, ctx)
            AstImport($imp)         -> compile_import(imp, ctx)
            AstIndex($index)        -> compile_index(index, ctx)
            AstLoop($lop)           -> compile_loop(lop, ctx)
            AstNumberLiteral($num)  -> compile_number(num, ctx)
            AstPoly($poly)          -> compile_poly(poly, ctx)
            AstReturn($ret)         -> compile_return(ret, ctx)
            AstString($str)         -> compile_string(str, ctx)
            AstStruct($str)         -> compile_struct(str, ctx)
            AstUfc($ufc)            -> compile_ufc(ufc, ctx)
            AstUnary($un)           -> compile_unary(un, ctx)

            _ -> {
                dump := dump_ast(node, recurse = false)
                workspace.error_handler.report_error_at(node.location, "compile_node: not implemented: {}", [dump])
                node
            }
        }

        // if result.typ == null {
        //     workspace.error_handler.report_error_at(result.location, "[ERROR] typ is null")
        //     poison(result)
        // }

        // return result
    }

    get_type_and_value_of_symbol :: (symbol: &Symbol) -> (typ: ^TypeInfo, value: Value) {
        return match symbol {
            .Val($value) -> value.typ, value.value

            .ConstDecl($decl) -> {
                wait_until(decl.value_expr.value != .None and decl.value_expr.typ != null, {
                    @assert(false, "Should not happen?")
                })
                // @todo: get type of type expr if available
                decl.value_expr.typ, decl.value_expr.value
            }

            .Decl($decl) -> {
                wait_until(decl.var_type != null, {
                    @assert(false, "Should not happen?")
                })
                decl.var_type, Value.None
            }

            .NativeFunc($func) -> cast func.function_type, Value.NativeFunc(*func)

            $sym -> {
                g_logger.log("get_type_and_value_of_symbol({}): not implemented", [symbol])
                @assert(false, "Should not happen?")
                null, Value.None
            }
        }
    }

    compile_dot :: (&mut Self, dot: &mut AstDot, ctx: CNContext) -> &mut AstNode {
        if dot.sub == null {
            workspace.error_handler.report_error_at(dot.location, "compile_dot: anonymous not implemented")
            poison(dot)
            return dot
        }

        mut original_sub := dot.sub
        dot.sub.scope = dot.scope
        dot.sub <- compile_node(&*dot.sub, ctx)
        handle_poison(dot, *dot.sub)

        dot.sub_type = match dot.sub.typ {
            TypeInfoPointer($ti) -> {
                // deref := workspace.new_ast(AstUnary(
                //     id          = -1
                //     location    = dot.sub.location
                //     scope       = dot.sub.scope
                //     sub         = &*dot.sub
                //     operator    = .Deref
                // ))
                // dot.sub <- compile_node(&*deref, ctx.with_expected(ti.target))
                // handle_poison(dot, *dot.sub)
                dot.address_mode = .Address
                ti.target
            }
            TypeInfoReference($ti) -> {
                // deref := workspace.new_ast(AstUnary(
                //     id          = -1
                //     location    = dot.sub.location
                //     scope       = dot.sub.scope
                //     sub         = &*dot.sub
                //     operator    = .Deref
                // ))
                // dot.sub <- compile_node(&*deref, ctx.with_expected(ti.target))
                // handle_poison(dot, *dot.sub)
                dot.address_mode = .Address
                ti.target
            }
            $ti -> {
                dot.address_mode = .Value
                ti
            }
        }

        name := dot.name.name
        match dot.sub_type {
            TypeInfoArray($ti) -> {
                if name == "length" or name == "count" { // @todo: remove length eventually
                    dot.typ = @type_info(int)
                    dot.value = .Int(ti.count)
                } else if name == "data" {
                    workspace.error_handler.report_error_at(dot.location, "TODO: array.data")
                    poison(dot)
                    return dot
                } else {
                    workspace.error_handler.report_error_at(
                        dot.name.location,
                        "Type '{}' has no subscript '{}'",
                        [dot.sub.typ, name])
                    poison(dot)
                    return dot
                }
            }

            TypeInfoStruct($ti) -> {
                return self.compile_dot_struct(dot, original_sub, &*ti, ctx)
            }

            TypeInfoType($ti) -> {
                typ := dot.sub.value.as_type()

                mut symbol : Option[Symbol] = None
                match AstNode.get_original_symbol(&*dot.sub) {
                    Some($original_symbol) -> match original_symbol {
                        .OriginalNode($node) -> {
                            symbol = node.scope.get_impl_symbol(typ, dot.name.name, only_public = !is_in_impl_for_type(&*typ))
                        }

                        _ -> @assert(false)
                    }
                    None -> {}
                }

                if symbol == .None {
                    symbol = dot.scope.get_impl_symbol(typ, dot.name.name, only_public = !is_in_impl_for_type(&*typ))
                }

                match &symbol {
                    Some($symbol) -> {
                        match symbol {
                            .Private($decl) -> {
                                workspace.error_handler.report_error_at(dot.name.location, "'{}.{}' is not public and thus not accessible from here", [typ, dot.name.name], details=[
                                    ("{}.{} defined at {}", [typ, dot.name.name, decl.location])
                                ])
                                poison(dot)
                                return dot
                            }
                            _ -> {}
                        }
                        dot.original_symbol = Some(*symbol)
                        dot.typ, dot.value = get_type_and_value_of_symbol(symbol)
                    }

                    None -> {}
                }

                if dot.typ == null {
                    workspace.error_handler.report_error_at(dot.location, "Unknown symbol '{}' in type {}", [dot.name.name, typ])
                    poison(dot)
                    return dot
                }

            }

            TypeInfoModule(_) -> {
                file := dot.sub.value.as_module()

                dot.name.scope = file.global_scope
                AstNode.set_flags(dot.name, .OnlyPubDeclarations)
                compile_node(dot.name, ctx)
                dot.typ = dot.name.typ
                dot.value = dot.name.value
                dot.symbol = dot.name.symbol
                dot.original_symbol = dot.name.original_symbol
            }

            _ -> {
                workspace.error_handler.report_error_at(dot.sub.location, "Invalid type on left side of '.': '{}'", [dot.sub.typ])
                poison(dot)
                return dot
            }
        }

        return dot
    }

    compile_dot_struct :: (&mut Self, dot: &mut AstDot, original_sub: ^mut AstNode, typ: &TypeInfoStruct, ctx: CNContext) -> &mut AstNode {
        mut new_sub := original_sub

        // wait_until(typ.members != null, {
        //     // @todo: report error? i dont think its necessary here
        // })

        struct_ast : ^mut AstStruct = match workspace.get_struct_ast(typ) {
            Some($ast) -> {
                wait_until(ast.members_done, {
                    // nothing to see here...
                })
                ast
            }
            None -> null
        }

        // check if member with this name exists
        mut member : ^TypeInfoStructMember = null
        for(by_ref=true) mem in typ.members {
            if mem.name == dot.name.name {
                member = mem
                break
            }
        }

        if member != null {
            // check if member is public
            only_public := !is_in_impl_for_type(typ)
            if struct_ast != null {
                @assert(member.index < struct_ast.members.count())
                member_ast := struct_ast.members[member.index]
                if only_public and !member_ast.public {
                    workspace.error_handler.report_error_at(dot.location, "Can't access non-public member '{}.{}'", [typ, member.name], details=[
                        ("Member defined here: {}", [member_ast.location])
                    ])
                    // do not poison 'dot' here because this error should have very little impact on following code
                    // so we can continue typechecking
                }
            }

            dot.typ = member.typ
            dot.symbol = .StructMember(member)
            if dot.sub.has_flags(.LValue) then AstNode.set_flags(dot, .LValue)
            return dot
        }

        // check if function is in typeinfo
        // this is for functions supplied by the compiler
        {
            mut func : ^TypeInfoImplFunction = null
            for &it in typ.impl_funcs {
                if it.name == dot.name.name {
                    func = ^*it
                    break
                }
            }

            if func != null {
                match workspace.get_native_function_wrapper(cast func.typ) {
                    Some($wrapper) -> {
                        return compile_node(&*workspace.new_ast(AstUfc(
                            id          = -1
                            location    = dot.location
                            scope       = dot.scope
                            typ         = func.typ
                            value_expr  = &*new_sub
                            symbol      = .NativeFunc2(wrapper)
                            value       = .NativeFunc2(wrapper, func.pointer)
                        )), ctx)
                    }
    
                    None -> {
                        workspace.error_handler.report_error_at(
                            dot.name.location,
                            "Can't call native function '{}' because no wrapper is available for type '{}'",
                            [dot.name.name, func.typ])
                        poison(dot)
                        return dot
                    }
                }
            }
        }

        // search for function in impl blocks
        mut symbol : Option[Symbol] = None

        // @TODO: somehow get symbol of type
        // match AstNode.get_original_symbol(&*dot.sub) {
        //     Some($original_symbol) -> match original_symbol {
        //         .OriginalNode($node) -> {
        //             symbol = node.scope.get_impl_symbol(dot.sub_type, dot.name.name, only_public = !is_in_impl_for_type(typ))
        //         }

        //         _ -> @assert(false)
        //     }
        //     None -> {}
        // }

        if symbol == .None {
            symbol = dot.scope.get_impl_symbol(dot.sub_type, dot.name.name, only_public = !is_in_impl_for_type(typ))
        }

        match &symbol {
            Some($symbol) -> {
                match symbol {
                    .Private($decl) -> {
                        workspace.error_handler.report_error_at(dot.name.location, "'{}.{}' is not public and thus not accessible from here", [typ, dot.name.name], details=[
                            ("{}.{} defined at {}", [typ, dot.name.name, decl.location])
                        ])
                        poison(dot)
                        return dot
                    }
                    _ -> {}
                }

                dot.original_symbol = Some(*symbol)
                dot.typ, dot.value = get_type_and_value_of_symbol(symbol)

                if dot.value == .Poison {
                    poison(dot)
                    return dot
                }

                func_type := match dot.typ {
                    TypeInfoFunction($typ_func) -> typ_func
                    _ -> {
                        workspace.error_handler.report_error_at(dot.name.location, "'{}' is not a function but '{}'", [dot.name.name, dot.typ])
                        poison(dot)
                        return dot
                    }
                }

                if func_type.param_types.length == 0 {
                    workspace.error_handler.report_error_at(dot.name.location, "Impl function '{}' has no self parameter. Type is '{}'", [dot.name.name, dot.typ])
                    poison(dot)
                    return dot
                }

                self_param_type := *func_type.param_types[0]

                match self_param_type {
                    $typ if typ == dot.sub.typ -> {
                        // ok, nothing to do
                    }
                    TypeInfoReference($typ) -> {
                        if dot.address_mode == .Value {
                            // left side of dot is a value but functions expects a reference, so create a reference
                            new_sub = workspace.new_ast(AstUnary(
                                id          = -1
                                location    = new_sub.location
                                scope       = new_sub.scope
                                sub         = &*new_sub
                                operator    = if typ.is_mut then .RefMut else .Ref
                            ))
                        }
                    }
                    _ -> {
                        if dot.address_mode == .Address {
                            // left side of dot is a reference/pointer but functions takes parameter by value, so create a deref
                            new_sub = workspace.new_ast(AstUnary(
                                id          = -1
                                location    = new_sub.location
                                scope       = new_sub.scope
                                sub         = &*new_sub
                                operator    = .Deref
                            ))
                        }
                    }
                }

                return compile_node(&*workspace.new_ast(AstUfc(
                    id          = -1
                    location    = dot.location
                    scope       = dot.scope
                    typ         = dot.typ
                    value_expr  = &*new_sub
                    symbol      = *symbol
                    value       = dot.value
                )), ctx)
            }

            None -> {}
        }

        workspace.error_handler.report_error_at(dot.name.location, "Struct '{}' has no member or function '{}'", [typ.name, dot.name.name])
        poison(dot)
        return dot
    }

    borrow_mutably :: (&mut Self, node: &mut AstNode, deref: bool) -> bool {
        if deref {
            match node.typ {
                TypeInfoReference($ti) -> { return ti.is_mut }
                TypeInfoPointer($ti) -> { return ti.is_mut }
                _ -> {}
            }
        }

        return match node {
            AstIdentifier($id) -> match id.symbol {
                .Decl($decl) -> decl.mutable
                _ -> false
            }

            AstDot($node) -> {
                @assert(node.sub != null)
                self.borrow_mutably(&*node.sub, true)
            }

            AstUnary($node) if node.operator == .Deref -> {
                self.borrow_mutably(node.sub, true)
            }

            AstIndex($node) -> {
                self.borrow_mutably(node.sub, true)
            }

            $node -> {
                g_logger.log("borrow_mutably: '{}' not implemented", [node])
                @assert(false)
                false
            }
        }
    }

    compile_assignment :: (&mut Self, ass: &mut AstAssignment, ctx: CNContext) -> &mut AstNode {
        // @todo: check if assignment is of form <expr>[<index>] = <value>
        // and the []set operator is overridden
        // in that case turn it into @typeof(<expr>)."[]set"(<expr>, <index>, <value>)

        ass.pattern.scope = ass.scope
        ass.pattern <- compile_node(ass.pattern, ctx)
        handle_poison(ass, ass.pattern)

        // @todo: check if pattern is lvalue
        if !AstNode.has_flags(ass.pattern, .LValue) {
            workspace.error_handler.report_error_at(ass.pattern.location, "Can't assign to non-lvalue")
            poison(ass)
            return ass
        }

        ass.value_expr.scope = ass.scope
        ass.value_expr <- compile_node(ass.value_expr, ctx.with_expected(ass.pattern.typ))
        handle_poison(ass, ass.value_expr)

        // check types
        if !TypeInfo.same(ass.value_expr.typ, ass.pattern.typ) {
            workspace.error_handler.report_error_at(
                ass.value_expr.location,
                "Can't assign value of type '{}' to pattern of type '{}'",
                [ass.value_expr.typ, ass.pattern.typ])
            poison(ass)
            return ass
        }

        if !self.borrow_mutably(ass.pattern, false) {
            workspace.error_handler.report_error_at(ass.pattern.location, "Can't assign to immutable pattern")
            poison(ass)
            return ass
        }

        match ass.pattern {
            AstIdentifier($id) -> match id.symbol {
                .Decl($decl) -> {
                    // check for mutability
                    if !decl.mutable {
                        workspace.error_handler.report_error_at(ass.pattern.location, "Can't assign to '{}' because it is not mutable", [id.name])
                        poison(ass)
                        return ass
                    }
                }

                .ConstDecl($decl) -> {
                    workspace.error_handler.report_error_at(ass.pattern.location, "Can't assign to constant '{}'", [id.name])
                    poison(ass)
                    return ass
                }

                _ -> {
                    workspace.error_handler.report_error_at(ass.pattern.location, "Invalid pattern on left side of '='")
                    poison(ass)
                    return ass
                }
            }

            AstDot($dot) if dot.symbol == .StructMember -> {
                // ok
            }

            AstDot($dot) -> {
                workspace.error_handler.report_error_at(ass.pattern.location, "compile_assignment: not implemented: <expr>.<id>")
                poison(ass)
                return ass
            }

            AstIndex($node) -> {
                match node.sub.typ {
                    TypeInfoArray($ti) -> match node.index.typ {
                        TypeInfoInt(_) -> {
                            // ok
                        }

                        _ -> {
                            workspace.error_handler.report_error_at(ass.pattern.location, "Invalid pattern on left side of '='")
                            poison(node)
                            return node
                        }
                    }

                    _ -> {
                        workspace.error_handler.report_error_at(ass.pattern.location, "Invalid pattern on left side of '='")
                        poison(node)
                        return node
                    }
                }
            }

            AstUnary($un) if un.operator == .Deref -> {
                match un.sub.typ {
                    TypeInfoPointer($ti) -> {
                        if !ti.is_mut {
                            workspace.error_handler.report_error_at(ass.pattern.location, "Can't assign to immutable pointer")
                            poison(ass)
                            return ass
                        }
                    }
                    TypeInfoReference($ti) -> {
                        if !ti.is_mut {
                            workspace.error_handler.report_error_at(ass.pattern.location, "Can't assign to immutable reference")
                            poison(ass)
                            return ass
                        }
                    }
                }
                // ok
                // workspace.error_handler.report_error_at(ass.pattern.location, "compile_assignment: not implemented: *<expr>")
                // poison(ass)
                // return ass
            }

            _ -> {
                workspace.error_handler.report_error_at(ass.pattern.location, "Invalid pattern on left side of '='")
                poison(ass)
                return ass
            }
        }

        // ok
        ass.typ = @type_info(void)
        return ass
    }
    
    compile_array :: (&mut Self, arr: &mut AstArray, ctx: CNContext) -> &mut AstNode {
        arr.typ = @type_info(void)

        mut expected : ^TypeInfo = null
        if ctx.expected != null then match &*ctx.expected {
            TypeInfoArray($arr_type) -> { expected = arr_type.target }
        }

        for(by_ref=true) val in &arr.values {
            val.scope = arr.scope
            *val = ^*compile_node(&**val, ctx.with_expected(expected))
            
            if val.value == .Poison {
                poison(arr)
                return arr
            }

            if expected == null {
                expected = val.typ
            }

            if !TypeInfo.same(val.typ, expected) {
                workspace.error_handler.report_error_at(val.location, "Type of value ({}) does not match expected type {}", [val.typ, expected])
                poison(arr)
                return arr
            }
        }

        if expected == null {
            workspace.error_handler.report_error_at(arr.location, "Failed to infer type of array expression")
            poison(arr)
            return arr
        }

        arr.typ = workspace.new_type(TypeInfoArray(
            size        = arr.values.count() * expected.size
            alignment   = expected.alignment
            traits      = []
            impl_funcs  = []
            count       = arr.values.count()
            target      = expected
        ))

        return arr
    }

    compile_array_type :: (&mut Self, arr: &mut AstArrayType, ctx: CNContext) -> &mut AstNode {
        arr.typ = @type_info(type)

        count : Option[int] = if arr.count == null {
            None
        } else {
            arr.count.scope = arr.scope
            arr.count = ^*evaluate_node(&*arr.count, ctx.with_expected(@type_info(int)))

            handle_poison(arr, arr.count)

            if !TypeInfo.same(arr.count.typ, @type_info(int)) {
                workspace.error_handler.report_error_at(arr.count.location, "Expected int, got '{}'", [arr.count.typ])
                poison(arr)
                return arr
            }

            @assert(arr.count.value == .Int)
            count := arr.count.value.Int

            Some(count)
        }

        arr.target.scope = arr.scope
        arr.target = evaluate_node(arr.target, ctx.with_expected(@type_info(type)))
        if arr.target.value == .Poison or arr.target.typ != @type_info(type) {
            poison(arr)
            return arr
        }

        @assert(arr.target.value == .Type)
        target := arr.target.value.Type

        arr.value = match count {
            Some($count) -> .Type(workspace.new_type(TypeInfoArray(
                size        = count * target.size
                alignment   = target.alignment
                traits      = []
                impl_funcs  = []
                count       = count
                target      = target
            )))

            None -> .Type(workspace.new_type(TypeInfoSlice(
                size        = 2 * @sizeof(^void)
                alignment   = target.alignment
                traits      = []
                impl_funcs  = []
                target      = target
            )))
        }

        return arr
    }

    compile_ufc :: (&mut Self, ufc: &mut AstUfc, ctx: CNContext) -> &mut AstNode {
        // ufc.value
        return ufc
    }

    compile_unary :: (&mut Self, un: &mut AstUnary, ctx: CNContext) -> &mut AstNode {
        un.sub.scope = un.scope
        return match un.operator {
            .Neg    -> compile_unary_neg(un, ctx)
            .Not    -> compile_unary_not(un, ctx)
            .Ref    -> compile_unary_ptr_or_ref(un, ctx)
            .RefMut -> compile_unary_ptr_or_ref(un, ctx)
            .Ptr    -> compile_unary_ptr_or_ref(un, ctx)
            .PtrMut -> compile_unary_ptr_or_ref(un, ctx)
            .Deref  -> compile_unary_deref(un, ctx)
        }
    }

    compile_unary_neg :: (&mut Self, un: &mut AstUnary, ctx: CNContext) -> &mut AstNode {
        un.sub.scope = un.scope
        un.sub <- compile_node(un.sub, ctx)

        // check types
        if un.sub.typ == null { return un }

        match &*un.sub.typ {
            TypeInfoInt(_) -> {}
            TypeInfoFloat(_) -> {}

            $ti -> {
                workspace.error_handler.report_error_at(
                    un.sub.location,
                    "Expected type bool, got {}",
                    [un.sub.typ])
                return un
            }
        }
        un.typ = un.sub.typ

        // set value if known at compile time
        match un.value {
            .Int($b) -> {
                un.value = .Int(-b)
            }
            .Float($b) -> {
                un.value = .Float(-b)
            }
        }
        return un
    }

    compile_unary_not :: (&mut Self, un: &mut AstUnary, ctx: CNContext) -> &mut AstNode {
        un.sub.scope = un.scope
        un.sub <- compile_node(un.sub, ctx.with_expected(@type_info(bool)))

        // check types
        if un.sub.typ == null { return un }
        if un.sub.typ != @type_info(bool) {
            workspace.error_handler.report_error_at(
                un.sub.location,
                "Expected type bool, got {}",
                [un.sub.typ])
            return un
        }

        un.typ = @type_info(bool)

        // set value if known at compile time
        match un.value {
            .Bool($b) -> {
                un.value = .Bool(!b)
            }
        }
        return un
    }

    compile_unary_ptr_or_ref :: (&mut Self, un: &mut AstUnary, ctx: CNContext) -> &mut AstNode {
        mutable, reference, str := match un.operator {
            .Ref    -> false, true, "reference"
            .RefMut -> true, true, "reference"
            .Ptr    -> false, false, "pointer"
            .PtrMut -> true, false, "pointer"
        }

        un.sub.scope = un.scope
        un.sub <- compile_node(un.sub, ctx)
        handle_poison(un, un.sub)

        if un.sub.typ == @type_info(type) {
            @assert(un.sub.value == .Type)
            un.typ = un.sub.typ
            if reference {
                un.value = .Type(workspace.reference_type(un.sub.value.Type, mutable))
            } else {
                un.value = .Type(workspace.pointer_type(un.sub.value.Type, mutable))
            }
        } else {
            if !un.sub.has_flags(.LValue) {
                workspace.error_handler.report_error_at(un.location, "Can't create {} to non l-value", [str])
                poison(un)
                return un
            }

            match un.sub {
                AstIdentifier($id) -> match id.symbol {
                    .Decl($decl) -> {
                        if mutable and !decl.mutable {
                            workspace.error_handler.report_error_at(un.location, "Can't create mutable {} to immutable variabe", [str])
                            poison(un)
                            return un
                        }
                    }
                }
                AstDot($dot) -> {
                    if mutable {
                        mut node := dot.sub
                        loop {
                            match node {
                                AstDot($dot) -> {
                                    node = dot.sub
                                }
                                AstIdentifier($id) -> match id.symbol {
                                    .Decl($decl) -> {
                                        if !decl.mutable {
                                            workspace.error_handler.report_error_at(un.location, "Can't create mutable {} to immutable variabe", [str])
                                            poison(un)
                                            return un
                                        }

                                        break
                                    }

                                    _ -> break
                                }

                                _ -> break
                            }
                        }
                    }
                }
            }

            if reference {
                un.typ = workspace.reference_type(un.sub.typ, mutable)
            } else {
                un.typ = workspace.pointer_type(un.sub.typ, mutable)
            }
        }

        return un
    }

    compile_unary_deref :: (&mut Self, un: &mut AstUnary, ctx: CNContext) -> &mut AstNode {
        un.sub.scope = un.scope
        un.sub <- compile_node(un.sub, ctx)
        handle_poison(un, un.sub)

        if !un.sub.has_flags(.LValue) {
            workspace.error_handler.report_error_at(un.location, "Can't dereference non l-value")
            poison(un)
            return un
        }

        match un.sub.typ {
            TypeInfoPointer($ti) -> {
                un.typ = ti.target
            }
            TypeInfoReference($ti) -> {
                un.typ = ti.target
            }

            _ -> {
                workspace.error_handler.report_error_at(
                    un.location,
                    "Can't dereference value of type '{}'",
                    [un.sub.typ]
                )
                poison(un)
            }
        }
        return un
    }

    compile_binary :: (&mut Self, bin: &mut AstBinary, ctx: CNContext) -> &mut AstNode {
        bin.left.scope = bin.scope
        bin.right.scope = bin.scope

        bin.left <- compile_node(bin.left, ctx)
        bin.right <- compile_node(bin.right, ctx)

        handle_poison(bin, bin.left)
        handle_poison(bin, bin.right)

        // find matching operator
        match bin.operator {
            .Add -> {
                if !TypeInfo.same(bin.left.typ, bin.right.typ) {
                    workspace.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }
            .Sub -> {
                if !TypeInfo.same(bin.left.typ, bin.right.typ) {
                    workspace.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }
            .Mul -> {
                if !TypeInfo.same(bin.left.typ, bin.right.typ) {
                    workspace.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }
            .Div -> {
                if !TypeInfo.same(bin.left.typ, bin.right.typ) {
                    workspace.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }
            .Mod -> {
                if !TypeInfo.same(bin.left.typ, bin.right.typ) {
                    workspace.error_handler.report_error_at(
                        bin.location, 
                        "Types of left and right sub expressions don't match. Left: {}, Right: {}",
                        [bin.left.typ, bin.right.typ])
                }
                bin.typ = bin.left.typ
            }

            .Equal      -> {
                bin.typ = @type_info(bool)
            }
            .NotEqual   -> {
                bin.typ = @type_info(bool)
            }
            .Less       -> {
                bin.typ = @type_info(bool)
            }
            .LessEq     -> {
                bin.typ = @type_info(bool)
            }
            .Greater    -> {
                bin.typ = @type_info(bool)
            }
            .GreaterEq  -> {
                bin.typ = @type_info(bool)
            }

            .And        -> {
                bin.typ = @type_info(bool)
            }
            .Or         -> {
                bin.typ = @type_info(bool)
            }

            .Move       -> {
                bin.typ = bin.left.typ
            }

            .Pipe       -> {
                workspace.error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }

            .Range      -> {
                workspace.error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }
            .RangeIncl  -> {
                workspace.error_handler.report_error_at(bin.location, "Binary operator {} implemented", [bin.operator])
            }
        }

        // @todo
        return bin
    }

    compile_if :: (&mut Self, iff: &mut AstIf, ctx: CNContext) -> &mut AstNode {
        iff.condition.scope = iff.scope
        compile_node(iff.condition, ctx.with_expected(@type_info(bool)))
        if iff.condition.typ == null {
            return iff
        }

        match &*iff.condition.typ {
            TypeInfoBool(_) -> {}
            TypeInfoPointer(_) -> {}

            _ -> {
                workspace.error_handler.report_error_at(
                    iff.condition.location,
                    "Type of condition must be bool or pointer, but is {}",
                    [iff.condition.typ])
            }
        }

        iff.true_case.scope = iff.scope
        compile_node(iff.true_case, ctx)

        if iff.false_case != null {
            // compile else
            iff.false_case.scope = iff.scope
            compile_node(&*iff.false_case, ctx)

            // cal type of iff
            if iff.true_case.typ == iff.false_case.typ {
                iff.typ = iff.true_case.typ
            } else {
                // @todo: maybe we can do something better here
                iff.typ = @type_info(void)
            }
        } else {
            iff.typ = @type_info(void)
        }

        return iff
    }

    split_const_decl :: (&mut Self, decl: &mut AstConstDecl, context: $T, on_decl: fn(&mut Self, &mut AstConstDecl, T), on_error: fn(&mut Self, &mut AstConstDecl, T)) {
        match decl.pattern {
            AstIdentifier($id) -> {
                decl.name = id.name
                on_decl(self, decl, context)
            }

            AstTuple($tuple) -> {
                @assert(false, "TODO: not implemented")
                // for(by_ref=false) value in tuple.values {
                //     sub_access := workspace.get_compiler().new_ast(AstDeclRef(decl = .ConstDecl(decl)))

                // }
            }

            _ -> {
                on_error(self, decl, context)
            }
        }
    }

    compile_impl :: (&mut Self, node: &mut AstImpl, ctx: CNContext) -> &mut AstNode {
        if node.params.is_some() {
            node.is_polymorphic = true
            node.typ = @type_info(void)
            // workspace.error_handler.report_error_at(node.location.beginning(), "Generic impls not implemented yet")
            // poison(node)
            return node
        }

        node.target_expr.scope = node.scope
        compile_node(node.target_expr, ctx.with_expected(@type_info(type)))
        handle_poison(node, node.target_expr)

        // check if node.target_expr is type
        if node.target_expr.typ != @type_info(type) {
            workspace.error_handler.report_error_at(
                node.target_expr.location,
                "Target of impl block must be a type, found {}",
                [node.target_expr.typ]
            )
            poison(node)
            return node
        }

        if node.trait_expr != null {
            node.trait_expr.scope = node.scope
            compile_node(&*node.trait_expr, ctx.with_expected(@type_info(type)))
            handle_poison(node, node.trait_expr)
        }

        // register this impl in the current scope
        if node.trait_expr == null {
            node.scope.add_impl_for_type(^*node)
        }

        node.sub_scope = workspace.new_scope(node.scope)
        node.functions.reserve(node.children.count())
        jobs := Array[^CompilationJob].create()

        for(by_ref=false) child in &mut node.children {
            child.scope = node.sub_scope
            AstNode.set_flags(&*child, .AllowPubModifier)

            match child {
                AstConstDecl($decl) -> {
                    split_const_decl(&*decl, (node, &jobs), on_decl = (self, decl, ctx) => {
                        define_const_decl(decl, &*self.workspace)

                        match decl.value_expr {
                            AstFunction($func) -> {
                                func.impl_block = ^*ctx[0]
                                ctx[0].functions.add(func)
                            }

                            _ -> {}
                        }
                        job := self.workspace.create_job(CompileGlobalNodeJob.new(cast ^*decl))
                        ctx[1].add(job)
                        self.workspace.add_job(job)
                    }, on_error = (self, decl, ctx) => {
                        self.workspace.error_handler.report_error_at(decl.location, "Invalid pattern in constant declaration")
                        poison(decl)
                    })
                }

                _ -> {
                    workspace.error_handler.report_error_at(child.location, "This type of expression is not allowed here")
                    poison(&*child)
                }
            }
        }

        for job in &jobs {
            wait_until(job.done, {
                // nothing to see here...
            })
        }
        node.children_done = true

        node.typ = @type_info(void)
        return node
    }

    compile_import :: (&mut Self, node: &mut AstImport, ctx: CNContext) -> &mut AstNode {
        match node.path {
            AstString($str) -> {
                str.typ = @type_info(void)

                search_paths := Array[string].create()
                search_paths.add(fs.Path.get_containing_directory(node.location.file))
                search_paths.add(compiler.module_path)

                for search_path in &search_paths {
                    import_path := fs.Path.concat(*search_path, str.string_value)
                    import_path_n := fs.Path.normalize(import_path.slice())

                    match compiler.get_source(import_path_n.slice()) {
                        Err(_) -> continue
                    }
                    match workspace.get_file(import_path_n.slice()) {
                        Some($file) -> {
                            node.typ = workspace.new_module_type()
                            node.value = .Module(file)
                            return node
                        }
                    }

                    job := cast(^LoadFileJob) workspace.create_and_add_job(LoadFileJob.new(import_path_n.clone()))
                    wait_until(job.done, {})

                    match workspace.get_file(import_path_n.slice()) {
                        Some($file) -> {
                            node.typ = workspace.new_module_type()
                            node.value = .Module(file)
                            return node
                        }
                    }
                }

                workspace.error_handler.report_error_at(
                    node.path.location,
                    "Can't find file '{}'",
                    [str.string_value],
                    details = [("Searched in '{}'", cast([]^any)[search_paths.slice()])]
                )
                poison(node)
                return node
            }

            _ -> {
                workspace.error_handler.report_error_at(node.path.location, "Invalid import path")
                poison(node)
                return node
            }
        }

        return node
    }

    compile_index :: (&mut Self, node: &mut AstIndex, ctx: CNContext) -> &mut AstNode {
        node.sub.scope = node.scope
        node.sub <- compile_node(node.sub, ctx)
        handle_poison(node, node.sub)

        match node.sub.value {
            .Poly($poly) -> {
                if node.arguments.count() != poly.params.length {
                    workspace.error_handler.report_error_at(node.location, "Wrong number of arguments. Expected {}", [poly.params.length])
                    poison(node)
                    return node
                } else {
                    for arg in node.arguments.slice() {
                        param := poly.params[it_index]

                        arg.scope = node.scope
                        arg.value_expr.scope = node.scope
                        arg.value_expr = evaluate_node(arg.value_expr, ctx.with_expected(param.var_type))
                        arg.typ = arg.value_expr.typ
                        arg.value = arg.value_expr.value

                        handle_poison(node, arg)

                        if !TypeInfo.same(arg.typ, param.var_type) {
                            workspace.error_handler.report_error_at(
                                arg.location,
                                "Type of argument ({}) does not match type of parameter '{}' ({}).",
                                [arg.typ, param.name, param.var_type])
                        }
                    }
                }

                cloner := AstCloner(workspace.next_ast_id, workspace.ast_allocator)
                mut clone := cloner.clone(^*poly.value_expr)
                if clone == null {
                    poison(node)
                    return node
                }

                scope := workspace.new_scope(poly.scope)

                for arg in &node.arguments {
                    param := poly.params[it_index]

                    scope.define_value(param.name, arg.typ, arg.value)
                }

                clone.scope = scope
                result := evaluate_node(&*clone, ctx)
                node.typ = result.typ
                node.value = result.value
                return node
            }
        }

        match node.sub.typ {
            TypeInfoArray($ti) -> {
                for arg in node.arguments.slice() {
                    arg.scope = node.scope
                    arg.value_expr.scope = arg.scope
                    arg.value_expr = compile_node(arg.value_expr, ctx)
                    arg.typ = arg.value_expr.typ
                    arg.value = arg.value_expr.value
                    handle_poison(node, *arg)
                }

                if node.arguments.count() != 1 {
                    workspace.error_handler.report_error_at(node.location, "Wrong number of arguments. Expected 1")
                    poison(node)
                    return node
                }

                node.index = *node.arguments[0]

                match node.index.typ {
                    TypeInfoInt(_) -> {
                        // ok
                        node.typ = ti.target
                    }

                    _ -> {
                        workspace.error_handler.report_error_at(
                            node.index.location,
                            "Type '{}' can't be used as index for type '{}'",
                            [node.index.typ, node.sub.typ])
                        poison(node)
                        return node
                    }
                }

                AstNode.set_flags(node, .LValue)
            }

            _ -> {
                workspace.error_handler.report_error_at(
                    node.sub.location,
                    "Type '{}' has not operator '[]'",
                    [node.sub.typ])
                poison(node)
                return node
            }
        }

        return node
    }

    compile_loop :: (&mut Self, lop: &mut AstLoop, ctx: CNContext) -> &mut AstNode {
        lop.typ = @type_info(void)
        lop.body.scope = lop.scope
        compile_node(lop.body, ctx)
        return lop
    }

    compile_for :: (&mut Self, forr: &mut AstFor, ctx: CNContext) -> &mut AstNode {
        forr.typ = @type_info(void)
        forr.collection.scope = forr.scope
        compile_node(forr.collection, ctx.with_expected(null))
        forr.body.scope = forr.scope
        compile_node(forr.body, ctx)
        return forr
    }

    compile_break :: (&mut Self, brake: &mut AstBreak, ctx: CNContext) -> &mut AstNode {
        brake.typ = @type_info(void)
        if brake.value_expr != null {
            brake.value_expr.scope = brake.scope
            compile_node(&*brake.value_expr, ctx)
        }
        return brake
    }

    compile_continue :: (&mut Self, cont: &mut AstContinue, ctx: CNContext) -> &mut AstNode {
        cont.typ = @type_info(void)
        return cont
    }

    compile_return :: (&mut Self, ret: &mut AstReturn, ctx: CNContext) -> &mut AstNode {
        if self.function == null {
            workspace.error_handler.report_error_at(ret.location, "Can't use return outside of a function")
            return ret
        }

        ret.typ = @type_info(void)
        if ret.value_expr != null {
            ret.value_expr.scope = ret.scope
            compile_node(&*ret.value_expr, ctx.with_expected(self.function.return_type))
            handle_poison(ret, ret.value_expr)

            if !TypeInfo.same(ret.value_expr.typ, self.function.return_type) {
                workspace.error_handler.report_error_at(
                    ret.value_expr.location,
                    "Type of return value ({}) does not match return type of containing function ({}).",
                    [ret.value_expr.typ, self.function.return_type])
            }
        }

        return ret
    }

    compile_defer :: (&mut Self, def: &mut AstDefer, ctx: CNContext) -> &mut AstNode {
        def.typ = @type_info(void)
        def.sub.scope = def.scope
        compile_node(def.sub, ctx.with_expected(null))
        return def
    }

    compile_string :: (&mut Self, str: &mut AstString, ctx: CNContext) -> &mut AstNode {
        str.typ = @type_info(string) // @todo: string_literal type
        str.value = .String(str.string_value)
        return str
    }

    compile_struct :: (&mut Self, str: &mut AstStruct, ctx: CNContext) -> &mut AstNode {
        str.typ = @type_info(type)
        str.sub_scope = workspace.new_scope(str.scope)

        jobs := Array[^CompileStructMemberJob].create()

        // @todo: create a job for each child, so children can depend on other children
        for child in &str.children {
            child.scope = str.sub_scope
            child.set_flags(.AllowPubModifier)
            job := workspace.create_job(CompileStructMemberJob.new(^*str, *child))
            jobs.add(cast job)
            workspace.add_job(job)
        }

        for job in &jobs {
            wait_until(job.done, {
                // nothing to see here...
            })
        }
        str.members_done = true

        // create type info
        mut member_type_infos := workspace.new_type_data_array(TypeInfoStructMember, str.members.count())
        for mem in &mut str.members {
            member_type_infos[it_index].index = it_index
            member_type_infos[it_index].name = mem.name
            member_type_infos[it_index].typ = mem.var_type
        }
        str.struct_type = workspace.new_type(TypeInfoStruct(
            size        = -1        // will be calculated later
            alignment   = -1        // will be calculated later
            traits      = []        // will be calculated later
            impl_funcs  = []        // will be calculated later
            name        = str.name
            members     = member_type_infos
        ))
        workspace.register_struct(cast str.struct_type, ^*str)

        // calculate size and alignment
        {
            mut alignment   := 1
            mut size        := 0
            for mem in &str.members {
                wait_until(mem.var_type.size >= 0 and mem.var_type.alignment >= 0, {
                    workspace.error_handler.report_error_at(
                        str.location,
                        "Failed to compute size and alignment of struct type. Size of member '{}' unknown"
                        [mem.name])
                })

                member_type_infos[it_index].offset = util.next_aligned_num(size, mem.var_type.alignment)
                alignment = max(alignment, mem.var_type.alignment)
                size += mem.var_type.size
                size = util.next_aligned_num(size, mem.var_type.alignment)
            }

            size = util.next_aligned_num(size, alignment)

            str.struct_type.size = size
            str.struct_type.alignment = alignment
        }

        str.value = .Type(str.struct_type)
        return str
    }

    compile_bool :: (&mut Self, bol: &mut AstBool, ctx: CNContext) -> &mut AstNode {
        bol.typ = @type_info(bool)
        bol.value = .Bool(bol.bool_value)
        return bol
    }

    compile_number :: (&mut Self, num: &mut AstNumberLiteral, ctx: CNContext) -> &mut AstNode {
        num.typ = match num.value {
            .Int(_) -> if ctx.expected != null then match ctx.expected {
                TypeInfoInt($ti) -> cast(^TypeInfo) ctx.expected
                _ -> @type_info(int)
            } else {
                @type_info(int)
            }
            .Float(_) -> @type_info(f64)
            _ -> @assert(false)
        }
        return num
    }

    compile_poly :: (&mut Self, poly: &mut AstPoly, ctx: CNContext) -> &mut AstNode {
        poly.param_scope = workspace.new_scope(poly.scope)
        poly.value_expr.scope = poly.param_scope

        match poly.value_expr {
            AstFunction($func) -> {
                func.name = poly.name
            }
            AstStruct($str) -> {
                str.name = poly.name
            }
            AstEnum($en) -> {
                en.name = poly.name
            }
            AstTrait($tr) -> {
                tr.name = poly.name
            }
            AstPoly($poly) -> {
                poly.name = poly.name
            }
        }

        for param in poly.params.slice() {
            param.scope = poly.scope
            compile_node(&*param, ctx.with_expected(null))
            handle_poison(poly, *param)
        }

        poly.typ = workspace.poly_type(^*poly)
        poly.value = .Poly(^*poly)
        return poly
    }

    compile_identifier :: (&mut Self, id: &mut AstIdentifier, ctx: CNContext) -> &mut AstNode {
        id.symbol = id.scope.get_symbol(id.name, AstNode.has_flags(id, .OnlyPubDeclarations))
        
        match id.symbol {
            .Val($value) -> {
                id.typ = value.typ
                id.value = value.value
            }

            .ConstDecl($decl) -> {
                wait_until(decl.value_expr.value != .None and decl.value_expr.typ != null, {
                    workspace.error_handler.report_error_at(id.location, "Failed to get value and type of constant declaration")
                })
                id.typ = decl.value_expr.typ // @todo: get type of type expr if available
                id.value = decl.value_expr.value
                id.original_symbol = decl.original_symbol
            }

            .Decl($decl) -> {
                wait_until(decl.var_type != null, {
                    workspace.error_handler.report_error_at(id.location, "Failed to get type of declaration")
                })
                AstNode.set_flags(id, .LValue)
                id.typ = decl.var_type
            }

            .NativeFunc($func) -> {
                id.typ = cast func.function_type
                id.value = .NativeFunc(func)
            }

            .NotFound -> {
                workspace.error_handler.report_error_at(id.location, "Unknown symbol '{}'", [id.name])
                poison(id)
                loop Fiber.yield()
                return id
            }

            .Private($node) -> {
                workspace.error_handler.report_error_at(id.location, "Can't access '{}' from here because it's not public", [id.name],
                    details = [("'{}' defined here: {}", [id.name, node.location])])
                poison(id)
                return id
            }

            .Poison -> {
                workspace.error_handler.report_error_at(id.location, "Can't use variable '{}' in constant context", [id.name])
                poison(id)
                return id
            }

            $sym -> {
                workspace.error_handler.report_error_at(id.location, "[compile_identifier] not implemented: {}", [sym])
                poison(id)
                return id
            }
        }

        return id
    }

    compile_cast :: (&mut Self, cst: &mut AstCast, ctx: CNContext) -> &mut AstNode {
        if cst.type_expr == null {
            workspace.error_handler.report_error_at(cst.location, "Auto cast not implemented yet.")
            poison(cst)
            return cst
        }
        cst.type_expr.scope = cst.scope
        cst.type_expr = ^*evaluate_node(&*cst.type_expr, ctx.with_expected(@type_info(type)))

        if cst.type_expr.value == .Poison {
            poison(cst)
            return cst
        }

        if cst.type_expr.typ != @type_info(type) {
            workspace.error_handler.report_error_at(cst.location, "Expected type, got ({})", [cst.type_expr.typ])
            poison(cst)
            return cst
        }

        @assert(cst.type_expr.value == .Type)
        cst.typ = cst.type_expr.value.Type

        cst.value_expr.scope = cst.scope
        cst.value_expr <- compile_node(cst.value_expr, ctx.with_expected(cst.typ))

        if cst.value_expr.value == .Poison {
            poison(cst)
            return cst
        }

        // if type is same, return sub expression since cast is not necesarry
        if cst.value_expr.typ == cst.typ {
            return cst.value_expr
        }

        // check if cast is valid
        // @todo

        return cst
    }

    compile_char :: (&mut Self, node: &mut AstChar, ctx: CNContext) -> &mut AstNode {
        node.typ = @type_info(char)
        node.value = .Char(node.char_value)
        return node
    }

    compile_argument :: (&mut Self, call: &mut AstCall, arg: &mut AstArgument, param_name: string, param_type: ^TypeInfo, ctx: CNContext) -> bool {
        arg.scope = call.scope
        arg.value_expr.scope = call.scope
        arg.value_expr = compile_node(arg.value_expr, ctx.with_expected(param_type))

        if arg.value_expr.value == .Poison {
            return true
        } else {
            match check_type(arg.value_expr, param_type, arg.value_expr.typ) {
                Ok($new) -> {
                    arg.value_expr = new
                }

                Err() -> {
                    workspace.error_handler.report_error_at(arg.location,
                        "Type of argument ({}) does not match type of parameter '{}' ({}). No implicit conversion available.",
                        [arg.value_expr.typ, param_name, param_type])
                    return true
                }
            }
        }

        arg.typ = arg.value_expr.typ
        arg.value = arg.value_expr.value

        return false
    }

    compile_call :: (&mut Self, call: &mut AstCall, ctx: CNContext) -> &mut AstNode {
        call.function.scope = call.scope
        call.function <- compile_node(call.function, ctx.with_expected(null))

        if call.function.value == .Poison {
            poison(call)
            return call
        }

        match call.function {
            AstUfc($ufc) -> {
                new_args := Array[^mut AstArgument].create(call.arguments.count() + 1)
                new_args.add(workspace.new_ast(AstArgument(
                    location    = ufc.location
                    scope       = ufc.scope
                    name        = null
                    value_expr  = ufc.value_expr
                    param       = .None
                )))
                for arg in &call.arguments {
                    new_args.add(*arg)
                }
                call.arguments = new_args
            }
            
            _ -> {}
        }

        {
            // dump := pretty_print_typed_ast(call)
            // g_logger.log("dump: {}", [dump])
        }

        match call.function.value {
            .Type($typ) -> {
                match typ {
                    TypeInfoStruct($str) -> {
                        // wait_until(str.members_done, {
                        //     // nothing to see here
                        // })

                        // get struct definition ast if available
                        struct_decl : Option[&mut AstStruct] = match AstNode.get_original_symbol(call.function) {
                            Some($original) -> match original {
                                .OriginalNode($node) -> match node {
                                    AstStruct($decl) -> Some(decl)
                                    _ -> None
                                }
                                _ -> None
                            }
                            _ -> None
                        }

                        // check for too many arguments
                        if call.arguments.count() > str.members.length {
                            workspace.error_handler.report_error_at(call.location, "Too many arguments. Expected {}, got {}", [str.members.length, call.arguments.count()])
                            poison(call)
                            return call
                        }

                        // stores which fields have a corresponding argument
                        // @todo: is @alloca possible here?
                        provided_fields := @alloca(bool, str.members.length)
                        C.memset(provided_fields.data, 0, cast provided_fields.length * @sizeof(bool))

                        mut allow_unnamed := true
                        for(by_ref=false) arg, i in &mut call.arguments {
                            field : &mut TypeInfoStructMember = if arg.name == null {
                                if !allow_unnamed {
                                    workspace.error_handler.report_error_at(arg.location, "Unnamed argument not allowed here")
                                    poison(call)
                                    return call
                                }

                                // g_logger.log("[compile_struct_init] unnamed arg {} ({}) -> field {}", [i, arg.location, arg.param])
                                cast(&mut TypeInfoStructMember) str.members[i]
                            } else {
                                name := arg.name.name
                                allow_unnamed = false
                                field := str.get_member(name)
                                if field == null {
                                    workspace.error_handler.report_error_at(arg.name.location, "Struct '{}' has no field called '{}'",
                                        [str.name, name])
                                    poison(call)
                                    return call
                                }

                                // g_logger.log("[compile_struct_init] named arg '{}' {} ({}) -> field {}", [name, i, arg.location, arg.param])
                                &mut *field
                            }

                            arg.param = .StructMember(field)
                            *provided_fields[field.index] = true

                            // compile value
                            arg.value_expr.scope = call.scope
                            arg.value_expr = compile_node(arg.value_expr, ctx.with_expected(field.typ))
                            handle_poison(&*arg, arg.value_expr)

                            // check type of argument
                            if !TypeInfo.same(arg.value_expr.typ, field.typ) {
                                match struct_decl {
                                    Some($decl) -> workspace.error_handler.report_error_at(
                                        arg.value_expr.location,
                                        "Type of argument ({}) does not match type of struct field ({})",
                                        [arg.value_expr.typ, field.typ],
                                        details = [("Struct field '{}.{}' defined here: {}", [str.name, field.name, decl.members[field.index].location])])
                                    None -> workspace.error_handler.report_error_at(
                                        arg.value_expr.location,
                                        "Type of argument ({}) does not match type of struct field ({})",
                                        [arg.value_expr.typ, field.typ])
                                }
                                poison(call)
                                return call
                            }

                            arg.typ = arg.value_expr.typ
                            arg.value = arg.value_expr.value
                        }

                        // check if there are struct fields which have no corresponding argument
                        mut any_fields_missing := false
                        for field_set in provided_fields {
                            if !field_set {
                                any_fields_missing = true
                                field := str.members[it_index]
                                match struct_decl {
                                    Some($decl) -> workspace.error_handler.report_error_at(
                                        call.location,
                                        "Missing argument for struct field '{} : {}'",
                                        [field.name, field.typ],
                                        details = [("Struct field '{}.{}' defined here: {}", [str.name, field.name, decl.members[field.index].location])])
                                    None -> workspace.error_handler.report_error_at(
                                        call.location,
                                        "Missing argument for struct field '{} : {}'",
                                        [field.name, field.typ])
                                }
                            }
                        }
                        if any_fields_missing {
                            poison(call)
                            return call
                        }

                        call.typ = str
                        return call
                    }

                    _ -> {
                        if call.arguments.count() != 1 {
                            workspace.error_handler.report_error_at(call.location, "Cast requires exactly one argument");
                            poison(call)
                            return call
                        }

                        // create cast
                        cast_ast := workspace.new_ast(AstCast(
                            id          = -1
                            location    = call.location
                            scope       = call.scope
                            type_expr   = ^*call.function
                            value_expr  = &**call.arguments[0]
                        ))

                        return compile_node(&*cast_ast, ctx)
                    }
                }
            }

            .Function($func) -> {
                call.ast_function = func

                if call.arguments.count() != func.params.length {
                    workspace.error_handler.report_error_at(call.location, "Wrong number of arguments in function call")
                    poison(call)
                    return call
                } else {
                    mut any_arg_failed := false
                    for(by_ref=false) arg in &call.arguments {
                        param := func.params[it_index]
                        if compile_argument(call, &*arg, param.name, param.var_type, ctx) {
                            any_arg_failed = true
                        }
                    }

                    if any_arg_failed {
                        poison(call)
                        return call
                    }
                }

                call.typ = func.return_type
            }

            .NativeFunc($func) -> {
                func_type := cast(^TypeInfoFunction) call.function.typ

                call.typ = func_type.return_type

                if call.arguments.count() != func_type.param_types.length {
                    workspace.error_handler.report_error_at(
                        call.location,
                        "Wrong number of arguments ({}) in function call. Expected {}",
                        [call.arguments.count(), func_type.param_types.length])
                    poison(call)
                    return call
                } else {
                    mut any_arg_failed := false
                    for(by_ref=false) arg in &call.arguments {
                        param_type := *func_type.param_types[it_index]
                        if compile_argument(call, &*arg, "", param_type, ctx) {
                            any_arg_failed = true
                        }
                        // arg.scope = call.scope
                        // *arg = cast ^*compile_node(&**arg, ctx.with_expected(param_type))

                        // if arg.value == .Poison {
                        //     any_arg_failed = true
                        // } else if !TypeInfo.same(arg.typ, param_type) {
                        //     any_arg_failed = true
                        //     workspace.error_handler.report_error_at(
                        //         arg.location,
                        //         "Type of argument ({}) does not match type of parameter ({}).",
                        //         [arg.typ, param_type])
                        // }
                    }

                    if any_arg_failed {
                        poison(call)
                        return call
                    }
                }
            }

            .NativeFunc2($func) -> {
                func_type := cast(^TypeInfoFunction) call.function.typ

                call.typ = func_type.return_type

                if call.arguments.count() != func_type.param_types.length {
                    workspace.error_handler.report_error_at(
                        call.location,
                        "Wrong number of arguments ({}) in function call. Expected {}",
                        [call.arguments.count(), func_type.param_types.length])
                } else {
                    mut any_arg_failed := false
                    for(by_ref=false) arg in &call.arguments {
                        param_type := *func_type.param_types[it_index]
                        if compile_argument(call, &*arg, "", param_type, ctx) {
                            any_arg_failed = true
                        }
                        // arg.scope = call.scope
                        // *arg = cast ^*compile_node(&**arg, ctx.with_expected(param_type))

                        // if arg.value == .Poison {
                        //     any_arg_failed = true
                        // } else if !TypeInfo.same(arg.typ, param_type) {
                        //     any_arg_failed = true
                        //     workspace.error_handler.report_error_at(
                        //         arg.location,
                        //         "Type of argument ({}) does not match type of parameter ({}).",
                        //         [arg.typ, param_type])
                        // }
                    }

                    if any_arg_failed {
                        poison(call)
                        return call
                    }
                }
            }

            $val -> {
                workspace.error_handler.report_error_at(call.function.location, "[compile_call] not implemented: {}", [val])
                poison(call)
                return call
            }
        }

        return call
    }

    compile_block :: (&mut Self, block: &mut AstBlock, ctx: CNContext) -> &mut AstNode {
        block.sub_scope = workspace.new_scope(block.scope)

        for child in &block.children {
            // g_logger.log("compile_block {}", [it_index])

            child.scope = block.sub_scope

            expected : ^TypeInfo = if it_index == block.children.count() - 1 then ctx.expected else null
            *child = ^*compile_node(&**child, ctx.with_expected(expected))

            if child.value == .Poison {
                poison(block)
                return block
            }
        }

        // calc type of block
        if block.children.count() > 0 {
            block.typ = block.children.peek_last().typ
        } else {
            block.typ = @type_info(void)
        }

        return block
    }

    compile_function :: (&mut Self, func: &mut AstFunction, ctx: CNContext) -> &mut AstNode {
        // debug_log("compile_function")
        // @todo: polymorphic functions

        _prev_func := self.function
        self.function = ^*func
        defer self.function = _prev_func

        debug_log("compile_function '{}': Begin", [func.name])
        func.param_scope = workspace.new_scope(func.scope)
        func.body.scope = func.param_scope
        func.value = Value.Function(^*func)

        // infer types of parameters
        param_types := mem.alloc_n(^TypeInfo, cast func.params.count(), workspace.type_allocator)
        for param in &func.params {
            param.scope = func.param_scope

            param.name = match param.pattern {
                AstIdentifier($id) -> id.name
                _ if param.pattern == null -> "_"

                _ -> {
                    workspace.error_handler.report_error_at(param.location, "Non-identifier patterns not implemented yet")
                    return func
                }
            }

            // compile type expression
            if param.type_expr != null {
                param.type_expr.scope = param.scope
                param.type_expr = ^*compile_node(&*param.type_expr, ctx.with_expected(@type_info(type)))
                
                if param.type_expr.typ != @type_info(type) {
                    workspace.error_handler.report_error_at(param.type_expr.location, "Expected type, got {}", [param.type_expr.typ])
                    return func
                } else {
                    @assert(param.type_expr.value == .Type)
                    param.var_type = param.type_expr.value.Type
                }
            }

            // default value
            if param.value_expr != null {
                param.value_expr = ^*compile_node(&*param.value_expr, ctx.with_expected(param.var_type))
                if param.value_expr.typ == null { return func }
                param.value = param.value_expr.value

                if param.var_type == null {
                    param.var_type = param.value_expr.typ
                }
            }

            // define param
            if param.name != "_" {
                match param.scope.define_decl(param.name, &**param) {
                    Err() -> {
                        workspace.error_handler.report_error_at(param.pattern.location, "A parameter with this name already exists")
                    }
                }
            }

            *param_types[it_index] = param.var_type
        }

        // handle return type
        func.return_type = @type_info(void)
        if func.return_type_expr != null {
            func.return_type_expr.scope = func.param_scope
            func.return_type_expr = ^*compile_node(&*func.return_type_expr, ctx.with_expected(@type_info(type)))

            if func.return_type_expr.value == .Poison {
                poison(func)
                return func
            } else if func.return_type_expr.typ != @type_info(type) {
                workspace.error_handler.report_error_at(func.return_type_expr.location, "Expected type, got {}", [func.return_type_expr.typ])
                poison(func)
                return func
            } else {
                @assert(func.return_type_expr.value == .Type)
                func.return_type = func.return_type_expr.value.Type
            }
        }

        // set function type
        func.typ = workspace.new_type(TypeInfoFunction(
            size        = 8
            alignment   = 8
            traits      = []
            impl_funcs  = []
            param_types = param_types
            return_type = func.return_type
        ))

        // compile body
        debug_log("compile_function '{}': Compile Body", [func.name])
        func.body = ^*compile_node(&*func.body, ctx.with_expected(null)) // @todo: use return type as expected?
        if func.body.value == .Poison {
            poison(func)
            return func
        }

        // generate byte code
        debug_log("compile_function '{}': Generate Bytecode", [func.name])
        code_gen := ByteCodeGenerator.new(&workspace.string_database, &*workspace.error_handler, workspace.bc_allocator)
        code_gen.get_mut().generate_code_for_function(^*func)

        debug_log("compile_function '{}': End", [func.name])
        return func
    }

    compile_decl :: (&mut Self, decl: &mut AstDecl, ctx: CNContext) -> &mut AstNode {
        decl.typ = @type_info(void)
        if !AstNode.has_flags(decl, .IsDefinedInScope) {

            decl.name = match &*decl.pattern {
                AstIdentifier($id) -> id.name
                _ -> {
                    workspace.error_handler.report_error_at(decl.location, "Non-identifier patterns not implemented yet")
                    return decl
                }
            }

            // define symbol but only if not _
            if decl.name != "_" {
                match decl.scope.define_decl(decl.name, decl) {
                    Err() -> {
                        workspace.error_handler.report_error_at(decl.pattern.location, "A symbol with this name already exists in this scope")
                    }
                }
            }
        }

        if decl.public and !AstNode.has_flags(decl, .AllowPubModifier) {
            workspace.error_handler.report_error_at(decl.pattern.location, "Modifier 'pub' is not allowed here")
        }

        // compile type expression
        if decl.type_expr != null {
            decl.type_expr.scope = decl.scope
            decl.type_expr = ^*compile_node(&*decl.type_expr, ctx.with_expected(@type_info(type)))
            
            // error handling
            if decl.type_expr.value == .Poison {
                decl.var_type = @type_info(void)
                poison(decl)
                return decl
            } else if decl.type_expr.typ != @type_info(type) {
                workspace.error_handler.report_error_at(decl.type_expr.location, "Expected type, got {}", [decl.type_expr.typ])
                decl.var_type = @type_info(void)
                poison(decl)
                return decl
            } else {
                @assert(decl.type_expr.value == .Type)
                decl.var_type = decl.type_expr.value.Type
            }
        }

        // compile value if present
        if decl.value_expr != null {
            decl.value_expr.scope = decl.scope
            decl.value_expr = ^*compile_node(&*decl.value_expr, ctx.with_expected(decl.var_type))
            if decl.value_expr.typ == null { return decl }
            decl.value = decl.value_expr.value

            // error handling
            if decl.value_expr.value == .Poison {
                decl.var_type = @type_info(void)
                poison(decl)
                return decl
            }

            if decl.var_type == null {
                decl.var_type = decl.value_expr.typ
            }

            if !TypeInfo.same(decl.value_expr.typ, decl.var_type) {
                workspace.error_handler.report_error_at(decl.value_expr.location, "Value type ({}) does not match expected type ({})", [decl.value_expr.typ, decl.var_type])
                decl.var_type = @type_info(void)
                poison(decl)
                return decl
            }
        }

        // check if var_type is valid
        if !validate_variable_type(decl.var_type, decl.pattern.location) {
            poison(decl)
            return decl
        }

        // @todo: create cast if necessary

        return decl
    }

    validate_variable_type :: (&mut Self, typ: ^TypeInfo, location: Location) -> bool {
        @assert(typ != null)
        if typ == @type_info(void) {
            workspace.error_handler.report_error_at(location, "Variable can't have type {}", [typ])
            return false
        }

        return true
    }

    compile_const_decl :: (&mut Self, decl: &mut AstConstDecl, ctx: CNContext) -> &mut AstNode {
        decl.typ = @type_info(void)

        if !AstNode.has_flags(decl, .IsDefinedInScope) {
            decl.value_expr.scope = decl.scope

            name := match decl.pattern {
                AstIdentifier($id) -> id.name
                _ -> {
                    workspace.error_handler.report_error_at(decl.location, "Non-identifier patterns not implemented yet")
                    return decl
                }
            }

            decl.name = name

            // set name of value expr if its a function or struct/trait/enum
            AstNode.set_name(decl.value_expr, name)

            // define symbol but only if not _
            if name != "_" {
                match decl.scope.define_const_decl(name, decl) {
                    Err() -> {
                        workspace.error_handler.report_error_at(decl.pattern.location, "A symbol with this name already exists in this scope")
                    }
                }
            }
        }

        if decl.public and !AstNode.has_flags(decl, .AllowPubModifier) {
            workspace.error_handler.report_error_at(decl.pattern.location, "Modifier 'pub' is not allowed here")
        }

        // compile type expression
        if decl.type_expr != null {
            decl.type_expr.scope = decl.scope
            decl.type_expr = ^*compile_node(&*decl.type_expr, ctx.with_expected(@type_info(type)))
            
            if decl.type_expr.typ != @type_info(type) {
                workspace.error_handler.report_error_at(decl.type_expr.location, "Expected type, got {}", [decl.type_expr.typ])
            } else {
                @assert(decl.type_expr.value == .Type)
                decl.var_type = decl.type_expr.value.Type
            }
        }

        decl.value_expr <- evaluate_node(decl.value_expr, ctx.with_expected(decl.var_type))
        decl.value = decl.value_expr.value

        if decl.value == .Poison {
            poison(decl)
            return decl
        }

        decl.original_symbol = AstNode.get_original_symbol(decl.value_expr)

        if decl.value_expr.typ != @type_info(void) and decl.value == .None {
            workspace.error_handler.report_error_at(decl.value_expr.location, "Value is not constant")
            poison(decl)
            return decl
        }

        if decl.var_type == null {
            decl.var_type = decl.value_expr.typ
        }

        // @todo: create cast if necessary

        return decl
    }

    check_type :: (&mut Self, node: &mut AstNode, target: ^TypeInfo, source: ^TypeInfo) -> Result[&mut AstNode, ()] {
        if TypeInfo.same(target, source) {
            return Ok(node)
        }

        match target, source {
            // cast(&T) &mut T
            TypeInfoReference($target), TypeInfoReference($source) if TypeInfo.same(target.target, source.target) and !target.is_mut and source.is_mut -> {
                // @todo: create cast

                // @temp
                node.typ = target
                return Ok(node)

                // deref := workspace.new_ast(AstCast(
                //     id          = -1
                //     location    = dot.sub.location
                //     scope       = dot.sub.scope
                //     sub         = &*dot.sub
                //     operator    = .Deref
                // ))
            }
        }

        return Err()
    }


    is_in_impl_for_type :: (&Self, typ: &TypeInfo) -> bool {
        return self.function != null and self.function.impl_block != null and TypeInfo.same(self.function.impl_block.target_expr.value.as_type(), ^*typ)
    }
}


#file_scope

define_decl :: (decl: &mut AstDecl, workspace: &mut Workspace) {
    decl.name = match &*decl.pattern {
        AstIdentifier($id) -> id.name
        _ -> {
            workspace.error_handler.report_error_at(decl.location, "Non-identifier patterns not implemented yet")
            return
        }
    }

    // define symbol but only if not _
    if decl.name != "_" {
        match decl.scope.define_decl(decl.name, decl) {
            Err() -> {
                workspace.error_handler.report_error_at(decl.pattern.location, "A symbol with this name already exists in this scope")
            }
        }
    }
    AstNode.set_flags(decl, .IsDefinedInScope)
}

define_const_decl :: (decl: &mut AstConstDecl, workspace: &mut Workspace) {
    decl.value_expr.scope = decl.scope
    
    name := match decl.pattern {
        AstIdentifier($id) -> id.name
        _ -> {
            workspace.error_handler.report_error_at(decl.location, "Non-identifier patterns not implemented yet")
            return
        }
    }

    // set name of value expr if its a function or struct/trait/enum
    AstNode.set_name(decl.value_expr, name)

    // define symbol but only if not _
    if name != "_" {
        match decl.scope.define_const_decl(name, decl) {
            Err() -> {
                workspace.error_handler.report_error_at(decl.pattern.location, "A symbol with this name already exists in this scope")
            }
        }
    }

    AstNode.set_flags(decl, .IsDefinedInScope)
}

handle_poison :: (node: &mut AstNode, possible_poison: Code) #macro {
    if @insert(possible_poison).value == .Poison {
        node.typ = @type_info(void)
        node.value = .Poison
        return node
    }
}

poison :: (node: &mut AstNode) {
    node.typ = @type_info(void)
    node.value = .Poison
}

impl TypeInfo {
    same :: (a: ^TypeInfo, b: ^TypeInfo) -> bool {
        if a == b {
            return true
        }

        return match a, b {
            TypeInfoArray($a), TypeInfoArray($b) -> a.count == b.count and same(a.target, b.target)

            // TypeInfoPointer($a), TypeInfoPointer($b) -> a.is_mut == b.is_mut and same(a.target, b.target)
            // TypeInfoReference($a), TypeInfoReference($b) -> a.is_mut == b.is_mut and same(a.target, b.target)
            TypeInfoPointer($a), TypeInfoPointer($b) -> same(a.target, b.target) and a.is_mut == b.is_mut
            TypeInfoReference($a), TypeInfoReference($b) -> same(a.target, b.target) and a.is_mut == b.is_mut

            // temp
            // TypeInfoPointer($a), TypeInfoReference($b) -> a.is_mut == b.is_mut and same(a.target, b.target)
            // TypeInfoReference($a), TypeInfoPointer($b) -> a.is_mut == b.is_mut and same(a.target, b.target)
            TypeInfoPointer($a), TypeInfoReference($b) -> same(a.target, b.target) and a.is_mut == b.is_mut
            TypeInfoReference($a), TypeInfoPointer($b) -> same(a.target, b.target) and a.is_mut == b.is_mut
            //

            TypeInfoFunction($a), TypeInfoFunction($b) -> {
                if a.param_types.length != b.param_types.length {
                    return false
                }
                if !same(a.return_type, b.return_type) {
                    return false
                }
                for 0 .. a.param_types.length {
                    if !same(*a.param_types[it], *b.param_types[it]) {
                        return false
                    }
                }
                return true
            }

            _ -> false
        }
    }

    matches_pattern :: (&Self, pattern: ^TypeInfo) -> bool {
        return TypeInfo.same(^*self, pattern)
    }
}