#file cli.che
use import std.array

use import std.mem.allocator

use import std.mem.arena_allocator

use import std.process

use import std.string

use import std.time

C :  : import std.c

fmt :  : import std.fmt

fs :  : import std.io.fs

io :  : import std.io

use import clap.clap

use import logging.logger

use import compiler

use import config

use import error_handler

use import jobs

use import lexer

use import parser

use import scope

use import string_database

use import value

LOG_PATH : string_literal : "../data/logs/compiler_log.txt"

Main :: Main() {
    args_array : Array[String] = get_cmd_args()
    compiler_args : ^MainCommand = parse_arguments(&args_array.sliceF(1))
    if (cast(^void) (compiler_args) == null) {
        @destruct(args_array);
        return
    } else {}
    (io).println((fmt).format_any(cast(^any) (*compiler_args)))
    match @tempvar_1(*compiler_args) {
        MainCommand.Build($options) -> command_build(^options)
        MainCommand.Compile($options) -> command_compile(^options);
        @destruct(options);
        MainCommand.Project($poptions) -> match @tempvar_2(poptions) {
            CommandProject.New($options) -> command_project_new(^options);
            @destruct(options);
        }
        MainCommand.Help -> (io).println(get_help_message(@type_info(MainCommand)))
        MainCommand.DumpTokens($file) -> dump_tokens(&file.slice());
        @destruct(file);
    }
    @destruct(args_array)
}

MainCommand :: enum<i64> { // size: 0, alignment: 1
    #name "help"
    #help "Displays this help info"
    Help = 0
    #name "compile"
    #help "Compile files"
    Compile : CommandCompile = 1
    #name "build"
    #help "Build a project using a build script (default: build.cheez)"
    Build : CommandBuild = 2
    #name "project"
    #help "Manage projects"
    Project : CommandProject = 3
    #name "run"
    #help "Run a bytecode or source file"
    Run : CommandRun = 4
    #name "dump-tokens"
    #help "Dump all tokens in the specified file"
    DumpTokens : String = 5
}

CommandCompile :: struct { // size: 56, alignment: 8
    #help "List of files to compile (.cheez extension optional)`ne.g. ... compile foo.cheez bar.cheez`ne.g. ... compile foo bar"
    files : Array[String]
    thread_count : i64 = 1
    debug_interpreter : bool = false
    debug_jobs : bool = false
    debug_parser : bool = false
    debug_wait : bool = false
    dump_ast : bool = false
    print_ast : bool = false
    print_typed_ast : bool = false
}

CommandBuild :: struct { // size: 16, alignment: 8
    thread_count : i64 = 1
    debug_interpreter : bool = false
    debug_jobs : bool = false
    debug_parser : bool = false
    debug_wait : bool = false
    dump_ast : bool = false
    print_ast : bool = false
    print_typed_ast : bool = false
}

CommandProject :: enum<i64> { // size: 0, alignment: 1
    #name "new"
    #help "Create a new project"
    New : CommandProjectNew = 0
    #help "Change the type of a project"
    #name "change-type"
    ChangeType : ProjectType = 1
}

CommandRun :: struct { // size: 40, alignment: 8
    #help "File to run. Can be a source file (.cheez) or bytecode file (.cheezb)"
    file : String
}

CommandProjectNew :: struct { // size: 56, alignment: 8
    #help "The name of the project to be created"
    name : String
    #name "type"
    #help "The type of project you want to create"
    typ : ProjectType
    #name "no-git"
    #help "Don't create a git repository"
    no_git : bool = false
}

CommandProjectChangeType :: struct { // size: 48, alignment: 8
    #help "The name of the project to be created"
    name : String
    #name "type"
    #help "The type of project you want to create"
    typ : ProjectType
}

ProjectType :: enum<i64> { // size: 0, alignment: 1
    #name "program"
    #help "Executable program"
    Program = 0
    #name "dynamic-lib"
    #help "Dynamic library"
    DynamicLibrary = 1
    #name "static-lib"
    #help "Static library"
    StaticLibrary = 2
}

CommandFindToken :: struct { // size: 96, alignment: 8
    #name "file"
    #help "The file to search tokens in"
    file : String
    #name "type"
    #help "The type of token to search for"
    typ : TokenType
    #name "suffix"
    #help "If searching for a literal, only include those with the specified suffix"
    suffix : Option[String] = Option[String].None
}

find_tokens_of_type :: find_tokens_of_type(options: ^CommandFindToken) {
    console_error_handler : ConsoleErrorHandler = (ConsoleErrorHandler).new(null)
    (console_error_handler).code_color_error = ConsoleColor.Green
    (console_error_handler).code_color_normal = ConsoleColor.White
    string_db : StringDatabase = (StringDatabase).new()
    lexer : Rc[Lexer] = #macro {
        
        
        @tempvar_6(match @tempvar_3((Lexer).from_file(&(*options).file.slice(), &string_db)) {
            Result[Rc[Lexer], ()].Ok($val) -> val
            Result[Rc[Lexer], ()].Err($err) -> #link #anonymous {
                (io).printfln("Failed to open file '{}'", &(*options).file.slice())
                @destruct(string_db);
                @destruct(console_error_handler);
                return
            }
        })
    }
    (console_error_handler).text_provider = cast(^TextProvider) (^*&lexer.get())
    @id((suffix, filter_suffix)_0) : (string, bool) = match @tempvar_4(&(*options).suffix) {
        Option[String].Some($str) -> (str.slice(), true)
        Option[String].None -> ("", false)
    }
    suffix : string = @var(@id((suffix, filter_suffix)_0))[0]
    filter_suffix : bool = @var(@id((suffix, filter_suffix)_0))[1]
    loop {
        token : Token = &lexer.get().next_token()
        if (cast(i64) ((token).typ) == cast(i64) (TokenType.EOF)) then break else {}
        if (cast(i64) ((token).typ) != cast(i64) ((*options).typ)) then continue else {}
        if filter_suffix {
            match @tempvar_5((token).suffix) {
                Option[string].Some($s) if streq(suffix, s) -> &console_error_handler.report_error_at((token).location, "", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                Option[string].None if streq(suffix, "") -> &console_error_handler.report_error_at((token).location, "", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
            }
        } else {
            &console_error_handler.report_error_at((token).location, "", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
        }
    }
    @destruct(lexer)
    @destruct(string_db)
    @destruct(console_error_handler)
}

command_project_new :: command_project_new(options: ^CommandProjectNew) {
    match @tempvar_7(&(*options).typ) {
        ProjectType.Program -> command_project_new_program(options)
    }
}

command_project_new_program :: command_project_new_program(options: ^CommandProjectNew) {
    create_dir :: create_dir(dir_format: string, dir_args: []^any) #macro {
        dir :  = (fmt).format(dir_format, dir_args)
        (fs).create_directory((dir).slice())
    }
    create_file :: create_file(path_format: string, path_args: []^any, content_format: string, content_args: []^any) {
        path : String = (fmt).format(path_format, path_args)
        content : String = (fmt).format(content_format, content_args)
        (fs).write_file(&path.slice(), &content.slice())
        @destruct(content)
        @destruct(path)
    }
    (io).printfln("Creating project files for new project '{}'", &(*options).name.slice())
    #macro {
        local dir_format : string : "{}"
        local dir_args : []^any = cast([]^any) ([cast(^any) (&(*options).name.slice())])
        dir : String = (fmt).format(dir_format, dir_args)
        (fs).create_directory(&dir.slice())
        @destruct(dir)
    }
    #macro {
        local dir_format : string : "{}/src"
        local dir_args : []^any = cast([]^any) ([cast(^any) (&(*options).name.slice())])
        dir : String = (fmt).format(dir_format, dir_args)
        (fs).create_directory(&dir.slice())
        @destruct(dir)
    }
    #macro {
        local dir_format : string : "{}/bin"
        local dir_args : []^any = cast([]^any) ([cast(^any) (&(*options).name.slice())])
        dir : String = (fmt).format(dir_format, dir_args)
        (fs).create_directory(&dir.slice())
        @destruct(dir)
    }
    #macro {
        local dir_format : string : "{}/modules"
        local dir_args : []^any = cast([]^any) ([cast(^any) (&(*options).name.slice())])
        dir : String = (fmt).format(dir_format, dir_args)
        (fs).create_directory(&dir.slice())
        @destruct(dir)
    }
    create_file("{}/src/{}", cast([]^any) ([cast(^any) (&(*options).name.slice()), cast(^any) ("main.che")]), "io :: import std.io`n`nMain :: () ``{`n    io.println(`"Hello, {}!`")`n}", cast([]^any) ([cast(^any) (&(*options).name.slice())]))
    create_file("{}/build.ps1", cast([]^any) ([cast(^any) (&(*options).name.slice())]), "[CmdletBinding()]`nparam ([Parameter(ValueFromRemainingArguments)] [string[]] $Passthrough)`n&cheezc ./src/main.che --out ./bin --name {} --time @Passthrough", cast([]^any) ([cast(^any) (&(*options).name.slice())]))
    if !(*options).no_git {
        create_file("{}/.gitignore", cast([]^any) ([cast(^any) (&(*options).name.slice())]), "# Build results`nbin/", cast([]^any) ([]))
        (io).println("Initializing git repository...")
        match @tempvar_8(find_on_path("git.exe")) {
            Option[String].None -> {
                (io).println("[ERROR] No git installation found.")
            }
            Option[String].Some($path) -> {
                run_process(&path.slice(), cast([]string) (["init"]), &(*options).name.slice())
            };
            @destruct(path);
        }
    } else {}
}

command_compile :: command_compile(options: ^CommandCompile) {
    DEBUG_INTERPRETER = (*options).debug_interpreter
    DEBUG_JOBS = (*options).debug_jobs
    DEBUG_PARSER = (*options).debug_parser
    DEBUG_WAIT = (*options).debug_wait
    DUMP_AST = (*options).dump_ast
    PRINT_AST = (*options).print_ast
    PRINT_TYPED_AST = (*options).print_typed_ast
    compile_files(&(*options).files.slice(), (*options).thread_count)
}

command_build :: command_build(options: ^CommandBuild) {
    DEBUG_INTERPRETER = (*options).debug_interpreter
    DEBUG_JOBS = (*options).debug_jobs
    DEBUG_PARSER = (*options).debug_parser
    DEBUG_WAIT = (*options).debug_wait
    DUMP_AST = (*options).dump_ast
    PRINT_AST = (*options).print_ast
    PRINT_TYPED_AST = (*options).print_typed_ast
    console_error_handler : ConsoleErrorHandler = (ConsoleErrorHandler).new(null)
    if (((*options).thread_count < 1) or ((*options).thread_count > 32)) {
        &console_error_handler.report_error("Invalid thread_count: {}", cast([]^any) ([cast(^any) ((*options).thread_count)]), "", cast([](fmt: string, args: []^any)) ([]))
        @destruct(console_error_handler);
        return
    } else {}
    compiler : Rc[Compiler] = (Compiler).new((*options).thread_count, cast(^ErrorHandler) (^console_error_handler))
    main_workspace : Rc[Workspace] = &compiler.get().get_main_workspace()
    wd : String = match @tempvar_9((fs).get_working_directory()) {
        Result[String, ()].Ok($wd) -> wd
        Result[String, ()].Err(_) -> {
            (io).println("[FATAL] Failed to get working directory")
            @destruct(main_workspace);
            @destruct(compiler);
            @destruct(console_error_handler);
            return
        }
    }
    build_file : String = (fmt).format("{}/build.cheez", cast([]^any) ([cast(^any) (&wd.slice())]))
    &main_workspace.get().create_and_add_job((LoadFileJob).new(build_file))
    &(*&compiler.get()).user_defined_builtins.add(("_get_compiler", Symbol.NativeFunc((NativeFunctionWrapper).new(cast(Fn(^Interpreter)) ((interp: ^Interpreter) => {
        frame : ^StackFrame = &*interp.top_frame()
        &*frame.set_return(g_compiler)
    })))))
    &(*&compiler.get()).user_defined_builtins.add(("_println", Symbol.NativeFunc((NativeFunctionWrapper).new(cast(Fn(^Interpreter)) ((interp: ^Interpreter) => {
        frame : ^StackFrame = &*interp.top_frame()
        (io).set_console_foreground_color(ConsoleColor.Green)
        (io).formatln(cast(^any) ("{}"), cast([]^any) ([cast(^any) (&*frame.get_arg(0))]))
        (io).set_console_foreground_color(ConsoleColor.White)
    })))))
    &(*&compiler.get()).user_defined_builtins.add(("_print", Symbol.NativeFunc((NativeFunctionWrapper).new(cast(Fn(^Interpreter)) ((interp: ^Interpreter) => {
        frame : ^StackFrame = &*interp.top_frame()
        (io).set_console_foreground_color(ConsoleColor.Green)
        (io).format(cast(^any) ("{}"), cast([]^any) ([cast(^any) (&*frame.get_arg(0))]))
        (io).set_console_foreground_color(ConsoleColor.White)
    })))))
    &(*&compiler.get()).user_defined_builtins.add(("_debugbreak", Symbol.NativeFunc((NativeFunctionWrapper).new(cast(Fn(^Interpreter)) ((interp: ^Interpreter) => {})))))
    start : i64 = get_time_milliseconds()
    &compiler.get().start_compilation()
    &compiler.get().wait_until_done()
    end : i64 = get_time_milliseconds()
    dur : i64 = (end - start)
    g_logger.log("[Compiler] Compilation took {} ms", cast([]^any) ([cast(^any) (dur)]), "")
    @destruct(wd)
    @destruct(main_workspace)
    @destruct(compiler)
    @destruct(console_error_handler)
}

dump_tokens :: dump_tokens(file: string) {
    string_db : StringDatabase = (StringDatabase).new()
    match @tempvar_10((Lexer).from_file(file, &string_db)) {
        Result[Rc[Lexer], ()].Ok($lexer) -> {
            loop {
                tok : Token = &lexer.get().next_token()
                (io).formatln(cast(^any) ("{}"), cast([]^any) ([cast(^any) (tok)]))
                if ((tok).typ == TokenType.EOF) then break else {}
            }
        };
        @destruct(lexer);
        Result[Rc[Lexer], ()].Err(_) -> {
            (io).formatln(cast(^any) ("File not found '{}'"), cast([]^any) ([cast(^any) (file)]))
        }
    }
    @destruct(string_db)
}

#file preload.che
_C :  : import std.c

Platform :: enum<i64> { // size: 0, alignment: 1
    Unknown = 0
    Windows = 1
    Linux = 2
    OSX = 3
}

__platform__ : Platform = #anonymous {
    Platform.Windows
}

push_var :: push_var(var: Code, x: Code) #macro #transparent {
    #local
    prev :  = @insert(var)
    defer {
        @insert(var) = prev
    }
    @insert(var) = @insert(x)
}

try :: try(code: Code) #macro {
    match @insert(code, _break = break, _continue = continue) {
        Ok($val) -> val
        Err($err) -> {
            ReturnType :  : (@function_type()).return_type
            return if (ReturnType == bool) {
                false
            } else {
                TargetType :  : (ReturnType).E
                ErrorType :  : @typeof(err)
                if @type_has_trait(ErrorType, Into[TargetType]) {
                    (ReturnType).Err(cast() ((@typeof(err)).into(&err)))
                } else {
                    (ReturnType).Err(err)
                }
            }
        }
    }
}

try_with :: try_with(code: Code, with: Code) #macro {
    match @insert(code, _break = break, _continue = continue) {
        Ok($val) -> val
        Err($err) -> @insert(with, link = [err], _break = break, _continue = continue)
    }
}

Drop :: trait {
    drop :: f.Accept(this)
}

Memory :: struct { // size: 0, alignment: 1
    
}

impl Memory {
    drop(_: $T) {}
    // Polymorphic instances for drop(_: $T)
        /* T = (type, ^AstNode) */
        /*  */
        drop(_: ^AstNode) {}
        /* T = (type, ^CompilationJob) */
        /*  */
        drop(_: ^CompilationJob) {}
        /* T = (type, Option[^AstStruct]) */
        /*  */
        drop(_: Option[^AstStruct]) {}
        /* T = (type, Option[SourceFile]) */
        /*  */
        drop(_: Option[SourceFile]) {
            
            @destruct(_)
        }
        /* T = (type, Option[fn(fn(), ^Interpreter)]) */
        /*  */
        drop(_: Option[fn(fn(), ^Interpreter)]) {}
        /* T = (type, Rc[Workspace]) */
        /*  */
        drop(_: Rc[Workspace]) {
            
            @destruct(_)
        }
        /* T = (type, ^FiberContext) */
        /*  */
        drop(_: ^FiberContext) {}
        /* T = (type, Option[String]) */
        /*  */
        drop(_: Option[String]) {
            
            @destruct(_)
        }
        /* T = (type, (name: string, symbol: Symbol)) */
        /*  */
        drop(_: (name: string, symbol: Symbol)) {}
        /* T = (type, Option[Symbol]) */
        /*  */
        drop(_: Option[Symbol]) {}
        /* T = (type, ^AstDecl) */
        /*  */
        drop(_: ^AstDecl) {}
        /* T = (type, ^AstConstDecl) */
        /*  */
        drop(_: ^AstConstDecl) {}
        /* T = (type, Option[i64]) */
        /*  */
        drop(_: Option[i64]) {}
        /* T = (type, LineInfo) */
        /*  */
        drop(_: LineInfo) {}
        /* T = (type, VariableInfo) */
        /*  */
        drop(_: VariableInfo) {}
        /* T = (type, u64) */
        /*  */
        drop(_: u64) {}
        /* T = (type, i64) */
        /*  */
        drop(_: i64) {}
        /* T = (type, String) */
        /*  */
        drop(_: String) {
            
            @destruct(_)
        }
        /* T = (type, MainCommand) */
        /*  */
        drop(_: MainCommand) {
            
            @destruct(_)
        }
        /* T = (type, Bucket) */
        /*  */
        drop(_: Bucket) {}
        /* T = (type, Option[string]) */
        /*  */
        drop(_: Option[string]) {}
        /* T = (type, string) */
        /*  */
        drop(_: string) {}
        /* T = (type, (name: string, mem: ^TypeInfoStructMember, set: bool)) */
        /*  */
        drop(_: (name: string, mem: ^TypeInfoStructMember, set: bool)) {}
        /* T = (type, u16) */
        /*  */
        drop(_: u16) {}
        /* T = (type, u8) */
        /*  */
        drop(_: u8) {}
        /* T = (type, ^AstArgument) */
        /*  */
        drop(_: ^AstArgument) {}
        /* T = (type, ^AstMatchCase) */
        /*  */
        drop(_: ^AstMatchCase) {}
        /* T = (type, Thread) */
        /*  */
        drop(_: Thread) {
            
            @destruct(_)
        }
        /* T = (type, Mutex) */
        /*  */
        drop(_: Mutex) {
            
            @destruct(_)
        }
        /* T = (type, ^SourceFile) */
        /*  */
        drop(_: ^SourceFile) {}
        /* T = (type, Data) */
        /*  */
        drop(_: Data) {
            
            @destruct(_)
        }
        /* T = (type, Option[Array[^AstImpl]]) */
        /*  */
        drop(_: Option[Array[^AstImpl]]) {
            
            @destruct(_)
        }
        /* T = (type, ^AstImpl) */
        /*  */
        drop(_: ^AstImpl) {}
        /* T = (type, ^CompileStructMemberJob) */
        /*  */
        drop(_: ^CompileStructMemberJob) {}
        /* T = (type, Location) */
        /*  */
        drop(_: Location) {}
        /* T = (type, Map[TypeId, Array[^AstImpl]]) */
        /*  */
        drop(_: Map[TypeId, Array[^AstImpl]]) {
            
            @destruct(_)
        }
        /* T = (type, BumpBucket) */
        /*  */
        drop(_: BumpBucket) {}
        /* T = (type, ^AstStruct) */
        /*  */
        drop(_: ^AstStruct) {}
        /* T = (type, SourceFile) */
        /*  */
        drop(_: SourceFile) {
            
            @destruct(_)
        }
        /* T = (type, FunctionTypeWrapper) */
        /*  */
        drop(_: FunctionTypeWrapper) {}
        /* T = (type, fn(fn(), ^Interpreter)) */
        /*  */
        drop(_: fn(fn(), ^Interpreter)) {}
        /* T = (type, Symbol) */
        /*  */
        drop(_: Symbol) {}
        /* T = (type, FileLogger) */
        /*  */
        drop(_: FileLogger) {
            
            @destruct(_)
        }
        /* T = (type, Workspace) */
        /*  */
        drop(_: Workspace) {
            
            @destruct(_)
        }
        /* T = (type, DefaultCodeRunner) */
        /*  */
        drop(_: DefaultCodeRunner) {}
        /* T = (type, Compiler) */
        /*  */
        drop(_: Compiler) {
            
            @destruct(_)
        }
        /* T = (type, TypeId) */
        /*  */
        drop(_: TypeId) {}
        /* T = (type, Array[^AstImpl]) */
        /*  */
        drop(_: Array[^AstImpl]) {
            
            @destruct(_)
        }
        /* T = (type, Lexer) */
        /*  */
        drop(_: Lexer) {}
        /* T = (type, ByteCodeGenerator) */
        /*  */
        drop(_: ByteCodeGenerator) {
            
            @destruct(_)
        }
        /* T = (type, Token) */
        /*  */
        drop(_: Token) {}
    
}

Option :: enum<i64>(T: type) {
    None = 0
    Some : $T = 1
}
// Polymorphic instances for enum<i64>(T: type)
    // T = String
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : String = 1
    }
    // T = ^SourceFile
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : ^SourceFile = 1
    }
    // T = ^AstStruct
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : ^AstStruct = 1
    }
    // T = fn(fn(), ^Interpreter)
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : fn(fn(), ^Interpreter) = 1
    }
    // T = Location
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : Location = 1
    }
    // T = i64
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : i64 = 1
    }
    // T = ^AstNode
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : ^AstNode = 1
    }
    // T = &^AstStruct
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &^AstStruct = 1
    }
    // T = &SourceFile
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &SourceFile = 1
    }
    // T = &fn(fn(), ^Interpreter)
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &fn(fn(), ^Interpreter) = 1
    }
    // T = Rc[Workspace]
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : Rc[Workspace] = 1
    }
    // T = ^FiberContext
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : ^FiberContext = 1
    }
    // T = &String
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &String = 1
    }
    // T = (name: string, symbol: Symbol)
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : (name: string, symbol: Symbol) = 1
    }
    // T = Token
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : Token = 1
    }
    // T = string
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : string = 1
    }
    // T = &Symbol
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &Symbol = 1
    }
    // T = Map[TypeId, Array[^AstImpl]]
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : Map[TypeId, Array[^AstImpl]] = 1
    }
    // T = Mutex
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : Mutex = 1
    }
    // T = ^AstDecl
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : ^AstDecl = 1
    }
    // T = ^AstConstDecl
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : ^AstConstDecl = 1
    }
    // T = &i64
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &i64 = 1
    }
    // T = LineInfo
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : LineInfo = 1
    }
    // T = VariableInfo
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : VariableInfo = 1
    }
    // T = u64
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : u64 = 1
    }
    // T = SourceFile
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : SourceFile = 1
    }
    // T = FunctionTypeWrapper
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : FunctionTypeWrapper = 1
    }
    // T = Symbol
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : Symbol = 1
    }
    // T = TypeId
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : TypeId = 1
    }
    // T = Array[^AstImpl]
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : Array[^AstImpl] = 1
    }
    // T = Bucket
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : Bucket = 1
    }
    // T = &string
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &string = 1
    }
    // T = (name: string, mem: ^TypeInfoStructMember, set: bool)
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : (name: string, mem: ^TypeInfoStructMember, set: bool) = 1
    }
    // T = u16
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : u16 = 1
    }
    // T = u8
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : u8 = 1
    }
    // T = ^AstArgument
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : ^AstArgument = 1
    }
    // T = ^AstMatchCase
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : ^AstMatchCase = 1
    }
    // T = Thread
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : Thread = 1
    }
    // T = &Mutex
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &Mutex = 1
    }
    // T = &^SourceFile
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &^SourceFile = 1
    }
    // T = &Array[^AstImpl]
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &Array[^AstImpl] = 1
    }
    // T = ^AstImpl
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : ^AstImpl = 1
    }
    // T = ^CompileStructMemberJob
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : ^CompileStructMemberJob = 1
    }
    // T = &Location
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &Location = 1
    }
    // T = &Map[TypeId, Array[^AstImpl]]
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &Map[TypeId, Array[^AstImpl]] = 1
    }
    // T = BumpBucket
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : BumpBucket = 1
    }
    // T = &FunctionTypeWrapper
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &FunctionTypeWrapper = 1
    }
    // T = &TypeId
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &TypeId = 1
    }
    // T = &Token
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &Token = 1
    }
    // T = &u16
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &u16 = 1
    }
    // T = &^AstDecl
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &^AstDecl = 1
    }
    // T = &^AstNode
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &^AstNode = 1
    }
    // T = &Rc[Workspace]
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &Rc[Workspace] = 1
    }
    // T = &^FiberContext
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &^FiberContext = 1
    }
    // T = &Thread
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &Thread = 1
    }
    // T = &CodeRunner
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &CodeRunner = 1
    }
    // T = &(name: string, symbol: Symbol)
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &(name: string, symbol: Symbol) = 1
    }
    // T = &Compiler
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &Compiler = 1
    }
    // T = &Workspace
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &Workspace = 1
    }
    // T = &Lexer
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &Lexer = 1
    }
    // T = &u64
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &u64 = 1
    }
    // T = &Bucket
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &Bucket = 1
    }
    // T = &LineInfo
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &LineInfo = 1
    }
    // T = &VariableInfo
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &VariableInfo = 1
    }
    // T = Compiler
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : Compiler = 1
    }
    // T = Workspace
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : Workspace = 1
    }
    // T = Lexer
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : Lexer = 1
    }
    // T = &^AstConstDecl
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &^AstConstDecl = 1
    }
    // T = &^AstImpl
    enum<i64> { // size: 0, alignment: 1
        None = 0
        Some : &^AstImpl = 1
    }


Result :: enum<i64>(V: type, E: type) {
    Ok : $V = 0
    Err : $E = 1
}
// Polymorphic instances for enum<i64>(V: type, E: type)
    // V = (), E = FsError
    enum<i64> { // size: 0, alignment: 1
        Ok : () = 0
        Err : FsError = 1
    }
    // V = String, E = FsError
    enum<i64> { // size: 0, alignment: 1
        Ok : String = 0
        Err : FsError = 1
    }
    // V = Array[u8], E = FsError
    enum<i64> { // size: 0, alignment: 1
        Ok : Array[u8] = 0
        Err : FsError = 1
    }
    // V = String, E = ()
    enum<i64> { // size: 0, alignment: 1
        Ok : String = 0
        Err : () = 1
    }
    // V = Array[u16], E = ()
    enum<i64> { // size: 0, alignment: 1
        Ok : Array[u16] = 0
        Err : () = 1
    }
    // V = Option[^SourceFile], E = ()
    enum<i64> { // size: 0, alignment: 1
        Ok : Option[^SourceFile] = 0
        Err : () = 1
    }
    // V = string, E = ()
    enum<i64> { // size: 0, alignment: 1
        Ok : string = 0
        Err : () = 1
    }
    // V = Rc[Lexer], E = ()
    enum<i64> { // size: 0, alignment: 1
        Ok : Rc[Lexer] = 0
        Err : () = 1
    }
    // V = (), E = ()
    enum<i64> { // size: 0, alignment: 1
        Ok : () = 0
        Err : () = 1
    }


use Option

use Result

impl(T: type) Option[$T] if !@is_trait(T) {
    
}
// Polymorphic instances for impl(T: type) Option[$T] if !@is_trait(T)
    // T = (type, string)
    impl(T: type) Option[string] {
        unwrap(self: Option[string]) -> string {
            return match @tempvar_737(self) {
                Option[string].Some($v) -> v
                Option[string].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[string], def: string) -> string {
            return match @tempvar_738(self) {
                Option[string].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[string].None -> def
            }
        }
        
        map_ref(self: Option[&string], fun: fn(&string) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, Mutex)
    impl(T: type) Option[Mutex] {
        unwrap(self: Option[Mutex]) -> Mutex {
            return match @tempvar_769(self) {
                Option[Mutex].Some($v) -> v
                Option[Mutex].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[Mutex], def: Mutex) -> Mutex {
            return match @tempvar_770(self) {
                Option[Mutex].Some($v) -> {
                    (Memory).drop(def)
                    @tempvar_771(v)
                };
                @destruct(v);
                Option[Mutex].None -> def
            }
        }
        
        map_ref(self: Option[&Mutex], fun: fn(&Mutex) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, ^SourceFile)
    impl(T: type) Option[^SourceFile] {
        unwrap(self: Option[^SourceFile]) -> ^SourceFile {
            return match @tempvar_772(self) {
                Option[^SourceFile].Some($v) -> v
                Option[^SourceFile].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[^SourceFile], def: ^SourceFile) -> ^SourceFile {
            return match @tempvar_773(self) {
                Option[^SourceFile].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[^SourceFile].None -> def
            }
        }
        
        map_ref(self: Option[&^SourceFile], fun: fn(&^SourceFile) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, i64)
    impl(T: type) Option[i64] {
        unwrap(self: Option[i64]) -> i64 {
            return match @tempvar_790(self) {
                Option[i64].Some($v) -> v
                Option[i64].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[i64], def: i64) -> i64 {
            return match @tempvar_791(self) {
                Option[i64].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[i64].None -> def
            }
        }
        
        map_ref(self: Option[&i64], fun: fn(&i64) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, Location)
    impl(T: type) Option[Location] {
        unwrap(self: Option[Location]) -> Location {
            return match @tempvar_793(self) {
                Option[Location].Some($v) -> v
                Option[Location].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[Location], def: Location) -> Location {
            return match @tempvar_794(self) {
                Option[Location].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[Location].None -> def
            }
        }
        
        map_ref(self: Option[&Location], fun: fn(&Location) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, Map[TypeId, Array[^AstImpl]])
    impl(T: type) Option[Map[TypeId, Array[^AstImpl]]] {
        unwrap(self: Option[Map[TypeId, Array[^AstImpl]]]) -> Map[TypeId, Array[^AstImpl]] {
            return match @tempvar_797(self) {
                Option[Map[TypeId, Array[^AstImpl]]].Some($v) -> v
                Option[Map[TypeId, Array[^AstImpl]]].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[Map[TypeId, Array[^AstImpl]]], def: Map[TypeId, Array[^AstImpl]]) -> Map[TypeId, Array[^AstImpl]] {
            return match @tempvar_798(self) {
                Option[Map[TypeId, Array[^AstImpl]]].Some($v) -> {
                    (Memory).drop(def)
                    @tempvar_799(v)
                };
                @destruct(v);
                Option[Map[TypeId, Array[^AstImpl]]].None -> def
            }
        }
        
        map_ref(self: Option[&Map[TypeId, Array[^AstImpl]]], fun: fn(&Map[TypeId, Array[^AstImpl]]) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, ^AstStruct)
    impl(T: type) Option[^AstStruct] {
        unwrap(self: Option[^AstStruct]) -> ^AstStruct {
            return match @tempvar_802(self) {
                Option[^AstStruct].Some($v) -> v
                Option[^AstStruct].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[^AstStruct], def: ^AstStruct) -> ^AstStruct {
            return match @tempvar_803(self) {
                Option[^AstStruct].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[^AstStruct].None -> def
            }
        }
        
        map_ref(self: Option[&^AstStruct], fun: fn(&^AstStruct) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, SourceFile)
    impl(T: type) Option[SourceFile] {
        unwrap(self: Option[SourceFile]) -> SourceFile {
            return match @tempvar_804(self) {
                Option[SourceFile].Some($v) -> v
                Option[SourceFile].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[SourceFile], def: SourceFile) -> SourceFile {
            return match @tempvar_805(self) {
                Option[SourceFile].Some($v) -> {
                    (Memory).drop(def)
                    @tempvar_806(v)
                };
                @destruct(v);
                Option[SourceFile].None -> def
            }
        }
        
        map_ref(self: Option[&SourceFile], fun: fn(&SourceFile) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, FunctionTypeWrapper)
    impl(T: type) Option[FunctionTypeWrapper] {
        unwrap(self: Option[FunctionTypeWrapper]) -> FunctionTypeWrapper {
            return match @tempvar_807(self) {
                Option[FunctionTypeWrapper].Some($v) -> v
                Option[FunctionTypeWrapper].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[FunctionTypeWrapper], def: FunctionTypeWrapper) -> FunctionTypeWrapper {
            return match @tempvar_808(self) {
                Option[FunctionTypeWrapper].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[FunctionTypeWrapper].None -> def
            }
        }
        
        map_ref(self: Option[&FunctionTypeWrapper], fun: fn(&FunctionTypeWrapper) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, fn(fn(), ^Interpreter))
    impl(T: type) Option[fn(fn(), ^Interpreter)] {
        unwrap(self: Option[fn(fn(), ^Interpreter)]) -> fn(fn(), ^Interpreter) {
            return match @tempvar_809(self) {
                Option[fn(fn(), ^Interpreter)].Some($v) -> v
                Option[fn(fn(), ^Interpreter)].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[fn(fn(), ^Interpreter)], def: fn(fn(), ^Interpreter)) -> fn(fn(), ^Interpreter) {
            return match @tempvar_810(self) {
                Option[fn(fn(), ^Interpreter)].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[fn(fn(), ^Interpreter)].None -> def
            }
        }
        
        map_ref(self: Option[&fn(fn(), ^Interpreter)], fun: fn(&fn(fn(), ^Interpreter)) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, String)
    impl(T: type) Option[String] {
        unwrap(self: Option[String]) -> String {
            return match @tempvar_811(self) {
                Option[String].Some($v) -> v
                Option[String].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[String], def: String) -> String {
            return match @tempvar_812(self) {
                Option[String].Some($v) -> {
                    (Memory).drop(def)
                    @tempvar_813(v)
                };
                @destruct(v);
                Option[String].None -> def
            }
        }
        
        map_ref(self: Option[&String], fun: fn(&String) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, Symbol)
    impl(T: type) Option[Symbol] {
        unwrap(self: Option[Symbol]) -> Symbol {
            return match @tempvar_815(self) {
                Option[Symbol].Some($v) -> v
                Option[Symbol].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[Symbol], def: Symbol) -> Symbol {
            return match @tempvar_816(self) {
                Option[Symbol].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[Symbol].None -> def
            }
        }
        
        map_ref(self: Option[&Symbol], fun: fn(&Symbol) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, TypeId)
    impl(T: type) Option[TypeId] {
        unwrap(self: Option[TypeId]) -> TypeId {
            return match @tempvar_827(self) {
                Option[TypeId].Some($v) -> v
                Option[TypeId].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[TypeId], def: TypeId) -> TypeId {
            return match @tempvar_828(self) {
                Option[TypeId].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[TypeId].None -> def
            }
        }
        
        map_ref(self: Option[&TypeId], fun: fn(&TypeId) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, Array[^AstImpl])
    impl(T: type) Option[Array[^AstImpl]] {
        unwrap(self: Option[Array[^AstImpl]]) -> Array[^AstImpl] {
            return match @tempvar_829(self) {
                Option[Array[^AstImpl]].Some($v) -> v
                Option[Array[^AstImpl]].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[Array[^AstImpl]], def: Array[^AstImpl]) -> Array[^AstImpl] {
            return match @tempvar_830(self) {
                Option[Array[^AstImpl]].Some($v) -> {
                    (Memory).drop(def)
                    @tempvar_831(v)
                };
                @destruct(v);
                Option[Array[^AstImpl]].None -> def
            }
        }
        
        map_ref(self: Option[&Array[^AstImpl]], fun: fn(&Array[^AstImpl]) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, Token)
    impl(T: type) Option[Token] {
        unwrap(self: Option[Token]) -> Token {
            return match @tempvar_832(self) {
                Option[Token].Some($v) -> v
                Option[Token].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[Token], def: Token) -> Token {
            return match @tempvar_833(self) {
                Option[Token].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[Token].None -> def
            }
        }
        
        map_ref(self: Option[&Token], fun: fn(&Token) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, u16)
    impl(T: type) Option[u16] {
        unwrap(self: Option[u16]) -> u16 {
            return match @tempvar_837(self) {
                Option[u16].Some($v) -> v
                Option[u16].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[u16], def: u16) -> u16 {
            return match @tempvar_838(self) {
                Option[u16].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[u16].None -> def
            }
        }
        
        map_ref(self: Option[&u16], fun: fn(&u16) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, ^AstDecl)
    impl(T: type) Option[^AstDecl] {
        unwrap(self: Option[^AstDecl]) -> ^AstDecl {
            return match @tempvar_840(self) {
                Option[^AstDecl].Some($v) -> v
                Option[^AstDecl].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[^AstDecl], def: ^AstDecl) -> ^AstDecl {
            return match @tempvar_841(self) {
                Option[^AstDecl].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[^AstDecl].None -> def
            }
        }
        
        map_ref(self: Option[&^AstDecl], fun: fn(&^AstDecl) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, ^AstNode)
    impl(T: type) Option[^AstNode] {
        unwrap(self: Option[^AstNode]) -> ^AstNode {
            return match @tempvar_842(self) {
                Option[^AstNode].Some($v) -> v
                Option[^AstNode].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[^AstNode], def: ^AstNode) -> ^AstNode {
            return match @tempvar_843(self) {
                Option[^AstNode].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[^AstNode].None -> def
            }
        }
        
        map_ref(self: Option[&^AstNode], fun: fn(&^AstNode) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, Rc[Workspace])
    impl(T: type) Option[Rc[Workspace]] {
        unwrap(self: Option[Rc[Workspace]]) -> Rc[Workspace] {
            return match @tempvar_844(self) {
                Option[Rc[Workspace]].Some($v) -> v
                Option[Rc[Workspace]].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[Rc[Workspace]], def: Rc[Workspace]) -> Rc[Workspace] {
            return match @tempvar_845(self) {
                Option[Rc[Workspace]].Some($v) -> {
                    (Memory).drop(def)
                    @tempvar_846(v)
                };
                @destruct(v);
                Option[Rc[Workspace]].None -> def
            }
        }
        
        map_ref(self: Option[&Rc[Workspace]], fun: fn(&Rc[Workspace]) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, ^FiberContext)
    impl(T: type) Option[^FiberContext] {
        unwrap(self: Option[^FiberContext]) -> ^FiberContext {
            return match @tempvar_847(self) {
                Option[^FiberContext].Some($v) -> v
                Option[^FiberContext].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[^FiberContext], def: ^FiberContext) -> ^FiberContext {
            return match @tempvar_848(self) {
                Option[^FiberContext].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[^FiberContext].None -> def
            }
        }
        
        map_ref(self: Option[&^FiberContext], fun: fn(&^FiberContext) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, Thread)
    impl(T: type) Option[Thread] {
        unwrap(self: Option[Thread]) -> Thread {
            return match @tempvar_849(self) {
                Option[Thread].Some($v) -> v
                Option[Thread].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[Thread], def: Thread) -> Thread {
            return match @tempvar_850(self) {
                Option[Thread].Some($v) -> {
                    (Memory).drop(def)
                    @tempvar_851(v)
                };
                @destruct(v);
                Option[Thread].None -> def
            }
        }
        
        map_ref(self: Option[&Thread], fun: fn(&Thread) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, (name: string, symbol: Symbol))
    impl(T: type) Option[(name: string, symbol: Symbol)] {
        unwrap(self: Option[(name: string, symbol: Symbol)]) -> (name: string, symbol: Symbol) {
            return match @tempvar_854(self) {
                Option[(name: string, symbol: Symbol)].Some($v) -> v
                Option[(name: string, symbol: Symbol)].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[(name: string, symbol: Symbol)], def: (name: string, symbol: Symbol)) -> (name: string, symbol: Symbol) {
            return match @tempvar_855(self) {
                Option[(name: string, symbol: Symbol)].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[(name: string, symbol: Symbol)].None -> def
            }
        }
        
        map_ref(self: Option[&(name: string, symbol: Symbol)], fun: fn(&(name: string, symbol: Symbol)) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, u64)
    impl(T: type) Option[u64] {
        unwrap(self: Option[u64]) -> u64 {
            return match @tempvar_862(self) {
                Option[u64].Some($v) -> v
                Option[u64].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[u64], def: u64) -> u64 {
            return match @tempvar_863(self) {
                Option[u64].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[u64].None -> def
            }
        }
        
        map_ref(self: Option[&u64], fun: fn(&u64) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, Bucket)
    impl(T: type) Option[Bucket] {
        unwrap(self: Option[Bucket]) -> Bucket {
            return match @tempvar_865(self) {
                Option[Bucket].Some($v) -> v
                Option[Bucket].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[Bucket], def: Bucket) -> Bucket {
            return match @tempvar_866(self) {
                Option[Bucket].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[Bucket].None -> def
            }
        }
        
        map_ref(self: Option[&Bucket], fun: fn(&Bucket) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, LineInfo)
    impl(T: type) Option[LineInfo] {
        unwrap(self: Option[LineInfo]) -> LineInfo {
            return match @tempvar_867(self) {
                Option[LineInfo].Some($v) -> v
                Option[LineInfo].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[LineInfo], def: LineInfo) -> LineInfo {
            return match @tempvar_868(self) {
                Option[LineInfo].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[LineInfo].None -> def
            }
        }
        
        map_ref(self: Option[&LineInfo], fun: fn(&LineInfo) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, VariableInfo)
    impl(T: type) Option[VariableInfo] {
        unwrap(self: Option[VariableInfo]) -> VariableInfo {
            return match @tempvar_869(self) {
                Option[VariableInfo].Some($v) -> v
                Option[VariableInfo].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[VariableInfo], def: VariableInfo) -> VariableInfo {
            return match @tempvar_870(self) {
                Option[VariableInfo].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[VariableInfo].None -> def
            }
        }
        
        map_ref(self: Option[&VariableInfo], fun: fn(&VariableInfo) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, Compiler)
    impl(T: type) Option[Compiler] {
        unwrap(self: Option[Compiler]) -> Compiler {
            return match @tempvar_871(self) {
                Option[Compiler].Some($v) -> v
                Option[Compiler].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[Compiler], def: Compiler) -> Compiler {
            return match @tempvar_872(self) {
                Option[Compiler].Some($v) -> {
                    (Memory).drop(def)
                    @tempvar_873(v)
                };
                @destruct(v);
                Option[Compiler].None -> def
            }
        }
        
        map_ref(self: Option[&Compiler], fun: fn(&Compiler) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, Workspace)
    impl(T: type) Option[Workspace] {
        unwrap(self: Option[Workspace]) -> Workspace {
            return match @tempvar_874(self) {
                Option[Workspace].Some($v) -> v
                Option[Workspace].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[Workspace], def: Workspace) -> Workspace {
            return match @tempvar_875(self) {
                Option[Workspace].Some($v) -> {
                    (Memory).drop(def)
                    @tempvar_876(v)
                };
                @destruct(v);
                Option[Workspace].None -> def
            }
        }
        
        map_ref(self: Option[&Workspace], fun: fn(&Workspace) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, Lexer)
    impl(T: type) Option[Lexer] {
        unwrap(self: Option[Lexer]) -> Lexer {
            return match @tempvar_877(self) {
                Option[Lexer].Some($v) -> v
                Option[Lexer].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[Lexer], def: Lexer) -> Lexer {
            return match @tempvar_878(self) {
                Option[Lexer].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[Lexer].None -> def
            }
        }
        
        map_ref(self: Option[&Lexer], fun: fn(&Lexer) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, ^AstConstDecl)
    impl(T: type) Option[^AstConstDecl] {
        unwrap(self: Option[^AstConstDecl]) -> ^AstConstDecl {
            return match @tempvar_880(self) {
                Option[^AstConstDecl].Some($v) -> v
                Option[^AstConstDecl].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[^AstConstDecl], def: ^AstConstDecl) -> ^AstConstDecl {
            return match @tempvar_881(self) {
                Option[^AstConstDecl].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[^AstConstDecl].None -> def
            }
        }
        
        map_ref(self: Option[&^AstConstDecl], fun: fn(&^AstConstDecl) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }
    // T = (type, ^AstImpl)
    impl(T: type) Option[^AstImpl] {
        unwrap(self: Option[^AstImpl]) -> ^AstImpl {
            return match @tempvar_882(self) {
                Option[^AstImpl].Some($v) -> v
                Option[^AstImpl].None -> @assert(false)
            }
        }
        
        unwrap_or(self: Option[^AstImpl], def: ^AstImpl) -> ^AstImpl {
            return match @tempvar_883(self) {
                Option[^AstImpl].Some($v) -> {
                    (Memory).drop(def)
                    v
                }
                Option[^AstImpl].None -> def
            }
        }
        
        map_ref(self: Option[&^AstImpl], fun: fn(&^AstImpl) -> $K) -> Option[K] {
            return match self {
                Some($value) -> Some(fun(value))
                None -> None
            }
        }
    }


impl(V: type, E: type) Result[$V, $E] {
    
}
// Polymorphic instances for impl(V: type, E: type) Result[$V, $E]
    // V = (type, ()), E = (type, FsError)
    impl(V: type, E: type) Result[(), FsError] {
        unwrap(self: Result[(), FsError]) -> () {
            return match @tempvar_740(self) {
                Result[(), FsError].Ok($v) -> v
                Result[(), FsError].Err(_) -> @assert(false)
            }
        }
    }
    // V = (type, String), E = (type, ())
    impl(V: type, E: type) Result[String, ()] {
        unwrap(self: Result[String, ()]) -> String {
            return match @tempvar_751(self) {
                Result[String, ()].Ok($v) -> v
                Result[String, ()].Err(_) -> @assert(false)
            }
        }
    }
    // V = (type, ()), E = (type, ())
    impl(V: type, E: type) Result[(), ()] {
        unwrap(self: Result[(), ()]) -> () {
            return match @tempvar_766(self) {
                Result[(), ()].Ok($v) -> v
                Result[(), ()].Err(_) -> @assert(false)
            }
        }
    }
    // V = (type, Option[^SourceFile]), E = (type, ())
    impl(V: type, E: type) Result[Option[^SourceFile], ()] {
        unwrap(self: Result[Option[^SourceFile], ()]) -> Option[^SourceFile] {
            return match @tempvar_774(self) {
                Result[Option[^SourceFile], ()].Ok($v) -> v
                Result[Option[^SourceFile], ()].Err(_) -> @assert(false)
            }
        }
    }
    // V = (type, string), E = (type, ())
    impl(V: type, E: type) Result[string, ()] {
        unwrap(self: Result[string, ()]) -> string {
            return match @tempvar_783(self) {
                Result[string, ()].Ok($v) -> v
                Result[string, ()].Err(_) -> @assert(false)
            }
        }
    }
    // V = (type, Array[u16]), E = (type, ())
    impl(V: type, E: type) Result[Array[u16], ()] {
        unwrap(self: Result[Array[u16], ()]) -> Array[u16] {
            return match @tempvar_835(self) {
                Result[Array[u16], ()].Ok($v) -> v
                Result[Array[u16], ()].Err(_) -> @assert(false)
            }
        }
    }
    // V = (type, Rc[Lexer]), E = (type, ())
    impl(V: type, E: type) Result[Rc[Lexer], ()] {
        unwrap(self: Result[Rc[Lexer], ()]) -> Rc[Lexer] {
            return match @tempvar_879(self) {
                Result[Rc[Lexer], ()].Ok($v) -> v
                Result[Rc[Lexer], ()].Err(_) -> @assert(false)
            }
        }
    }


From :: trait(T: type) {
    from :: f.Accept(this)
}
// Polymorphic instances for From
    // T = ()
    trait {
        from :: f.Accept(this)
    }


Into :: trait(T: type) {
    into :: f.Accept(this)
}
// Polymorphic instances for Into
    // T = ()
    trait {
        into :: f.Accept(this)
    }
    // T = String
    trait {
        into :: f.Accept(this)
    }
    // T = Array[string]
    trait {
        into :: f.Accept(this)
    }
    // T = Array[String]
    trait {
        into :: f.Accept(this)
    }
    // T = Array[Rc[Workspace]]
    trait {
        into :: f.Accept(this)
    }


impl Into[()] for () {
    into(self: &()) -> () {
        return ()
    }
}

impl From[()] for () {
    from(value: ()) -> () {
        return ()
    }
}

convert : (T: type, c: &$S) : convert(T: type, c: &$S) {
    if (T == S) then *c else (c).into()
}
// Polymorphic instances for convert(T: type, c: &$S)
    /* S = (type, string) */
    /*  */
    convert(T: type, c: &string) #macro {
        if (T == S) then *c else (c).into()
    }
    /* S = (type, i64) */
    /*  */
    convert(T: type, c: &i64) #macro {
        if (T == S) then *c else (c).into()
    }
    /* S = (type, TypeId) */
    /*  */
    convert(T: type, c: &TypeId) #macro {
        if (T == S) then *c else (c).into()
    }
    /* S = (type, FunctionTypeWrapper) */
    /*  */
    convert(T: type, c: &FunctionTypeWrapper) #macro {
        if (T == S) then *c else (c).into()
    }


Clone :: trait {
    clone :: f.Accept(this)
}

impl Clone for string {
    clone(self: &string) -> string {
        return *self
    }
}

Equatable :: trait(T: type) {
    equal :: f.Accept(this)
}
// Polymorphic instances for Equatable
    // T = i64
    trait {
        equal :: f.Accept(this)
    }
    // T = TypeId
    trait {
        equal :: f.Accept(this)
    }
    // T = String
    trait {
        equal :: f.Accept(this)
    }
    // T = string
    trait {
        equal :: f.Accept(this)
    }
    // T = FunctionTypeWrapper
    trait {
        equal :: f.Accept(this)
    }


impl Equatable[i64] for i64 {
    equal(self: &i64, other: &i64) -> bool {
        return (*self == *other)
    }
}

impl Equatable[TypeId] for TypeId {
    equal(self: &TypeId, other: &TypeId) -> bool {
        return (cast(^void) ((*self).ptr) == cast(^void) ((*other).ptr))
    }
}

Range :: struct(T: type) {
    start :  = default
    end :  = default
}
// Polymorphic instances for struct(T: type)
    // T = i64
    struct { // size: 16, alignment: 8
        start : i64 = default
        end : i64 = default
    }


RangeInclusive :: struct(T: type) {
    start :  = default
    end :  = default
}
// Polymorphic instances for struct(T: type)
    // T = i64
    struct { // size: 16, alignment: 8
        start : i64 = default
        end : i64 = default
    }


RangeFrom :: struct(T: type) {
    start :  = default
}
// Polymorphic instances for struct(T: type)
    // T = i64
    struct { // size: 8, alignment: 8
        start : i64 = default
    }


RangeTo :: struct(T: type) {
    end :  = default
}
// Polymorphic instances for struct(T: type)
    // T = i64
    struct { // size: 8, alignment: 8
        end : i64 = default
    }


RangeToInclusive :: struct(T: type) {
    end :  = default
}
// Polymorphic instances for struct(T: type)
    // T = i64
    struct { // size: 8, alignment: 8
        end : i64 = default
    }


RangeFull :: struct { // size: 0, alignment: 1
    
}

impl(T: type) Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(T: type) Cheez.Types.Abstract.GenericStructType
    // T = (type, i64)
    impl(T: type) Range[i64] {
        reverse(self: Range[i64]) -> Range[i64] {
            return new Range[i64] { start = ((self).end - 1), end = ((self).start - 1) }
        }
    }


impl string {
    get_index(self: string, index: i64) -> &u8 #operator("[]") {
        return get_index((self).bytes, index)
    }
    
    get_range(self: string, range: Range[i64]) -> string #operator("[]") {
        data : i64 = (cast(i64) (((self).bytes).data) + (range).start)
        length : i64 = ((range).end - (range).start)
        return @string_from_ptr_and_length(cast (data), length)
    }
    
    get_range_inclusive(self: string, range: RangeInclusive[i64]) -> string #operator("[]") {
        data : i64 = (cast(i64) (((self).bytes).data) + (range).start)
        length : i64 = (((range).end - (range).start) + 1)
        return @string_from_ptr_and_length(cast (data), length)
    }
    
    get_range_to(self: string, range: RangeTo[i64]) -> string #operator("[]") {
        @assert((((range).end >= 0) and ((range).end <= ((self).bytes).length)))
        data : i64 = cast(i64) (((self).bytes).data)
        length : i64 = (range).end
        return @string_from_ptr_and_length(cast (data), length)
    }
    
    get_range_to_incl(self: string, range: RangeToInclusive[i64]) -> string #operator("[]") {
        @assert((((range).end >= 0) and ((range).end < ((self).bytes).length)))
        data : i64 = cast(i64) (((self).bytes).data)
        length : i64 = ((range).end + 1)
        return @string_from_ptr_and_length(cast (data), length)
    }
    
    get_range_from(self: string, range: RangeFrom[i64]) -> string #operator("[]") {
        if !(((range).start >= 0) and ((range).start <= ((self).bytes).length)) {
            (_C).printf("%lld, %lld`n", (range).start, ((self).bytes).length)
        } else {}
        @assert((((range).start >= 0) and ((range).start <= ((self).bytes).length)))
        data : i64 = (cast(i64) (((self).bytes).data) + (range).start)
        length : i64 = (((self).bytes).length - (range).start)
        return @string_from_ptr_and_length(cast (data), length)
    }
    
    get_range_full(self: string, range: RangeFull) -> string #operator("[]") {
        return self
    }
}

impl(T: type) []$T {
    
}
// Polymorphic instances for impl(T: type) []$T
    // T = (type, u8)
    impl(T: type) []u8 {
        get_index(self: []u8, index: i64) -> &u8 #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []u8, range: Range[i64]) -> []u8 #operator("[]") {
            result : []u8 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u8))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []u8, range: RangeInclusive[i64]) -> []u8 #operator("[]") {
            result : []u8 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u8))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []u8, range: RangeTo[i64]) -> []u8 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []u8 = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []u8, range: RangeToInclusive[i64]) -> []u8 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []u8 = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []u8, range: RangeFrom[i64]) -> []u8 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []u8 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u8))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []u8, range: RangeFull) -> []u8 #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, Entry[string, string])
    impl(T: type) []Entry[string, string] {
        get_index(self: []Entry[string, string], index: i64) -> &Entry[string, string] #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []Entry[string, string], range: Range[i64]) -> []Entry[string, string] #operator("[]") {
            result : []Entry[string, string] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[string, string]))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []Entry[string, string], range: RangeInclusive[i64]) -> []Entry[string, string] #operator("[]") {
            result : []Entry[string, string] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[string, string]))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []Entry[string, string], range: RangeTo[i64]) -> []Entry[string, string] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []Entry[string, string] = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []Entry[string, string], range: RangeToInclusive[i64]) -> []Entry[string, string] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []Entry[string, string] = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []Entry[string, string], range: RangeFrom[i64]) -> []Entry[string, string] #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []Entry[string, string] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[string, string]))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []Entry[string, string], range: RangeFull) -> []Entry[string, string] #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, ^any)
    impl(T: type) []^any {
        get_index(self: []^any, index: i64) -> &^any #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []^any, range: Range[i64]) -> []^any #operator("[]") {
            result : []^any = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^any))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []^any, range: RangeInclusive[i64]) -> []^any #operator("[]") {
            result : []^any = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^any))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []^any, range: RangeTo[i64]) -> []^any #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []^any = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []^any, range: RangeToInclusive[i64]) -> []^any #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []^any = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []^any, range: RangeFrom[i64]) -> []^any #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []^any = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^any))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []^any, range: RangeFull) -> []^any #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, string)
    impl(T: type) []string {
        get_index(self: []string, index: i64) -> &string #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []string, range: Range[i64]) -> []string #operator("[]") {
            result : []string = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(string))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []string, range: RangeInclusive[i64]) -> []string #operator("[]") {
            result : []string = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(string))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []string, range: RangeTo[i64]) -> []string #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []string = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []string, range: RangeToInclusive[i64]) -> []string #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []string = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []string, range: RangeFrom[i64]) -> []string #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []string = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(string))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []string, range: RangeFull) -> []string #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, String)
    impl(T: type) []String {
        get_index(self: []String, index: i64) -> &String #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []String, range: Range[i64]) -> []String #operator("[]") {
            result : []String = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(String))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []String, range: RangeInclusive[i64]) -> []String #operator("[]") {
            result : []String = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(String))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []String, range: RangeTo[i64]) -> []String #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []String = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []String, range: RangeToInclusive[i64]) -> []String #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []String = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []String, range: RangeFrom[i64]) -> []String #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []String = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(String))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []String, range: RangeFull) -> []String #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, TypeInfoEnumMember)
    impl(T: type) []TypeInfoEnumMember {
        get_index(self: []TypeInfoEnumMember, index: i64) -> &TypeInfoEnumMember #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []TypeInfoEnumMember, range: Range[i64]) -> []TypeInfoEnumMember #operator("[]") {
            result : []TypeInfoEnumMember = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoEnumMember))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []TypeInfoEnumMember, range: RangeInclusive[i64]) -> []TypeInfoEnumMember #operator("[]") {
            result : []TypeInfoEnumMember = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoEnumMember))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []TypeInfoEnumMember, range: RangeTo[i64]) -> []TypeInfoEnumMember #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []TypeInfoEnumMember = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []TypeInfoEnumMember, range: RangeToInclusive[i64]) -> []TypeInfoEnumMember #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []TypeInfoEnumMember = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []TypeInfoEnumMember, range: RangeFrom[i64]) -> []TypeInfoEnumMember #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []TypeInfoEnumMember = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoEnumMember))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []TypeInfoEnumMember, range: RangeFull) -> []TypeInfoEnumMember #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, TypeInfoStructMember)
    impl(T: type) []TypeInfoStructMember {
        get_index(self: []TypeInfoStructMember, index: i64) -> &TypeInfoStructMember #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []TypeInfoStructMember, range: Range[i64]) -> []TypeInfoStructMember #operator("[]") {
            result : []TypeInfoStructMember = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoStructMember))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []TypeInfoStructMember, range: RangeInclusive[i64]) -> []TypeInfoStructMember #operator("[]") {
            result : []TypeInfoStructMember = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoStructMember))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []TypeInfoStructMember, range: RangeTo[i64]) -> []TypeInfoStructMember #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []TypeInfoStructMember = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []TypeInfoStructMember, range: RangeToInclusive[i64]) -> []TypeInfoStructMember #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []TypeInfoStructMember = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []TypeInfoStructMember, range: RangeFrom[i64]) -> []TypeInfoStructMember #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []TypeInfoStructMember = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoStructMember))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []TypeInfoStructMember, range: RangeFull) -> []TypeInfoStructMember #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, TypeInfoTupleMember)
    impl(T: type) []TypeInfoTupleMember {
        get_index(self: []TypeInfoTupleMember, index: i64) -> &TypeInfoTupleMember #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []TypeInfoTupleMember, range: Range[i64]) -> []TypeInfoTupleMember #operator("[]") {
            result : []TypeInfoTupleMember = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoTupleMember))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []TypeInfoTupleMember, range: RangeInclusive[i64]) -> []TypeInfoTupleMember #operator("[]") {
            result : []TypeInfoTupleMember = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoTupleMember))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []TypeInfoTupleMember, range: RangeTo[i64]) -> []TypeInfoTupleMember #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []TypeInfoTupleMember = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []TypeInfoTupleMember, range: RangeToInclusive[i64]) -> []TypeInfoTupleMember #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []TypeInfoTupleMember = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []TypeInfoTupleMember, range: RangeFrom[i64]) -> []TypeInfoTupleMember #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []TypeInfoTupleMember = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoTupleMember))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []TypeInfoTupleMember, range: RangeFull) -> []TypeInfoTupleMember #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, void)
    impl(T: type) []void {
        get_index(self: []void, index: i64) -> &void #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []void, range: Range[i64]) -> []void #operator("[]") {
            result : []void = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(void))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []void, range: RangeInclusive[i64]) -> []void #operator("[]") {
            result : []void = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(void))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []void, range: RangeTo[i64]) -> []void #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []void = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []void, range: RangeToInclusive[i64]) -> []void #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []void = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []void, range: RangeFrom[i64]) -> []void #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []void = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(void))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []void, range: RangeFull) -> []void #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, u16)
    impl(T: type) []u16 {
        get_index(self: []u16, index: i64) -> &u16 #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []u16, range: Range[i64]) -> []u16 #operator("[]") {
            result : []u16 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u16))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []u16, range: RangeInclusive[i64]) -> []u16 #operator("[]") {
            result : []u16 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u16))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []u16, range: RangeTo[i64]) -> []u16 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []u16 = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []u16, range: RangeToInclusive[i64]) -> []u16 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []u16 = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []u16, range: RangeFrom[i64]) -> []u16 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []u16 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u16))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []u16, range: RangeFull) -> []u16 #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, TypeInfoAttribute)
    impl(T: type) []TypeInfoAttribute {
        get_index(self: []TypeInfoAttribute, index: i64) -> &TypeInfoAttribute #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []TypeInfoAttribute, range: Range[i64]) -> []TypeInfoAttribute #operator("[]") {
            result : []TypeInfoAttribute = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoAttribute))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []TypeInfoAttribute, range: RangeInclusive[i64]) -> []TypeInfoAttribute #operator("[]") {
            result : []TypeInfoAttribute = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoAttribute))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []TypeInfoAttribute, range: RangeTo[i64]) -> []TypeInfoAttribute #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []TypeInfoAttribute = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []TypeInfoAttribute, range: RangeToInclusive[i64]) -> []TypeInfoAttribute #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []TypeInfoAttribute = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []TypeInfoAttribute, range: RangeFrom[i64]) -> []TypeInfoAttribute #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []TypeInfoAttribute = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoAttribute))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []TypeInfoAttribute, range: RangeFull) -> []TypeInfoAttribute #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, TypeInfoTraitFunction)
    impl(T: type) []TypeInfoTraitFunction {
        get_index(self: []TypeInfoTraitFunction, index: i64) -> &TypeInfoTraitFunction #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []TypeInfoTraitFunction, range: Range[i64]) -> []TypeInfoTraitFunction #operator("[]") {
            result : []TypeInfoTraitFunction = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoTraitFunction))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []TypeInfoTraitFunction, range: RangeInclusive[i64]) -> []TypeInfoTraitFunction #operator("[]") {
            result : []TypeInfoTraitFunction = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoTraitFunction))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []TypeInfoTraitFunction, range: RangeTo[i64]) -> []TypeInfoTraitFunction #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []TypeInfoTraitFunction = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []TypeInfoTraitFunction, range: RangeToInclusive[i64]) -> []TypeInfoTraitFunction #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []TypeInfoTraitFunction = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []TypeInfoTraitFunction, range: RangeFrom[i64]) -> []TypeInfoTraitFunction #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []TypeInfoTraitFunction = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoTraitFunction))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []TypeInfoTraitFunction, range: RangeFull) -> []TypeInfoTraitFunction #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, ^Printable)
    impl(T: type) []^Printable {
        get_index(self: []^Printable, index: i64) -> &^Printable #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []^Printable, range: Range[i64]) -> []^Printable #operator("[]") {
            result : []^Printable = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^Printable))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []^Printable, range: RangeInclusive[i64]) -> []^Printable #operator("[]") {
            result : []^Printable = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^Printable))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []^Printable, range: RangeTo[i64]) -> []^Printable #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []^Printable = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []^Printable, range: RangeToInclusive[i64]) -> []^Printable #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []^Printable = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []^Printable, range: RangeFrom[i64]) -> []^Printable #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []^Printable = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^Printable))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []^Printable, range: RangeFull) -> []^Printable #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, (fmt: string, args: []^any))
    impl(T: type) [](fmt: string, args: []^any) {
        get_index(self: [](fmt: string, args: []^any), index: i64) -> &(fmt: string, args: []^any) #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: [](fmt: string, args: []^any), range: Range[i64]) -> [](fmt: string, args: []^any) #operator("[]") {
            result : [](fmt: string, args: []^any) = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof((fmt: string, args: []^any)))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: [](fmt: string, args: []^any), range: RangeInclusive[i64]) -> [](fmt: string, args: []^any) #operator("[]") {
            result : [](fmt: string, args: []^any) = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof((fmt: string, args: []^any)))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: [](fmt: string, args: []^any), range: RangeTo[i64]) -> [](fmt: string, args: []^any) #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : [](fmt: string, args: []^any) = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: [](fmt: string, args: []^any), range: RangeToInclusive[i64]) -> [](fmt: string, args: []^any) #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : [](fmt: string, args: []^any) = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: [](fmt: string, args: []^any), range: RangeFrom[i64]) -> [](fmt: string, args: []^any) #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : [](fmt: string, args: []^any) = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof((fmt: string, args: []^any)))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: [](fmt: string, args: []^any), range: RangeFull) -> [](fmt: string, args: []^any) #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, TypeInfoImplFunction)
    impl(T: type) []TypeInfoImplFunction {
        get_index(self: []TypeInfoImplFunction, index: i64) -> &TypeInfoImplFunction #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []TypeInfoImplFunction, range: Range[i64]) -> []TypeInfoImplFunction #operator("[]") {
            result : []TypeInfoImplFunction = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoImplFunction))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []TypeInfoImplFunction, range: RangeInclusive[i64]) -> []TypeInfoImplFunction #operator("[]") {
            result : []TypeInfoImplFunction = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoImplFunction))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []TypeInfoImplFunction, range: RangeTo[i64]) -> []TypeInfoImplFunction #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []TypeInfoImplFunction = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []TypeInfoImplFunction, range: RangeToInclusive[i64]) -> []TypeInfoImplFunction #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []TypeInfoImplFunction = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []TypeInfoImplFunction, range: RangeFrom[i64]) -> []TypeInfoImplFunction #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []TypeInfoImplFunction = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoImplFunction))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []TypeInfoImplFunction, range: RangeFull) -> []TypeInfoImplFunction #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, Entry[TypeId, Array[^AstImpl]])
    impl(T: type) []Entry[TypeId, Array[^AstImpl]] {
        get_index(self: []Entry[TypeId, Array[^AstImpl]], index: i64) -> &Entry[TypeId, Array[^AstImpl]] #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []Entry[TypeId, Array[^AstImpl]], range: Range[i64]) -> []Entry[TypeId, Array[^AstImpl]] #operator("[]") {
            result : []Entry[TypeId, Array[^AstImpl]] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[TypeId, Array[^AstImpl]]))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []Entry[TypeId, Array[^AstImpl]], range: RangeInclusive[i64]) -> []Entry[TypeId, Array[^AstImpl]] #operator("[]") {
            result : []Entry[TypeId, Array[^AstImpl]] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[TypeId, Array[^AstImpl]]))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []Entry[TypeId, Array[^AstImpl]], range: RangeTo[i64]) -> []Entry[TypeId, Array[^AstImpl]] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []Entry[TypeId, Array[^AstImpl]] = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []Entry[TypeId, Array[^AstImpl]], range: RangeToInclusive[i64]) -> []Entry[TypeId, Array[^AstImpl]] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []Entry[TypeId, Array[^AstImpl]] = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []Entry[TypeId, Array[^AstImpl]], range: RangeFrom[i64]) -> []Entry[TypeId, Array[^AstImpl]] #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []Entry[TypeId, Array[^AstImpl]] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[TypeId, Array[^AstImpl]]))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []Entry[TypeId, Array[^AstImpl]], range: RangeFull) -> []Entry[TypeId, Array[^AstImpl]] #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, ^TypeInfo)
    impl(T: type) []^TypeInfo {
        get_index(self: []^TypeInfo, index: i64) -> &^TypeInfo #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []^TypeInfo, range: Range[i64]) -> []^TypeInfo #operator("[]") {
            result : []^TypeInfo = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^TypeInfo))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []^TypeInfo, range: RangeInclusive[i64]) -> []^TypeInfo #operator("[]") {
            result : []^TypeInfo = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^TypeInfo))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []^TypeInfo, range: RangeTo[i64]) -> []^TypeInfo #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []^TypeInfo = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []^TypeInfo, range: RangeToInclusive[i64]) -> []^TypeInfo #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []^TypeInfo = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []^TypeInfo, range: RangeFrom[i64]) -> []^TypeInfo #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []^TypeInfo = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^TypeInfo))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []^TypeInfo, range: RangeFull) -> []^TypeInfo #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, char8)
    impl(T: type) []char8 {
        get_index(self: []char8, index: i64) -> &char8 #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []char8, range: Range[i64]) -> []char8 #operator("[]") {
            result : []char8 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(char8))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []char8, range: RangeInclusive[i64]) -> []char8 #operator("[]") {
            result : []char8 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(char8))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []char8, range: RangeTo[i64]) -> []char8 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []char8 = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []char8, range: RangeToInclusive[i64]) -> []char8 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []char8 = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []char8, range: RangeFrom[i64]) -> []char8 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []char8 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(char8))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []char8, range: RangeFull) -> []char8 #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, i64)
    impl(T: type) []i64 {
        get_index(self: []i64, index: i64) -> &i64 #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []i64, range: Range[i64]) -> []i64 #operator("[]") {
            result : []i64 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(i64))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []i64, range: RangeInclusive[i64]) -> []i64 #operator("[]") {
            result : []i64 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(i64))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []i64, range: RangeTo[i64]) -> []i64 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []i64 = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []i64, range: RangeToInclusive[i64]) -> []i64 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []i64 = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []i64, range: RangeFrom[i64]) -> []i64 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []i64 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(i64))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []i64, range: RangeFull) -> []i64 #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, u64)
    impl(T: type) []u64 {
        get_index(self: []u64, index: i64) -> &u64 #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []u64, range: Range[i64]) -> []u64 #operator("[]") {
            result : []u64 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u64))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []u64, range: RangeInclusive[i64]) -> []u64 #operator("[]") {
            result : []u64 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u64))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []u64, range: RangeTo[i64]) -> []u64 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []u64 = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []u64, range: RangeToInclusive[i64]) -> []u64 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []u64 = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []u64, range: RangeFrom[i64]) -> []u64 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []u64 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u64))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []u64, range: RangeFull) -> []u64 #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, ^AstNode)
    impl(T: type) []^AstNode {
        get_index(self: []^AstNode, index: i64) -> &^AstNode #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []^AstNode, range: Range[i64]) -> []^AstNode #operator("[]") {
            result : []^AstNode = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstNode))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []^AstNode, range: RangeInclusive[i64]) -> []^AstNode #operator("[]") {
            result : []^AstNode = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstNode))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []^AstNode, range: RangeTo[i64]) -> []^AstNode #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []^AstNode = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []^AstNode, range: RangeToInclusive[i64]) -> []^AstNode #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []^AstNode = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []^AstNode, range: RangeFrom[i64]) -> []^AstNode #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []^AstNode = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstNode))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []^AstNode, range: RangeFull) -> []^AstNode #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, Entry[i64, ^AstStruct])
    impl(T: type) []Entry[i64, ^AstStruct] {
        get_index(self: []Entry[i64, ^AstStruct], index: i64) -> &Entry[i64, ^AstStruct] #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []Entry[i64, ^AstStruct], range: Range[i64]) -> []Entry[i64, ^AstStruct] #operator("[]") {
            result : []Entry[i64, ^AstStruct] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[i64, ^AstStruct]))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []Entry[i64, ^AstStruct], range: RangeInclusive[i64]) -> []Entry[i64, ^AstStruct] #operator("[]") {
            result : []Entry[i64, ^AstStruct] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[i64, ^AstStruct]))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []Entry[i64, ^AstStruct], range: RangeTo[i64]) -> []Entry[i64, ^AstStruct] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []Entry[i64, ^AstStruct] = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []Entry[i64, ^AstStruct], range: RangeToInclusive[i64]) -> []Entry[i64, ^AstStruct] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []Entry[i64, ^AstStruct] = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []Entry[i64, ^AstStruct], range: RangeFrom[i64]) -> []Entry[i64, ^AstStruct] #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []Entry[i64, ^AstStruct] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[i64, ^AstStruct]))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []Entry[i64, ^AstStruct], range: RangeFull) -> []Entry[i64, ^AstStruct] #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, Entry[string, SourceFile])
    impl(T: type) []Entry[string, SourceFile] {
        get_index(self: []Entry[string, SourceFile], index: i64) -> &Entry[string, SourceFile] #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []Entry[string, SourceFile], range: Range[i64]) -> []Entry[string, SourceFile] #operator("[]") {
            result : []Entry[string, SourceFile] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[string, SourceFile]))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []Entry[string, SourceFile], range: RangeInclusive[i64]) -> []Entry[string, SourceFile] #operator("[]") {
            result : []Entry[string, SourceFile] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[string, SourceFile]))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []Entry[string, SourceFile], range: RangeTo[i64]) -> []Entry[string, SourceFile] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []Entry[string, SourceFile] = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []Entry[string, SourceFile], range: RangeToInclusive[i64]) -> []Entry[string, SourceFile] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []Entry[string, SourceFile] = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []Entry[string, SourceFile], range: RangeFrom[i64]) -> []Entry[string, SourceFile] #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []Entry[string, SourceFile] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[string, SourceFile]))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []Entry[string, SourceFile], range: RangeFull) -> []Entry[string, SourceFile] #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)])
    impl(T: type) []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] {
        get_index(self: []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], index: i64) -> &Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], range: Range[i64]) -> []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] #operator("[]") {
            result : []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], range: RangeInclusive[i64]) -> []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] #operator("[]") {
            result : []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], range: RangeTo[i64]) -> []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], range: RangeToInclusive[i64]) -> []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], range: RangeFrom[i64]) -> []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], range: RangeFull) -> []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, Rc[Workspace])
    impl(T: type) []Rc[Workspace] {
        get_index(self: []Rc[Workspace], index: i64) -> &Rc[Workspace] #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []Rc[Workspace], range: Range[i64]) -> []Rc[Workspace] #operator("[]") {
            result : []Rc[Workspace] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Rc[Workspace]))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []Rc[Workspace], range: RangeInclusive[i64]) -> []Rc[Workspace] #operator("[]") {
            result : []Rc[Workspace] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Rc[Workspace]))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []Rc[Workspace], range: RangeTo[i64]) -> []Rc[Workspace] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []Rc[Workspace] = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []Rc[Workspace], range: RangeToInclusive[i64]) -> []Rc[Workspace] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []Rc[Workspace] = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []Rc[Workspace], range: RangeFrom[i64]) -> []Rc[Workspace] #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []Rc[Workspace] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Rc[Workspace]))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []Rc[Workspace], range: RangeFull) -> []Rc[Workspace] #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, ^FiberContext)
    impl(T: type) []^FiberContext {
        get_index(self: []^FiberContext, index: i64) -> &^FiberContext #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []^FiberContext, range: Range[i64]) -> []^FiberContext #operator("[]") {
            result : []^FiberContext = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^FiberContext))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []^FiberContext, range: RangeInclusive[i64]) -> []^FiberContext #operator("[]") {
            result : []^FiberContext = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^FiberContext))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []^FiberContext, range: RangeTo[i64]) -> []^FiberContext #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []^FiberContext = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []^FiberContext, range: RangeToInclusive[i64]) -> []^FiberContext #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []^FiberContext = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []^FiberContext, range: RangeFrom[i64]) -> []^FiberContext #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []^FiberContext = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^FiberContext))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []^FiberContext, range: RangeFull) -> []^FiberContext #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, Entry[string, String])
    impl(T: type) []Entry[string, String] {
        get_index(self: []Entry[string, String], index: i64) -> &Entry[string, String] #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []Entry[string, String], range: Range[i64]) -> []Entry[string, String] #operator("[]") {
            result : []Entry[string, String] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[string, String]))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []Entry[string, String], range: RangeInclusive[i64]) -> []Entry[string, String] #operator("[]") {
            result : []Entry[string, String] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[string, String]))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []Entry[string, String], range: RangeTo[i64]) -> []Entry[string, String] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []Entry[string, String] = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []Entry[string, String], range: RangeToInclusive[i64]) -> []Entry[string, String] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []Entry[string, String] = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []Entry[string, String], range: RangeFrom[i64]) -> []Entry[string, String] #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []Entry[string, String] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[string, String]))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []Entry[string, String], range: RangeFull) -> []Entry[string, String] #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, (name: string, symbol: Symbol))
    impl(T: type) [](name: string, symbol: Symbol) {
        get_index(self: [](name: string, symbol: Symbol), index: i64) -> &(name: string, symbol: Symbol) #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: [](name: string, symbol: Symbol), range: Range[i64]) -> [](name: string, symbol: Symbol) #operator("[]") {
            result : [](name: string, symbol: Symbol) = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof((name: string, symbol: Symbol)))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: [](name: string, symbol: Symbol), range: RangeInclusive[i64]) -> [](name: string, symbol: Symbol) #operator("[]") {
            result : [](name: string, symbol: Symbol) = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof((name: string, symbol: Symbol)))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: [](name: string, symbol: Symbol), range: RangeTo[i64]) -> [](name: string, symbol: Symbol) #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : [](name: string, symbol: Symbol) = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: [](name: string, symbol: Symbol), range: RangeToInclusive[i64]) -> [](name: string, symbol: Symbol) #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : [](name: string, symbol: Symbol) = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: [](name: string, symbol: Symbol), range: RangeFrom[i64]) -> [](name: string, symbol: Symbol) #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : [](name: string, symbol: Symbol) = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof((name: string, symbol: Symbol)))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: [](name: string, symbol: Symbol), range: RangeFull) -> [](name: string, symbol: Symbol) #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, Entry[string, Symbol])
    impl(T: type) []Entry[string, Symbol] {
        get_index(self: []Entry[string, Symbol], index: i64) -> &Entry[string, Symbol] #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []Entry[string, Symbol], range: Range[i64]) -> []Entry[string, Symbol] #operator("[]") {
            result : []Entry[string, Symbol] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[string, Symbol]))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []Entry[string, Symbol], range: RangeInclusive[i64]) -> []Entry[string, Symbol] #operator("[]") {
            result : []Entry[string, Symbol] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[string, Symbol]))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []Entry[string, Symbol], range: RangeTo[i64]) -> []Entry[string, Symbol] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []Entry[string, Symbol] = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []Entry[string, Symbol], range: RangeToInclusive[i64]) -> []Entry[string, Symbol] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []Entry[string, Symbol] = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []Entry[string, Symbol], range: RangeFrom[i64]) -> []Entry[string, Symbol] #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []Entry[string, Symbol] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[string, Symbol]))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []Entry[string, Symbol], range: RangeFull) -> []Entry[string, Symbol] #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, ^AstDecl)
    impl(T: type) []^AstDecl {
        get_index(self: []^AstDecl, index: i64) -> &^AstDecl #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []^AstDecl, range: Range[i64]) -> []^AstDecl #operator("[]") {
            result : []^AstDecl = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstDecl))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []^AstDecl, range: RangeInclusive[i64]) -> []^AstDecl #operator("[]") {
            result : []^AstDecl = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstDecl))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []^AstDecl, range: RangeTo[i64]) -> []^AstDecl #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []^AstDecl = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []^AstDecl, range: RangeToInclusive[i64]) -> []^AstDecl #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []^AstDecl = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []^AstDecl, range: RangeFrom[i64]) -> []^AstDecl #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []^AstDecl = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstDecl))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []^AstDecl, range: RangeFull) -> []^AstDecl #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, ^AstConstDecl)
    impl(T: type) []^AstConstDecl {
        get_index(self: []^AstConstDecl, index: i64) -> &^AstConstDecl #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []^AstConstDecl, range: Range[i64]) -> []^AstConstDecl #operator("[]") {
            result : []^AstConstDecl = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstConstDecl))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []^AstConstDecl, range: RangeInclusive[i64]) -> []^AstConstDecl #operator("[]") {
            result : []^AstConstDecl = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstConstDecl))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []^AstConstDecl, range: RangeTo[i64]) -> []^AstConstDecl #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []^AstConstDecl = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []^AstConstDecl, range: RangeToInclusive[i64]) -> []^AstConstDecl #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []^AstConstDecl = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []^AstConstDecl, range: RangeFrom[i64]) -> []^AstConstDecl #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []^AstConstDecl = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstConstDecl))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []^AstConstDecl, range: RangeFull) -> []^AstConstDecl #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, Entry[i64, i64])
    impl(T: type) []Entry[i64, i64] {
        get_index(self: []Entry[i64, i64], index: i64) -> &Entry[i64, i64] #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []Entry[i64, i64], range: Range[i64]) -> []Entry[i64, i64] #operator("[]") {
            result : []Entry[i64, i64] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[i64, i64]))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []Entry[i64, i64], range: RangeInclusive[i64]) -> []Entry[i64, i64] #operator("[]") {
            result : []Entry[i64, i64] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[i64, i64]))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []Entry[i64, i64], range: RangeTo[i64]) -> []Entry[i64, i64] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []Entry[i64, i64] = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []Entry[i64, i64], range: RangeToInclusive[i64]) -> []Entry[i64, i64] #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []Entry[i64, i64] = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []Entry[i64, i64], range: RangeFrom[i64]) -> []Entry[i64, i64] #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []Entry[i64, i64] = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Entry[i64, i64]))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []Entry[i64, i64], range: RangeFull) -> []Entry[i64, i64] #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, LineInfo)
    impl(T: type) []LineInfo {
        get_index(self: []LineInfo, index: i64) -> &LineInfo #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []LineInfo, range: Range[i64]) -> []LineInfo #operator("[]") {
            result : []LineInfo = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(LineInfo))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []LineInfo, range: RangeInclusive[i64]) -> []LineInfo #operator("[]") {
            result : []LineInfo = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(LineInfo))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []LineInfo, range: RangeTo[i64]) -> []LineInfo #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []LineInfo = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []LineInfo, range: RangeToInclusive[i64]) -> []LineInfo #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []LineInfo = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []LineInfo, range: RangeFrom[i64]) -> []LineInfo #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []LineInfo = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(LineInfo))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []LineInfo, range: RangeFull) -> []LineInfo #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, VariableInfo)
    impl(T: type) []VariableInfo {
        get_index(self: []VariableInfo, index: i64) -> &VariableInfo #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []VariableInfo, range: Range[i64]) -> []VariableInfo #operator("[]") {
            result : []VariableInfo = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(VariableInfo))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []VariableInfo, range: RangeInclusive[i64]) -> []VariableInfo #operator("[]") {
            result : []VariableInfo = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(VariableInfo))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []VariableInfo, range: RangeTo[i64]) -> []VariableInfo #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []VariableInfo = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []VariableInfo, range: RangeToInclusive[i64]) -> []VariableInfo #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []VariableInfo = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []VariableInfo, range: RangeFrom[i64]) -> []VariableInfo #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []VariableInfo = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(VariableInfo))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []VariableInfo, range: RangeFull) -> []VariableInfo #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, Bucket)
    impl(T: type) []Bucket {
        get_index(self: []Bucket, index: i64) -> &Bucket #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []Bucket, range: Range[i64]) -> []Bucket #operator("[]") {
            result : []Bucket = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Bucket))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []Bucket, range: RangeInclusive[i64]) -> []Bucket #operator("[]") {
            result : []Bucket = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Bucket))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []Bucket, range: RangeTo[i64]) -> []Bucket #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []Bucket = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []Bucket, range: RangeToInclusive[i64]) -> []Bucket #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []Bucket = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []Bucket, range: RangeFrom[i64]) -> []Bucket #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []Bucket = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Bucket))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []Bucket, range: RangeFull) -> []Bucket #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, char32)
    impl(T: type) []char32 {
        get_index(self: []char32, index: i64) -> &char32 #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []char32, range: Range[i64]) -> []char32 #operator("[]") {
            result : []char32 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(char32))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []char32, range: RangeInclusive[i64]) -> []char32 #operator("[]") {
            result : []char32 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(char32))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []char32, range: RangeTo[i64]) -> []char32 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []char32 = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []char32, range: RangeToInclusive[i64]) -> []char32 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []char32 = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []char32, range: RangeFrom[i64]) -> []char32 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []char32 = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(char32))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []char32, range: RangeFull) -> []char32 #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, (name: string, mem: ^TypeInfoStructMember, set: bool))
    impl(T: type) [](name: string, mem: ^TypeInfoStructMember, set: bool) {
        get_index(self: [](name: string, mem: ^TypeInfoStructMember, set: bool), index: i64) -> &(name: string, mem: ^TypeInfoStructMember, set: bool) #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: [](name: string, mem: ^TypeInfoStructMember, set: bool), range: Range[i64]) -> [](name: string, mem: ^TypeInfoStructMember, set: bool) #operator("[]") {
            result : [](name: string, mem: ^TypeInfoStructMember, set: bool) = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof((name: string, mem: ^TypeInfoStructMember, set: bool)))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: [](name: string, mem: ^TypeInfoStructMember, set: bool), range: RangeInclusive[i64]) -> [](name: string, mem: ^TypeInfoStructMember, set: bool) #operator("[]") {
            result : [](name: string, mem: ^TypeInfoStructMember, set: bool) = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof((name: string, mem: ^TypeInfoStructMember, set: bool)))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: [](name: string, mem: ^TypeInfoStructMember, set: bool), range: RangeTo[i64]) -> [](name: string, mem: ^TypeInfoStructMember, set: bool) #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : [](name: string, mem: ^TypeInfoStructMember, set: bool) = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: [](name: string, mem: ^TypeInfoStructMember, set: bool), range: RangeToInclusive[i64]) -> [](name: string, mem: ^TypeInfoStructMember, set: bool) #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : [](name: string, mem: ^TypeInfoStructMember, set: bool) = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: [](name: string, mem: ^TypeInfoStructMember, set: bool), range: RangeFrom[i64]) -> [](name: string, mem: ^TypeInfoStructMember, set: bool) #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : [](name: string, mem: ^TypeInfoStructMember, set: bool) = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof((name: string, mem: ^TypeInfoStructMember, set: bool)))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: [](name: string, mem: ^TypeInfoStructMember, set: bool), range: RangeFull) -> [](name: string, mem: ^TypeInfoStructMember, set: bool) #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, ^AstArgument)
    impl(T: type) []^AstArgument {
        get_index(self: []^AstArgument, index: i64) -> &^AstArgument #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []^AstArgument, range: Range[i64]) -> []^AstArgument #operator("[]") {
            result : []^AstArgument = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstArgument))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []^AstArgument, range: RangeInclusive[i64]) -> []^AstArgument #operator("[]") {
            result : []^AstArgument = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstArgument))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []^AstArgument, range: RangeTo[i64]) -> []^AstArgument #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []^AstArgument = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []^AstArgument, range: RangeToInclusive[i64]) -> []^AstArgument #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []^AstArgument = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []^AstArgument, range: RangeFrom[i64]) -> []^AstArgument #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []^AstArgument = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstArgument))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []^AstArgument, range: RangeFull) -> []^AstArgument #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, ^AstMatchCase)
    impl(T: type) []^AstMatchCase {
        get_index(self: []^AstMatchCase, index: i64) -> &^AstMatchCase #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []^AstMatchCase, range: Range[i64]) -> []^AstMatchCase #operator("[]") {
            result : []^AstMatchCase = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstMatchCase))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []^AstMatchCase, range: RangeInclusive[i64]) -> []^AstMatchCase #operator("[]") {
            result : []^AstMatchCase = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstMatchCase))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []^AstMatchCase, range: RangeTo[i64]) -> []^AstMatchCase #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []^AstMatchCase = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []^AstMatchCase, range: RangeToInclusive[i64]) -> []^AstMatchCase #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []^AstMatchCase = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []^AstMatchCase, range: RangeFrom[i64]) -> []^AstMatchCase #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []^AstMatchCase = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstMatchCase))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []^AstMatchCase, range: RangeFull) -> []^AstMatchCase #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, Thread)
    impl(T: type) []Thread {
        get_index(self: []Thread, index: i64) -> &Thread #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []Thread, range: Range[i64]) -> []Thread #operator("[]") {
            result : []Thread = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Thread))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []Thread, range: RangeInclusive[i64]) -> []Thread #operator("[]") {
            result : []Thread = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Thread))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []Thread, range: RangeTo[i64]) -> []Thread #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []Thread = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []Thread, range: RangeToInclusive[i64]) -> []Thread #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []Thread = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []Thread, range: RangeFrom[i64]) -> []Thread #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []Thread = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Thread))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []Thread, range: RangeFull) -> []Thread #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, ^AstImpl)
    impl(T: type) []^AstImpl {
        get_index(self: []^AstImpl, index: i64) -> &^AstImpl #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []^AstImpl, range: Range[i64]) -> []^AstImpl #operator("[]") {
            result : []^AstImpl = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstImpl))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []^AstImpl, range: RangeInclusive[i64]) -> []^AstImpl #operator("[]") {
            result : []^AstImpl = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstImpl))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []^AstImpl, range: RangeTo[i64]) -> []^AstImpl #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []^AstImpl = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []^AstImpl, range: RangeToInclusive[i64]) -> []^AstImpl #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []^AstImpl = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []^AstImpl, range: RangeFrom[i64]) -> []^AstImpl #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []^AstImpl = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^AstImpl))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []^AstImpl, range: RangeFull) -> []^AstImpl #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, ^CompileStructMemberJob)
    impl(T: type) []^CompileStructMemberJob {
        get_index(self: []^CompileStructMemberJob, index: i64) -> &^CompileStructMemberJob #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []^CompileStructMemberJob, range: Range[i64]) -> []^CompileStructMemberJob #operator("[]") {
            result : []^CompileStructMemberJob = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^CompileStructMemberJob))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []^CompileStructMemberJob, range: RangeInclusive[i64]) -> []^CompileStructMemberJob #operator("[]") {
            result : []^CompileStructMemberJob = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^CompileStructMemberJob))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []^CompileStructMemberJob, range: RangeTo[i64]) -> []^CompileStructMemberJob #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []^CompileStructMemberJob = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []^CompileStructMemberJob, range: RangeToInclusive[i64]) -> []^CompileStructMemberJob #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []^CompileStructMemberJob = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []^CompileStructMemberJob, range: RangeFrom[i64]) -> []^CompileStructMemberJob #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []^CompileStructMemberJob = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^CompileStructMemberJob))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []^CompileStructMemberJob, range: RangeFull) -> []^CompileStructMemberJob #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, Utf8Format)
    impl(T: type) []Utf8Format {
        get_index(self: []Utf8Format, index: i64) -> &Utf8Format #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []Utf8Format, range: Range[i64]) -> []Utf8Format #operator("[]") {
            result : []Utf8Format = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Utf8Format))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []Utf8Format, range: RangeInclusive[i64]) -> []Utf8Format #operator("[]") {
            result : []Utf8Format = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Utf8Format))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []Utf8Format, range: RangeTo[i64]) -> []Utf8Format #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []Utf8Format = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []Utf8Format, range: RangeToInclusive[i64]) -> []Utf8Format #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []Utf8Format = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []Utf8Format, range: RangeFrom[i64]) -> []Utf8Format #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []Utf8Format = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Utf8Format))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []Utf8Format, range: RangeFull) -> []Utf8Format #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, BumpBucket)
    impl(T: type) []BumpBucket {
        get_index(self: []BumpBucket, index: i64) -> &BumpBucket #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []BumpBucket, range: Range[i64]) -> []BumpBucket #operator("[]") {
            result : []BumpBucket = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(BumpBucket))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []BumpBucket, range: RangeInclusive[i64]) -> []BumpBucket #operator("[]") {
            result : []BumpBucket = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(BumpBucket))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []BumpBucket, range: RangeTo[i64]) -> []BumpBucket #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []BumpBucket = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []BumpBucket, range: RangeToInclusive[i64]) -> []BumpBucket #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []BumpBucket = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []BumpBucket, range: RangeFrom[i64]) -> []BumpBucket #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []BumpBucket = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(BumpBucket))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []BumpBucket, range: RangeFull) -> []BumpBucket #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, StackFrame)
    impl(T: type) []StackFrame {
        get_index(self: []StackFrame, index: i64) -> &StackFrame #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []StackFrame, range: Range[i64]) -> []StackFrame #operator("[]") {
            result : []StackFrame = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(StackFrame))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []StackFrame, range: RangeInclusive[i64]) -> []StackFrame #operator("[]") {
            result : []StackFrame = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(StackFrame))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []StackFrame, range: RangeTo[i64]) -> []StackFrame #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []StackFrame = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []StackFrame, range: RangeToInclusive[i64]) -> []StackFrame #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []StackFrame = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []StackFrame, range: RangeFrom[i64]) -> []StackFrame #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []StackFrame = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(StackFrame))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []StackFrame, range: RangeFull) -> []StackFrame #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }
    // T = (type, TypeInfoTraitImpl)
    impl(T: type) []TypeInfoTraitImpl {
        get_index(self: []TypeInfoTraitImpl, index: i64) -> &TypeInfoTraitImpl #operator("[]") {
            return &*pointer_add_sized((self).data, index)
        }
        
        get_range(self: []TypeInfoTraitImpl, range: Range[i64]) -> []TypeInfoTraitImpl #operator("[]") {
            result : []TypeInfoTraitImpl = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoTraitImpl))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: []TypeInfoTraitImpl, range: RangeInclusive[i64]) -> []TypeInfoTraitImpl #operator("[]") {
            result : []TypeInfoTraitImpl = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoTraitImpl))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: []TypeInfoTraitImpl, range: RangeTo[i64]) -> []TypeInfoTraitImpl #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (self).length)))
            result : []TypeInfoTraitImpl = self
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: []TypeInfoTraitImpl, range: RangeToInclusive[i64]) -> []TypeInfoTraitImpl #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (self).length)))
            result : []TypeInfoTraitImpl = self
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: []TypeInfoTraitImpl, range: RangeFrom[i64]) -> []TypeInfoTraitImpl #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (self).length)))
            result : []TypeInfoTraitImpl = self
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(TypeInfoTraitImpl))))
            (result).length = ((self).length - (range).start)
            return result
        }
        
        get_range_full(self: []TypeInfoTraitImpl, range: RangeFull) -> []TypeInfoTraitImpl #operator("[]") {
            return self
        }
        
        reinterpret_cast(self: Self, $N: type) -> []N {
            result :  = []
            (result).data = cast ((self).data)
            (result).length = (((self).length * @sizeof(T)) / @sizeof(N))
            return result
        }
    }


impl(T: type, Size: i64) [Cheez.PolyValue]$T {
    
}
// Polymorphic instances for impl(T: type, Size: i64) [Cheez.PolyValue]$T
    // T = (type, char32), Size = (u0, 260)
    impl(T: type, Size: type) [260]char32 {
        get_index(self: &[260]char32, index: i64) -> &char32 #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[260]char32, range: Range[i64]) -> []char32 #operator("[]") {
            result : []char32 = cast([]char32) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(char32))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[260]char32, range: RangeInclusive[i64]) -> []char32 #operator("[]") {
            result : []char32 = cast([]char32) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(char32))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[260]char32, range: RangeTo[i64]) -> []char32 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []char32 = cast([]char32) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[260]char32, range: RangeToInclusive[i64]) -> []char32 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []char32 = cast([]char32) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[260]char32, range: RangeFrom[i64]) -> []char32 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []char32 = cast([]char32) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(char32))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[260]char32, range: RangeFull) -> []char32 #operator("[]") {
            return cast([]char32) (*self)
        }
    }
    // T = (type, u16), Size = (u0, 512)
    impl(T: type, Size: type) [512]u16 {
        get_index(self: &[512]u16, index: i64) -> &u16 #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[512]u16, range: Range[i64]) -> []u16 #operator("[]") {
            result : []u16 = cast([]u16) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u16))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[512]u16, range: RangeInclusive[i64]) -> []u16 #operator("[]") {
            result : []u16 = cast([]u16) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u16))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[512]u16, range: RangeTo[i64]) -> []u16 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []u16 = cast([]u16) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[512]u16, range: RangeToInclusive[i64]) -> []u16 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []u16 = cast([]u16) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[512]u16, range: RangeFrom[i64]) -> []u16 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []u16 = cast([]u16) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u16))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[512]u16, range: RangeFull) -> []u16 #operator("[]") {
            return cast([]u16) (*self)
        }
    }
    // T = (type, u8), Size = (u0, 4)
    impl(T: type, Size: type) [4]u8 {
        get_index(self: &[4]u8, index: i64) -> &u8 #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[4]u8, range: Range[i64]) -> []u8 #operator("[]") {
            result : []u8 = cast([]u8) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u8))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[4]u8, range: RangeInclusive[i64]) -> []u8 #operator("[]") {
            result : []u8 = cast([]u8) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u8))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[4]u8, range: RangeTo[i64]) -> []u8 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []u8 = cast([]u8) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[4]u8, range: RangeToInclusive[i64]) -> []u8 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []u8 = cast([]u8) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[4]u8, range: RangeFrom[i64]) -> []u8 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []u8 = cast([]u8) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u8))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[4]u8, range: RangeFull) -> []u8 #operator("[]") {
            return cast([]u8) (*self)
        }
    }
    // T = (type, u16), Size = (u0, 260)
    impl(T: type, Size: type) [260]u16 {
        get_index(self: &[260]u16, index: i64) -> &u16 #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[260]u16, range: Range[i64]) -> []u16 #operator("[]") {
            result : []u16 = cast([]u16) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u16))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[260]u16, range: RangeInclusive[i64]) -> []u16 #operator("[]") {
            result : []u16 = cast([]u16) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u16))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[260]u16, range: RangeTo[i64]) -> []u16 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []u16 = cast([]u16) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[260]u16, range: RangeToInclusive[i64]) -> []u16 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []u16 = cast([]u16) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[260]u16, range: RangeFrom[i64]) -> []u16 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []u16 = cast([]u16) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u16))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[260]u16, range: RangeFull) -> []u16 #operator("[]") {
            return cast([]u16) (*self)
        }
    }
    // T = (type, Utf8Format), Size = (u0, 5)
    impl(T: type, Size: type) [5]Utf8Format {
        get_index(self: &[5]Utf8Format, index: i64) -> &Utf8Format #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[5]Utf8Format, range: Range[i64]) -> []Utf8Format #operator("[]") {
            result : []Utf8Format = cast([]Utf8Format) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Utf8Format))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[5]Utf8Format, range: RangeInclusive[i64]) -> []Utf8Format #operator("[]") {
            result : []Utf8Format = cast([]Utf8Format) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Utf8Format))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[5]Utf8Format, range: RangeTo[i64]) -> []Utf8Format #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []Utf8Format = cast([]Utf8Format) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[5]Utf8Format, range: RangeToInclusive[i64]) -> []Utf8Format #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []Utf8Format = cast([]Utf8Format) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[5]Utf8Format, range: RangeFrom[i64]) -> []Utf8Format #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []Utf8Format = cast([]Utf8Format) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(Utf8Format))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[5]Utf8Format, range: RangeFull) -> []Utf8Format #operator("[]") {
            return cast([]Utf8Format) (*self)
        }
    }
    // T = (type, StackFrame), Size = (u0, 8192)
    impl(T: type, Size: type) [8192]StackFrame {
        get_index(self: &[8192]StackFrame, index: i64) -> &StackFrame #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[8192]StackFrame, range: Range[i64]) -> []StackFrame #operator("[]") {
            result : []StackFrame = cast([]StackFrame) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(StackFrame))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[8192]StackFrame, range: RangeInclusive[i64]) -> []StackFrame #operator("[]") {
            result : []StackFrame = cast([]StackFrame) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(StackFrame))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[8192]StackFrame, range: RangeTo[i64]) -> []StackFrame #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []StackFrame = cast([]StackFrame) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[8192]StackFrame, range: RangeToInclusive[i64]) -> []StackFrame #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []StackFrame = cast([]StackFrame) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[8192]StackFrame, range: RangeFrom[i64]) -> []StackFrame #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []StackFrame = cast([]StackFrame) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(StackFrame))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[8192]StackFrame, range: RangeFull) -> []StackFrame #operator("[]") {
            return cast([]StackFrame) (*self)
        }
    }
    // T = (type, i64), Size = (u0, 1048576)
    impl(T: type, Size: type) [1048576]i64 {
        get_index(self: &[1048576]i64, index: i64) -> &i64 #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[1048576]i64, range: Range[i64]) -> []i64 #operator("[]") {
            result : []i64 = cast([]i64) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(i64))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[1048576]i64, range: RangeInclusive[i64]) -> []i64 #operator("[]") {
            result : []i64 = cast([]i64) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(i64))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[1048576]i64, range: RangeTo[i64]) -> []i64 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []i64 = cast([]i64) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[1048576]i64, range: RangeToInclusive[i64]) -> []i64 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []i64 = cast([]i64) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[1048576]i64, range: RangeFrom[i64]) -> []i64 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []i64 = cast([]i64) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(i64))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[1048576]i64, range: RangeFull) -> []i64 #operator("[]") {
            return cast([]i64) (*self)
        }
    }
    // T = (type, ^Printable), Size = (u0, 4)
    impl(T: type, Size: type) [4]^Printable {
        get_index(self: &[4]^Printable, index: i64) -> &^Printable #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[4]^Printable, range: Range[i64]) -> []^Printable #operator("[]") {
            result : []^Printable = cast([]^Printable) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^Printable))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[4]^Printable, range: RangeInclusive[i64]) -> []^Printable #operator("[]") {
            result : []^Printable = cast([]^Printable) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^Printable))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[4]^Printable, range: RangeTo[i64]) -> []^Printable #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []^Printable = cast([]^Printable) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[4]^Printable, range: RangeToInclusive[i64]) -> []^Printable #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []^Printable = cast([]^Printable) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[4]^Printable, range: RangeFrom[i64]) -> []^Printable #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []^Printable = cast([]^Printable) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^Printable))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[4]^Printable, range: RangeFull) -> []^Printable #operator("[]") {
            return cast([]^Printable) (*self)
        }
    }
    // T = (type, ^Printable), Size = (u0, 2)
    impl(T: type, Size: type) [2]^Printable {
        get_index(self: &[2]^Printable, index: i64) -> &^Printable #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[2]^Printable, range: Range[i64]) -> []^Printable #operator("[]") {
            result : []^Printable = cast([]^Printable) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^Printable))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[2]^Printable, range: RangeInclusive[i64]) -> []^Printable #operator("[]") {
            result : []^Printable = cast([]^Printable) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^Printable))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[2]^Printable, range: RangeTo[i64]) -> []^Printable #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []^Printable = cast([]^Printable) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[2]^Printable, range: RangeToInclusive[i64]) -> []^Printable #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []^Printable = cast([]^Printable) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[2]^Printable, range: RangeFrom[i64]) -> []^Printable #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []^Printable = cast([]^Printable) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^Printable))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[2]^Printable, range: RangeFull) -> []^Printable #operator("[]") {
            return cast([]^Printable) (*self)
        }
    }
    // T = (type, ^Printable), Size = (u0, 3)
    impl(T: type, Size: type) [3]^Printable {
        get_index(self: &[3]^Printable, index: i64) -> &^Printable #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[3]^Printable, range: Range[i64]) -> []^Printable #operator("[]") {
            result : []^Printable = cast([]^Printable) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^Printable))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[3]^Printable, range: RangeInclusive[i64]) -> []^Printable #operator("[]") {
            result : []^Printable = cast([]^Printable) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^Printable))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[3]^Printable, range: RangeTo[i64]) -> []^Printable #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []^Printable = cast([]^Printable) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[3]^Printable, range: RangeToInclusive[i64]) -> []^Printable #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []^Printable = cast([]^Printable) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[3]^Printable, range: RangeFrom[i64]) -> []^Printable #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []^Printable = cast([]^Printable) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(^Printable))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[3]^Printable, range: RangeFull) -> []^Printable #operator("[]") {
            return cast([]^Printable) (*self)
        }
    }
    // T = (type, u64), Size = (u0, 1)
    impl(T: type, Size: type) [1]u64 {
        get_index(self: &[1]u64, index: i64) -> &u64 #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[1]u64, range: Range[i64]) -> []u64 #operator("[]") {
            result : []u64 = cast([]u64) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u64))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[1]u64, range: RangeInclusive[i64]) -> []u64 #operator("[]") {
            result : []u64 = cast([]u64) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u64))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[1]u64, range: RangeTo[i64]) -> []u64 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []u64 = cast([]u64) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[1]u64, range: RangeToInclusive[i64]) -> []u64 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []u64 = cast([]u64) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[1]u64, range: RangeFrom[i64]) -> []u64 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []u64 = cast([]u64) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u64))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[1]u64, range: RangeFull) -> []u64 #operator("[]") {
            return cast([]u64) (*self)
        }
    }
    // T = (type, u64), Size = (u0, 3)
    impl(T: type, Size: type) [3]u64 {
        get_index(self: &[3]u64, index: i64) -> &u64 #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[3]u64, range: Range[i64]) -> []u64 #operator("[]") {
            result : []u64 = cast([]u64) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u64))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[3]u64, range: RangeInclusive[i64]) -> []u64 #operator("[]") {
            result : []u64 = cast([]u64) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u64))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[3]u64, range: RangeTo[i64]) -> []u64 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []u64 = cast([]u64) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[3]u64, range: RangeToInclusive[i64]) -> []u64 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []u64 = cast([]u64) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[3]u64, range: RangeFrom[i64]) -> []u64 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []u64 = cast([]u64) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u64))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[3]u64, range: RangeFull) -> []u64 #operator("[]") {
            return cast([]u64) (*self)
        }
    }
    // T = (type, u8), Size = (u0, 1024)
    impl(T: type, Size: type) [1024]u8 {
        get_index(self: &[1024]u8, index: i64) -> &u8 #operator("[]") {
            return &*pointer_add_sized((*self).data, index)
        }
        
        get_range(self: &[1024]u8, range: Range[i64]) -> []u8 #operator("[]") {
            result : []u8 = cast([]u8) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u8))))
            (result).length = ((range).end - (range).start)
            return result
        }
        
        get_range_inclusive(self: &[1024]u8, range: RangeInclusive[i64]) -> []u8 #operator("[]") {
            result : []u8 = cast([]u8) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u8))))
            (result).length = (((range).end - (range).start) + 1)
            return result
        }
        
        get_range_to(self: &[1024]u8, range: RangeTo[i64]) -> []u8 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end <= (*self).length)))
            result : []u8 = cast([]u8) (*self)
            (result).length = (range).end
            return result
        }
        
        get_range_to_incl(self: &[1024]u8, range: RangeToInclusive[i64]) -> []u8 #operator("[]") {
            @assert((((range).end >= 0) and ((range).end < (*self).length)))
            result : []u8 = cast([]u8) (*self)
            (result).length = ((range).end + 1)
            return result
        }
        
        get_range_from(self: &[1024]u8, range: RangeFrom[i64]) -> []u8 #operator("[]") {
            @assert((((range).start >= 0) and ((range).start <= (*self).length)))
            result : []u8 = cast([]u8) (*self)
            (result).data = cast ((cast(i64) ((result).data) + ((range).start * @sizeof(u8))))
            (result).length = ((*self).length - (range).start)
            return result
        }
        
        get_range_full(self: &[1024]u8, range: RangeFull) -> []u8 #operator("[]") {
            return cast([]u8) (*self)
        }
    }


for_extension_range : (r: Range[$T], code: Code) : for_extension_range(r: Range[$T], code: Code) {
    rev :  = ((r).end < (r).start)
    inc :  = if rev then T(-1) else T(1)
    compare :  : @code(if rev then (it > (r).end) else (it < (r).end))
    {
        (it, it_index) :  = ((r).start, 0)
        loop {
            if !@insert(compare, link = [it], _break = {}, _continue = {}) then break
            defer #anonymous {
                it_index = 1
                it = inc
            }
            @insert(code, _break = break, _continue = continue)
        }
    }
}
// Polymorphic instances for for_extension_range(r: Range[$T], code: Code)
    /* T = (type, i64) */
    /*  */
    for_extension_range(r: Range[i64], code: Code) #for {
        rev :  = ((r).end < (r).start)
        inc :  = if rev then T(-1) else T(1)
        compare :  : @code(if rev then (it > (r).end) else (it < (r).end))
        {
            (it, it_index) :  = ((r).start, 0)
            loop {
                if !@insert(compare, link = [it], _break = {}, _continue = {}) then break
                defer #anonymous {
                    it_index = 1
                    it = inc
                }
                @insert(code, _break = break, _continue = continue)
            }
        }
    }


for_extension_range_inclusive : (r: RangeInclusive[$T], code: Code, reverse: bool = false) : for_extension_range_inclusive(r: RangeInclusive[$T], code: Code, reverse: bool) {
    (start, end, inc) :  = {
        end :  = (r).end
        if reverse then (end, (r).start, T(-1)) else ((r).start, end, T(1))
    }
    compare :  : @code(if reverse then (it >= end) else (it <= end))
    {
        (it, it_index) :  = (start, 0)
        loop {
            if !@insert(compare, link = [it], _break = {}, _continue = {}) then break
            defer #anonymous {
                it_index = 1
                it = inc
            }
            @insert(code, _break = break, _continue = continue)
        }
    }
}
// Polymorphic instances for for_extension_range_inclusive(r: RangeInclusive[$T], code: Code, reverse: bool)
    /* T = (type, i64) */
    /*  */
    for_extension_range_inclusive(r: RangeInclusive[i64], code: Code, reverse: bool = false) #for {
        (start, end, inc) :  = {
            end :  = (r).end
            if reverse then (end, (r).start, T(-1)) else ((r).start, end, T(1))
        }
        compare :  : @code(if reverse then (it >= end) else (it <= end))
        {
            (it, it_index) :  = (start, 0)
            loop {
                if !@insert(compare, link = [it], _break = {}, _continue = {}) then break
                defer #anonymous {
                    it_index = 1
                    it = inc
                }
                @insert(code, _break = break, _continue = continue)
            }
        }
    }


for_extension_range_from : (r: RangeFrom[$T], code: Code) : for_extension_range_from(r: RangeFrom[$T], code: Code) {
    {
        (it, it_index) :  = ((r).start, 0)
        loop {
            if !true then break
            defer #anonymous {
                it_index = 1
                it = 1
            }
            @insert(code, _break = break, _continue = continue)
        }
    }
}

for_extension_slice : (arr: []$T, code: Code, reverse: bool = false, by_ref: bool = false) : for_extension_slice(arr: []$T, code: Code, reverse: bool, by_ref: bool) {
    {
        it_index :  = 0
        loop {
            if !(it_index < (arr).length) then break
            defer it_index = 1
            if reverse {
                it_index_rev :  = (((arr).length - it_index) - 1)
                it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                @insert(code, link = [it_index_rev], _break = break, _continue = continue)
            } else {
                it :  = if by_ref then arr[it_index] else *arr[it_index]
                @insert(code, _break = break, _continue = continue)
            }
        }
    }
}
// Polymorphic instances for for_extension_slice(arr: []$T, code: Code, reverse: bool, by_ref: bool)
    /* T = (type, string) */
    /*  */
    for_extension_slice(arr: []string, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, TypeInfoEnumMember) */
    /*  */
    for_extension_slice(arr: []TypeInfoEnumMember, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, TypeInfoStructMember) */
    /*  */
    for_extension_slice(arr: []TypeInfoStructMember, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, String) */
    /*  */
    for_extension_slice(arr: []String, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, TypeInfoTupleMember) */
    /*  */
    for_extension_slice(arr: []TypeInfoTupleMember, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, TypeInfoAttribute) */
    /*  */
    for_extension_slice(arr: []TypeInfoAttribute, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, TypeInfoTraitFunction) */
    /*  */
    for_extension_slice(arr: []TypeInfoTraitFunction, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, u8) */
    /*  */
    for_extension_slice(arr: []u8, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, (fmt: string, args: []^any)) */
    /*  */
    for_extension_slice(arr: [](fmt: string, args: []^any), code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, TypeInfoImplFunction) */
    /*  */
    for_extension_slice(arr: []TypeInfoImplFunction, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, Entry[TypeId, Array[^AstImpl]]) */
    /*  */
    for_extension_slice(arr: []Entry[TypeId, Array[^AstImpl]], code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, ^TypeInfo) */
    /*  */
    for_extension_slice(arr: []^TypeInfo, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, ^AstNode) */
    /*  */
    for_extension_slice(arr: []^AstNode, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, Entry[i64, ^AstStruct]) */
    /*  */
    for_extension_slice(arr: []Entry[i64, ^AstStruct], code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, Entry[string, SourceFile]) */
    /*  */
    for_extension_slice(arr: []Entry[string, SourceFile], code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]) */
    /*  */
    for_extension_slice(arr: []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, Rc[Workspace]) */
    /*  */
    for_extension_slice(arr: []Rc[Workspace], code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, Entry[string, String]) */
    /*  */
    for_extension_slice(arr: []Entry[string, String], code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, Entry[string, Symbol]) */
    /*  */
    for_extension_slice(arr: []Entry[string, Symbol], code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, Entry[i64, i64]) */
    /*  */
    for_extension_slice(arr: []Entry[i64, i64], code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, u64) */
    /*  */
    for_extension_slice(arr: []u64, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, i64) */
    /*  */
    for_extension_slice(arr: []i64, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, Entry[string, string]) */
    /*  */
    for_extension_slice(arr: []Entry[string, string], code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, u16) */
    /*  */
    for_extension_slice(arr: []u16, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, TypeInfoTraitImpl) */
    /*  */
    for_extension_slice(arr: []TypeInfoTraitImpl, code: Code, reverse: bool = false, by_ref: bool = false) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).length) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    it :  = if by_ref then arr[it_index_rev] else *arr[it_index_rev]
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    it :  = if by_ref then arr[it_index] else *arr[it_index]
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }


for_extension_array : (arr: [$Size]$T, code: Code, reverse: bool = false, by_ref: bool = false) : for_extension_array(arr: [$Size]$T, code: Code, reverse: bool, by_ref: bool) {
    {
        it_index :  = 0
        loop {
            if !(it_index < (arr).length) then break
            defer it_index = 1
            if reverse {
                it_index_rev :  = (((arr).length - it_index) - 1)
                it :  = if by_ref then &arr[it_index_rev] else arr[it_index_rev]
                @insert(code, link = [it_index_rev], _break = break, _continue = continue)
            } else {
                it :  = if by_ref then &arr[it_index] else arr[it_index]
                @insert(code, _break = break, _continue = continue)
            }
        }
    }
}

__VTable :: struct { // size: 16, alignment: 8
    type_info : ^TypeInfo
}

__Trait :: struct { // size: 16, alignment: 8
    value : ^void
    vtable : ^__VTable
}

Traits :: struct { // size: 0, alignment: 1
    
}

__any :: struct { // size: 24, alignment: 8
    value : ^void
    type_info : ^TypeInfo
}

Any :: struct { // size: 0, alignment: 1
    
}

__FatFunction :: struct { // size: 16, alignment: 8
    func : ^void
    data : ^void
}

FatFunctions :: struct { // size: 0, alignment: 1
    
}

impl FatFunctions {
    from_pointers($T: type, func: ^void, data: ^void) -> T {
        t :  = __FatFunction(func, data)
        return *cast() (^t)
    }
    
    destructure(func: $T, $FuncType: type, $DataType: type) -> (FuncType, DataType) {
        fat :  = cast() (^func)
        return (cast ((fat).func), cast ((fat).data))
    }
}

__ti_type_info : ^TypeInfo = @type_info(TypeInfo)

TypeInfo :: trait {
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
}

TypeId :: struct { // size: 16, alignment: 8
    ptr : ^TypeInfo
}

__ti_TypeId : ^TypeInfo = @type_info(TypeId)

TypeInfoVoid :: struct type { // size: 48, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
}

__ti_TypeInfoVoid : ^TypeInfo = @type_info(TypeInfoVoid)

TypeInfoType :: struct type { // size: 48, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
}

__ti_TypeInfoType : ^TypeInfo = @type_info(TypeInfoType)

TypeInfoCode :: struct type { // size: 48, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
}

__ti_TypeInfoCode : ^TypeInfo = @type_info(TypeInfoCode)

TypeInfoFloat :: struct type { // size: 48, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
}

__ti_TypeInfoFloat : ^TypeInfo = @type_info(TypeInfoFloat)

TypeInfoBool :: struct type { // size: 48, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
}

__ti_TypeInfoBool : ^TypeInfo = @type_info(TypeInfoBool)

TypeInfoChar :: struct type { // size: 48, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
}

__ti_TypeInfoChar : ^TypeInfo = @type_info(TypeInfoChar)

TypeInfoString :: struct type { // size: 48, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
}

__ti_TypeInfoString : ^TypeInfo = @type_info(TypeInfoString)

TypeInfoAny :: struct type { // size: 48, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
}

__ti_TypeInfoAny : ^TypeInfo = @type_info(TypeInfoAny)

TypeInfoFunction :: struct type { // size: 80, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
    return_type : ^TypeInfo
    param_types : []^TypeInfo
}

impl TypeInfo for TypeInfoFunction {
    
}

__ti_TypeInfoFunction : ^TypeInfo = @type_info(TypeInfoFunction)

TypeInfoTuple :: struct type { // size: 64, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
    members : []TypeInfoTupleMember
}

__ti_TypeInfoTuple : ^TypeInfo = @type_info(TypeInfoTuple)

TypeInfoInt :: struct type { // size: 56, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
    signed : bool
}

__ti_TypeInfoInt : ^TypeInfo = @type_info(TypeInfoInt)

TypeInfoPointer :: struct type { // size: 72, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
    target : ^TypeInfo
    is_mut : bool
    is_fat : bool
}

__ti_TypeInfoPointer : ^TypeInfo = @type_info(TypeInfoPointer)

TypeInfoReference :: struct type { // size: 72, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
    target : ^TypeInfo
    is_mut : bool
    is_fat : bool
}

__ti_TypeInfoReference : ^TypeInfo = @type_info(TypeInfoReference)

TypeInfoSlice :: struct type { // size: 64, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
    target : ^TypeInfo
}

__ti_TypeInfoSlice : ^TypeInfo = @type_info(TypeInfoSlice)

TypeInfoArray :: struct type { // size: 72, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
    count : i64
    target : ^TypeInfo
}

__ti_TypeInfoArray : ^TypeInfo = @type_info(TypeInfoArray)

TypeInfoTrait :: struct type { // size: 80, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
    name : string
    functions : []TypeInfoTraitFunction
}

__ti_TypeInfoTrait : ^TypeInfo = @type_info(TypeInfoTrait)

TypeInfoStruct :: struct type { // size: 80, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
    name : string
    members : []TypeInfoStructMember
}

__ti_TypeInfoStruct : ^TypeInfo = @type_info(TypeInfoStruct)

TypeInfoEnum :: struct type { // size: 96, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
    name : string
    members : []TypeInfoEnumMember
    tag_type : ^TypeInfo
}

__ti_TypeInfoEnum : ^TypeInfo = @type_info(TypeInfoEnum)

TypeInfoImplFunction :: struct { // size: 40, alignment: 8
    typ : ^TypeInfo
    name : string
    pointer : fn()
}

TypeInfoTraitFunction :: struct { // size: 24, alignment: 8
    name : string
    offset : i64
}

TypeInfoStructMember :: struct { // size: 96, alignment: 8
    index : i64
    offset : i64
    name : string
    typ : ^TypeInfo
    value : ^any
    initializer : fn(^void)
    attributes : []TypeInfoAttribute
}

TypeInfoTupleMember :: struct { // size: 32, alignment: 8
    index : i64
    offset : i64
    typ : ^TypeInfo
}

TypeInfoEnumMember :: struct { // size: 56, alignment: 8
    name : string
    typ : ^TypeInfo
    tag : i64
    attributes : []TypeInfoAttribute
}

TypeInfoTraitImpl :: struct { // size: 24, alignment: 8
    trait_type : ^TypeInfo
    vtable : ^void
}

TypeInfoAttribute :: struct { // size: 32, alignment: 8
    name : string
    args : []^any
}

impl TypeId {
    type_info(self: TypeId) -> ^TypeInfo {
        return (self).ptr
    }
}

impl TypeInfo {
    id(self: &TypeInfo) -> TypeId {
        return new TypeId { ptr = ^*self }
    }
    
    get_trait_impl(&TypeInfo, $T: type) -> ^TypeInfoTraitImpl {
        ti :  = @type_info(T)
        for(by_ref = true) : (self).traits {
            if ((it).trait_type == ti) {
                return ^*it
            }
        }
        return null
    }
    // Polymorphic instances for get_trait_impl(&TypeInfo, $T: type) -> ^TypeInfoTraitImpl
        /*  */
        /* T = Printable */
        get_trait_impl(self: &TypeInfo) -> ^TypeInfoTraitImpl {
            ti : ^TypeInfo = @type_info(Printable)
            #macro {
                local arr : []TypeInfoTraitImpl = (*self).traits
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &TypeInfoTraitImpl = get_index(arr, it_index)
                            #link #anonymous {
                                it : &TypeInfoTraitImpl = it
                                it_index : i64 = it_index
                                {
                                    if (cast(^void) ((*it).trait_type) == cast(^void) (ti)) {
                                        it_index = (it_index + 1);
                                        return ^*it
                                    } else {}
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            return null
        }
    
    
    get_trait_function(&TypeInfo, $Trait: type, func_name: string, $F: type) -> F {
        ti_impl :  = (self).get_trait_impl(Trait)
        if (ti_impl == null) {
            return null
        }
        ti_trait :  = cast() ((ti_impl).trait_type)
        vtable :  = (ti_impl).vtable
        func_info :  = (ti_trait).get_function(func_name)
        @assert((func_info != null))
        function :  = cast() (*cast() ((int(vtable) + (func_info).offset)))
        return function
    }
    // Polymorphic instances for get_trait_function(&TypeInfo, $Trait: type, func_name: string, $F: type) -> F
        /*  */
        /* Trait = Printable, F = fn(^void, &String, string) */
        get_trait_function(self: &TypeInfo, func_name: string) -> fn(^void, &String, string) {
            ti_impl : ^TypeInfoTraitImpl = self.get_trait_impl()
            if (cast(^void) (ti_impl) == null) {
                return cast(fn(^void, &String, string)) (null)
            } else {}
            ti_trait : ^TypeInfoTrait = cast(^TypeInfoTrait) ((*ti_impl).trait_type)
            vtable : ^void = (*ti_impl).vtable
            func_info : ^TypeInfoTraitFunction = &*ti_trait.get_function(func_name)
            @assert((cast(^void) (func_info) != null))
            function : fn(^void, &String, string) = cast(fn(^void, &String, string)) (*cast(^fn()) ((cast(i64) (vtable) + (*func_info).offset)))
            return function
        }
    
}

impl TypeInfoStruct {
    has_member(self: &TypeInfoStruct, name: string) -> bool {
        #macro {
            local arr : []TypeInfoStructMember = members
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : &TypeInfoStructMember = get_index(arr, it_index)
                        #link #anonymous {
                            it : &TypeInfoStructMember = it
                            it_index : i64 = it_index
                            {
                                if strings_equal(name, (*it).name) {
                                    it_index = (it_index + 1);
                                    return true
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return false
    }
    
    get_member(self: &TypeInfoStruct, name: string) -> ^TypeInfoStructMember {
        #macro {
            local arr : []TypeInfoStructMember = members
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : &TypeInfoStructMember = get_index(arr, it_index)
                        #link #anonymous {
                            it : &TypeInfoStructMember = it
                            it_index : i64 = it_index
                            {
                                if strings_equal(name, (*it).name) {
                                    it_index = (it_index + 1);
                                    return ^*it
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return null
    }
}

impl TypeInfoEnum {
    get_enum_member(self: &TypeInfoEnum, tag: i64) -> ^TypeInfoEnumMember {
        #macro {
            local arr : []TypeInfoEnumMember = members
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : &TypeInfoEnumMember = get_index(arr, it_index)
                        #link #anonymous {
                            mem : &TypeInfoEnumMember = it
                            it_index : i64 = it_index
                            {
                                if ((*mem).tag == tag) {
                                    it_index = (it_index + 1);
                                    return ^*mem
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return null
    }
    
    get_tag(self: &TypeInfoEnum, value: ^void) -> i64 {
        return match @tempvar_212((*self).tag_type) {
            $ti if (cast(^void) (ti) == cast(^void) (@type_info(u8))) -> cast(i64) (*cast(^u8) (value))
            $ti if (cast(^void) (ti) == cast(^void) (@type_info(u16))) -> cast(i64) (*cast(^u16) (value))
            $ti if (cast(^void) (ti) == cast(^void) (@type_info(u32))) -> cast(i64) (*cast(^u32) (value))
            $ti if (cast(^void) (ti) == cast(^void) (@type_info(u64))) -> cast(i64) (*cast(^u64) (value))
            $ti if (cast(^void) (ti) == cast(^void) (@type_info(i8))) -> cast(i64) (*cast(^i8) (value))
            $ti if (cast(^void) (ti) == cast(^void) (@type_info(i16))) -> cast(i64) (*cast(^i16) (value))
            $ti if (cast(^void) (ti) == cast(^void) (@type_info(i32))) -> cast(i64) (*cast(^i32) (value))
            $ti if (cast(^void) (ti) == cast(^void) (@type_info(i64))) -> *cast(^i64) (value)
            _ -> -1
        }
    }
}

impl TypeInfoTraitImpl {
    get_function(&TypeInfoTraitImpl, func_name: string, $F: type) -> F {
        ti_trait :  = cast() ((self).trait_type)
        func_info :  = (ti_trait).get_function(func_name)
        @assert((func_info != null))
        function :  = cast() (cast() ((int(vtable) + (func_info).offset)))
        return function
    }
}

impl TypeInfoAttribute {
    get_arg(&TypeInfoAttribute, index: int, $T: type) -> T {
        @assert(((index >= 0) and (index < ((self).args).length)))
        arg :  = *(self).args[index]
        @assert((@type_info(T) == @type_info_of_any(arg)))
        return *cast() (arg)
    }
}

impl TypeInfoStructMember {
    get_attribute(self: &TypeInfoStructMember, name: string) -> ^TypeInfoAttribute {
        #macro {
            local arr : []TypeInfoAttribute = attributes
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : &TypeInfoAttribute = get_index(arr, it_index)
                        #link #anonymous {
                            att : &TypeInfoAttribute = it
                            it_index : i64 = it_index
                            {
                                if strings_equal((*att).name, name) {
                                    it_index = (it_index + 1);
                                    return ^*att
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return null
    }
    
    has_attribute(self: &TypeInfoStructMember, name: string) -> bool {
        #macro {
            local arr : []TypeInfoAttribute = attributes
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : &TypeInfoAttribute = get_index(arr, it_index)
                        #link #anonymous {
                            att : &TypeInfoAttribute = it
                            it_index : i64 = it_index
                            {
                                if strings_equal((*att).name, name) {
                                    it_index = (it_index + 1);
                                    return true
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return false
    }
}

impl TypeInfoEnumMember {
    get_attribute(self: &TypeInfoEnumMember, name: string) -> ^TypeInfoAttribute {
        #macro {
            local arr : []TypeInfoAttribute = attributes
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : &TypeInfoAttribute = get_index(arr, it_index)
                        #link #anonymous {
                            att : &TypeInfoAttribute = it
                            it_index : i64 = it_index
                            {
                                if strings_equal((*att).name, name) {
                                    it_index = (it_index + 1);
                                    return ^*att
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return null
    }
    
    has_attribute(self: &TypeInfoEnumMember, name: string) -> bool {
        #macro {
            local arr : []TypeInfoAttribute = attributes
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : &TypeInfoAttribute = get_index(arr, it_index)
                        #link #anonymous {
                            att : &TypeInfoAttribute = it
                            it_index : i64 = it_index
                            {
                                if strings_equal((*att).name, name) {
                                    it_index = (it_index + 1);
                                    return true
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return false
    }
}

impl TypeInfoTrait {
    get_function(self: &TypeInfoTrait, name: string) -> ^TypeInfoTraitFunction {
        #macro {
            local arr : []TypeInfoTraitFunction = functions
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : &TypeInfoTraitFunction = get_index(arr, it_index)
                        #link #anonymous {
                            it : &TypeInfoTraitFunction = it
                            it_index : i64 = it_index
                            {
                                if strings_equal(name, (*it).name) {
                                    it_index = (it_index + 1);
                                    return ^*it
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return null
    }
}

strings_not_equal :: strings_not_equal(a: string, b: string) -> bool #operator("!=") {
    return !strings_equal(a, b)
}

strings_equal :: strings_equal(a: string, b: string) -> bool #operator("==") {
    a_bytes : []u8 = (a).bytes
    b_bytes : []u8 = (b).bytes
    if ((a_bytes).length != (b_bytes).length) {
        return false
    } else {}
    #macro {
        local r : Range[i64] = new Range[i64] { start = 0, end = (a_bytes).length }
        
        rev : bool = ((r).end < (r).start)
        inc : i64 = if rev then -1 else 1
        
        {
            @id((it, it_index)_1) : (i64, i64) = ((r).start, 0)
            it : i64 = @var(@id((it, it_index)_1))[0]
            it_index : i64 = @var(@id((it, it_index)_1))[1]
            loop {
                if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                defer #anonymous {
                    it_index = (it_index + 1)
                    it = (it + inc)
                }
                #link #anonymous {
                    it : i64 = it
                    it_index : i64 = it_index
                    {
                        if (*get_index(a_bytes, it) != *get_index(b_bytes, it)) {
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            };
                            return false
                        } else {}
                    }
                }
                #anonymous {
                    it_index = (it_index + 1)
                    it = (it + inc)
                }
            }
        }
    }
    return true
}

pointer_add_sized : (ptr: ^$T, amount: int) -> ^T : pointer_add_sized(ptr: ^$T, amount: int) -> ^T {
    return cast() ((cast() (ptr) + (amount * @sizeof(T))))
}
// Polymorphic instances for pointer_add_sized(ptr: ^$T, amount: int) -> ^T
    /* T = (type, u8) */
    /*  */
    pointer_add_sized(ptr: ^u8, amount: i64) -> ^u8 {
        return cast(^u8) ((cast(i64) (ptr) + (amount * @sizeof(u8))))
    }
    /* T = (type, Entry[string, string]) */
    /*  */
    pointer_add_sized(ptr: ^Entry[string, string], amount: i64) -> ^Entry[string, string] {
        return cast(^Entry[string, string]) ((cast(i64) (ptr) + (amount * @sizeof(Entry[string, string]))))
    }
    /* T = (type, ^any) */
    /*  */
    pointer_add_sized(ptr: ^^any, amount: i64) -> ^^any {
        return cast(^^any) ((cast(i64) (ptr) + (amount * @sizeof(^any))))
    }
    /* T = (type, char32) */
    /*  */
    pointer_add_sized(ptr: ^char32, amount: i64) -> ^char32 {
        return cast(^char32) ((cast(i64) (ptr) + (amount * @sizeof(char32))))
    }
    /* T = (type, string) */
    /*  */
    pointer_add_sized(ptr: ^string, amount: i64) -> ^string {
        return cast(^string) ((cast(i64) (ptr) + (amount * @sizeof(string))))
    }
    /* T = (type, String) */
    /*  */
    pointer_add_sized(ptr: ^String, amount: i64) -> ^String {
        return cast(^String) ((cast(i64) (ptr) + (amount * @sizeof(String))))
    }
    /* T = (type, TypeInfoEnumMember) */
    /*  */
    pointer_add_sized(ptr: ^TypeInfoEnumMember, amount: i64) -> ^TypeInfoEnumMember {
        return cast(^TypeInfoEnumMember) ((cast(i64) (ptr) + (amount * @sizeof(TypeInfoEnumMember))))
    }
    /* T = (type, TypeInfoStructMember) */
    /*  */
    pointer_add_sized(ptr: ^TypeInfoStructMember, amount: i64) -> ^TypeInfoStructMember {
        return cast(^TypeInfoStructMember) ((cast(i64) (ptr) + (amount * @sizeof(TypeInfoStructMember))))
    }
    /* T = (type, TypeInfoTupleMember) */
    /*  */
    pointer_add_sized(ptr: ^TypeInfoTupleMember, amount: i64) -> ^TypeInfoTupleMember {
        return cast(^TypeInfoTupleMember) ((cast(i64) (ptr) + (amount * @sizeof(TypeInfoTupleMember))))
    }
    /* T = (type, void) */
    /*  */
    pointer_add_sized(ptr: ^void, amount: i64) -> ^void {
        return cast(^void) ((cast(i64) (ptr) + (amount * @sizeof(void))))
    }
    /* T = (type, u16) */
    /*  */
    pointer_add_sized(ptr: ^u16, amount: i64) -> ^u16 {
        return cast(^u16) ((cast(i64) (ptr) + (amount * @sizeof(u16))))
    }
    /* T = (type, TypeInfoAttribute) */
    /*  */
    pointer_add_sized(ptr: ^TypeInfoAttribute, amount: i64) -> ^TypeInfoAttribute {
        return cast(^TypeInfoAttribute) ((cast(i64) (ptr) + (amount * @sizeof(TypeInfoAttribute))))
    }
    /* T = (type, TypeInfoTraitFunction) */
    /*  */
    pointer_add_sized(ptr: ^TypeInfoTraitFunction, amount: i64) -> ^TypeInfoTraitFunction {
        return cast(^TypeInfoTraitFunction) ((cast(i64) (ptr) + (amount * @sizeof(TypeInfoTraitFunction))))
    }
    /* T = (type, ^Printable) */
    /*  */
    pointer_add_sized(ptr: ^^Printable, amount: i64) -> ^^Printable {
        return cast(^^Printable) ((cast(i64) (ptr) + (amount * @sizeof(^Printable))))
    }
    /* T = (type, (fmt: string, args: []^any)) */
    /*  */
    pointer_add_sized(ptr: ^(fmt: string, args: []^any), amount: i64) -> ^(fmt: string, args: []^any) {
        return cast(^(fmt: string, args: []^any)) ((cast(i64) (ptr) + (amount * @sizeof((fmt: string, args: []^any)))))
    }
    /* T = (type, TypeInfoImplFunction) */
    /*  */
    pointer_add_sized(ptr: ^TypeInfoImplFunction, amount: i64) -> ^TypeInfoImplFunction {
        return cast(^TypeInfoImplFunction) ((cast(i64) (ptr) + (amount * @sizeof(TypeInfoImplFunction))))
    }
    /* T = (type, Entry[TypeId, Array[^AstImpl]]) */
    /*  */
    pointer_add_sized(ptr: ^Entry[TypeId, Array[^AstImpl]], amount: i64) -> ^Entry[TypeId, Array[^AstImpl]] {
        return cast(^Entry[TypeId, Array[^AstImpl]]) ((cast(i64) (ptr) + (amount * @sizeof(Entry[TypeId, Array[^AstImpl]]))))
    }
    /* T = (type, ^TypeInfo) */
    /*  */
    pointer_add_sized(ptr: ^^TypeInfo, amount: i64) -> ^^TypeInfo {
        return cast(^^TypeInfo) ((cast(i64) (ptr) + (amount * @sizeof(^TypeInfo))))
    }
    /* T = (type, char8) */
    /*  */
    pointer_add_sized(ptr: ^char8, amount: i64) -> ^char8 {
        return cast(^char8) ((cast(i64) (ptr) + (amount * @sizeof(char8))))
    }
    /* T = (type, Utf8Format) */
    /*  */
    pointer_add_sized(ptr: ^Utf8Format, amount: i64) -> ^Utf8Format {
        return cast(^Utf8Format) ((cast(i64) (ptr) + (amount * @sizeof(Utf8Format))))
    }
    /* T = (type, i64) */
    /*  */
    pointer_add_sized(ptr: ^i64, amount: i64) -> ^i64 {
        return cast(^i64) ((cast(i64) (ptr) + (amount * @sizeof(i64))))
    }
    /* T = (type, StackFrame) */
    /*  */
    pointer_add_sized(ptr: ^StackFrame, amount: i64) -> ^StackFrame {
        return cast(^StackFrame) ((cast(i64) (ptr) + (amount * @sizeof(StackFrame))))
    }
    /* T = (type, u64) */
    /*  */
    pointer_add_sized(ptr: ^u64, amount: i64) -> ^u64 {
        return cast(^u64) ((cast(i64) (ptr) + (amount * @sizeof(u64))))
    }
    /* T = (type, ^AstNode) */
    /*  */
    pointer_add_sized(ptr: ^^AstNode, amount: i64) -> ^^AstNode {
        return cast(^^AstNode) ((cast(i64) (ptr) + (amount * @sizeof(^AstNode))))
    }
    /* T = (type, Entry[i64, ^AstStruct]) */
    /*  */
    pointer_add_sized(ptr: ^Entry[i64, ^AstStruct], amount: i64) -> ^Entry[i64, ^AstStruct] {
        return cast(^Entry[i64, ^AstStruct]) ((cast(i64) (ptr) + (amount * @sizeof(Entry[i64, ^AstStruct]))))
    }
    /* T = (type, Entry[string, SourceFile]) */
    /*  */
    pointer_add_sized(ptr: ^Entry[string, SourceFile], amount: i64) -> ^Entry[string, SourceFile] {
        return cast(^Entry[string, SourceFile]) ((cast(i64) (ptr) + (amount * @sizeof(Entry[string, SourceFile]))))
    }
    /* T = (type, Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]) */
    /*  */
    pointer_add_sized(ptr: ^Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], amount: i64) -> ^Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] {
        return cast(^Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]) ((cast(i64) (ptr) + (amount * @sizeof(Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]))))
    }
    /* T = (type, Rc[Workspace]) */
    /*  */
    pointer_add_sized(ptr: ^Rc[Workspace], amount: i64) -> ^Rc[Workspace] {
        return cast(^Rc[Workspace]) ((cast(i64) (ptr) + (amount * @sizeof(Rc[Workspace]))))
    }
    /* T = (type, ^FiberContext) */
    /*  */
    pointer_add_sized(ptr: ^^FiberContext, amount: i64) -> ^^FiberContext {
        return cast(^^FiberContext) ((cast(i64) (ptr) + (amount * @sizeof(^FiberContext))))
    }
    /* T = (type, Entry[string, String]) */
    /*  */
    pointer_add_sized(ptr: ^Entry[string, String], amount: i64) -> ^Entry[string, String] {
        return cast(^Entry[string, String]) ((cast(i64) (ptr) + (amount * @sizeof(Entry[string, String]))))
    }
    /* T = (type, (name: string, symbol: Symbol)) */
    /*  */
    pointer_add_sized(ptr: ^(name: string, symbol: Symbol), amount: i64) -> ^(name: string, symbol: Symbol) {
        return cast(^(name: string, symbol: Symbol)) ((cast(i64) (ptr) + (amount * @sizeof((name: string, symbol: Symbol)))))
    }
    /* T = (type, Entry[string, Symbol]) */
    /*  */
    pointer_add_sized(ptr: ^Entry[string, Symbol], amount: i64) -> ^Entry[string, Symbol] {
        return cast(^Entry[string, Symbol]) ((cast(i64) (ptr) + (amount * @sizeof(Entry[string, Symbol]))))
    }
    /* T = (type, ^AstDecl) */
    /*  */
    pointer_add_sized(ptr: ^^AstDecl, amount: i64) -> ^^AstDecl {
        return cast(^^AstDecl) ((cast(i64) (ptr) + (amount * @sizeof(^AstDecl))))
    }
    /* T = (type, ^AstConstDecl) */
    /*  */
    pointer_add_sized(ptr: ^^AstConstDecl, amount: i64) -> ^^AstConstDecl {
        return cast(^^AstConstDecl) ((cast(i64) (ptr) + (amount * @sizeof(^AstConstDecl))))
    }
    /* T = (type, Entry[i64, i64]) */
    /*  */
    pointer_add_sized(ptr: ^Entry[i64, i64], amount: i64) -> ^Entry[i64, i64] {
        return cast(^Entry[i64, i64]) ((cast(i64) (ptr) + (amount * @sizeof(Entry[i64, i64]))))
    }
    /* T = (type, LineInfo) */
    /*  */
    pointer_add_sized(ptr: ^LineInfo, amount: i64) -> ^LineInfo {
        return cast(^LineInfo) ((cast(i64) (ptr) + (amount * @sizeof(LineInfo))))
    }
    /* T = (type, VariableInfo) */
    /*  */
    pointer_add_sized(ptr: ^VariableInfo, amount: i64) -> ^VariableInfo {
        return cast(^VariableInfo) ((cast(i64) (ptr) + (amount * @sizeof(VariableInfo))))
    }
    /* T = (type, Bucket) */
    /*  */
    pointer_add_sized(ptr: ^Bucket, amount: i64) -> ^Bucket {
        return cast(^Bucket) ((cast(i64) (ptr) + (amount * @sizeof(Bucket))))
    }
    /* T = (type, (name: string, mem: ^TypeInfoStructMember, set: bool)) */
    /*  */
    pointer_add_sized(ptr: ^(name: string, mem: ^TypeInfoStructMember, set: bool), amount: i64) -> ^(name: string, mem: ^TypeInfoStructMember, set: bool) {
        return cast(^(name: string, mem: ^TypeInfoStructMember, set: bool)) ((cast(i64) (ptr) + (amount * @sizeof((name: string, mem: ^TypeInfoStructMember, set: bool)))))
    }
    /* T = (type, ^AstArgument) */
    /*  */
    pointer_add_sized(ptr: ^^AstArgument, amount: i64) -> ^^AstArgument {
        return cast(^^AstArgument) ((cast(i64) (ptr) + (amount * @sizeof(^AstArgument))))
    }
    /* T = (type, ^AstMatchCase) */
    /*  */
    pointer_add_sized(ptr: ^^AstMatchCase, amount: i64) -> ^^AstMatchCase {
        return cast(^^AstMatchCase) ((cast(i64) (ptr) + (amount * @sizeof(^AstMatchCase))))
    }
    /* T = (type, Thread) */
    /*  */
    pointer_add_sized(ptr: ^Thread, amount: i64) -> ^Thread {
        return cast(^Thread) ((cast(i64) (ptr) + (amount * @sizeof(Thread))))
    }
    /* T = (type, ^AstImpl) */
    /*  */
    pointer_add_sized(ptr: ^^AstImpl, amount: i64) -> ^^AstImpl {
        return cast(^^AstImpl) ((cast(i64) (ptr) + (amount * @sizeof(^AstImpl))))
    }
    /* T = (type, ^CompileStructMemberJob) */
    /*  */
    pointer_add_sized(ptr: ^^CompileStructMemberJob, amount: i64) -> ^^CompileStructMemberJob {
        return cast(^^CompileStructMemberJob) ((cast(i64) (ptr) + (amount * @sizeof(^CompileStructMemberJob))))
    }
    /* T = (type, BumpBucket) */
    /*  */
    pointer_add_sized(ptr: ^BumpBucket, amount: i64) -> ^BumpBucket {
        return cast(^BumpBucket) ((cast(i64) (ptr) + (amount * @sizeof(BumpBucket))))
    }
    /* T = (type, TypeInfoTraitImpl) */
    /*  */
    pointer_add_sized(ptr: ^TypeInfoTraitImpl, amount: i64) -> ^TypeInfoTraitImpl {
        return cast(^TypeInfoTraitImpl) ((cast(i64) (ptr) + (amount * @sizeof(TypeInfoTraitImpl))))
    }


pointer_add : (ptr: ^$T, amount: int) -> ^T : pointer_add(ptr: ^$T, amount: int) -> ^T {
    return cast() ((cast() (ptr) + amount))
}

max : (a: $T, b: T) -> T : max(a: $T, b: T) -> T {
    return if (a >= b) then a else b
}
// Polymorphic instances for max(a: $T, b: T) -> T
    /* T = (type, i64) */
    /*  */
    max(a: i64, b: i64) -> i64 {
        return if (a >= b) then a else b
    }


min : (a: $T, b: T) -> T : min(a: $T, b: T) -> T {
    return if (a <= b) then a else b
}
// Polymorphic instances for min(a: $T, b: T) -> T
    /* T = (type, i64) */
    /*  */
    min(a: i64, b: i64) -> i64 {
        return if (a <= b) then a else b
    }


#file array.che
use import std.mem.allocator

use import std.mem.std_heap_allocator

use import std.iterator

C :  : import std.c

Array :: struct(T: type) {
    data : 
    capacity : 
    length : 
    allocator : 
}
// Polymorphic instances for struct(T: type)
    // T = String
    struct { // size: 40, alignment: 8
        data : ^String
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = u8
    struct { // size: 40, alignment: 8
        data : ^u8
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = string
    struct { // size: 40, alignment: 8
        data : ^string
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = u16
    struct { // size: 40, alignment: 8
        data : ^u16
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = ^AstDecl
    struct { // size: 40, alignment: 8
        data : ^^AstDecl
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = ^AstNode
    struct { // size: 40, alignment: 8
        data : ^^AstNode
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = ^AstArgument
    struct { // size: 40, alignment: 8
        data : ^^AstArgument
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = i64
    struct { // size: 40, alignment: 8
        data : ^i64
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = Bucket
    struct { // size: 40, alignment: 8
        data : ^Bucket
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = Rc[Workspace]
    struct { // size: 40, alignment: 8
        data : ^Rc[Workspace]
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = ^FiberContext
    struct { // size: 40, alignment: 8
        data : ^^FiberContext
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = Thread
    struct { // size: 40, alignment: 8
        data : ^Thread
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = (name: string, symbol: Symbol)
    struct { // size: 40, alignment: 8
        data : ^(name: string, symbol: Symbol)
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = ^AstImpl
    struct { // size: 40, alignment: 8
        data : ^^AstImpl
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = BumpBucket
    struct { // size: 40, alignment: 8
        data : ^BumpBucket
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = ^AstConstDecl
    struct { // size: 40, alignment: 8
        data : ^^AstConstDecl
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = ^AstMatchCase
    struct { // size: 40, alignment: 8
        data : ^^AstMatchCase
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = LineInfo
    struct { // size: 40, alignment: 8
        data : ^LineInfo
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = VariableInfo
    struct { // size: 40, alignment: 8
        data : ^VariableInfo
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = u64
    struct { // size: 40, alignment: 8
        data : ^u64
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = (name: string, mem: ^TypeInfoStructMember, set: bool)
    struct { // size: 40, alignment: 8
        data : ^(name: string, mem: ^TypeInfoStructMember, set: bool)
        capacity : i64
        length : i64
        allocator : ^Allocator
    }
    // T = ^CompileStructMemberJob
    struct { // size: 40, alignment: 8
        data : ^^CompileStructMemberJob
        capacity : i64
        length : i64
        allocator : ^Allocator
    }


impl(T: type) Drop for Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(T: type) Drop for Cheez.Types.Abstract.GenericStructType
    // T = (type, ^AstNode)
    impl(T: type) Drop for Array[^AstNode] {
        drop(self: &Array[^AstNode]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_294) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_294))[0]
                    it_index : i64 = @var(@id((it, it_index)_294))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, Rc[Workspace])
    impl(T: type) Drop for Array[Rc[Workspace]] {
        drop(self: &Array[Rc[Workspace]]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_327) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_327))[0]
                    it_index : i64 = @var(@id((it, it_index)_327))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, ^FiberContext)
    impl(T: type) Drop for Array[^FiberContext] {
        drop(self: &Array[^FiberContext]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_335) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_335))[0]
                    it_index : i64 = @var(@id((it, it_index)_335))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, (name: string, symbol: Symbol))
    impl(T: type) Drop for Array[(name: string, symbol: Symbol)] {
        drop(self: &Array[(name: string, symbol: Symbol)]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_357) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_357))[0]
                    it_index : i64 = @var(@id((it, it_index)_357))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, ^AstDecl)
    impl(T: type) Drop for Array[^AstDecl] {
        drop(self: &Array[^AstDecl]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_370) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_370))[0]
                    it_index : i64 = @var(@id((it, it_index)_370))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, ^AstConstDecl)
    impl(T: type) Drop for Array[^AstConstDecl] {
        drop(self: &Array[^AstConstDecl]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_379) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_379))[0]
                    it_index : i64 = @var(@id((it, it_index)_379))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, LineInfo)
    impl(T: type) Drop for Array[LineInfo] {
        drop(self: &Array[LineInfo]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_394) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_394))[0]
                    it_index : i64 = @var(@id((it, it_index)_394))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, VariableInfo)
    impl(T: type) Drop for Array[VariableInfo] {
        drop(self: &Array[VariableInfo]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_401) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_401))[0]
                    it_index : i64 = @var(@id((it, it_index)_401))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, u64)
    impl(T: type) Drop for Array[u64] {
        drop(self: &Array[u64]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_408) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_408))[0]
                    it_index : i64 = @var(@id((it, it_index)_408))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, i64)
    impl(T: type) Drop for Array[i64] {
        drop(self: &Array[i64]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_418) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_418))[0]
                    it_index : i64 = @var(@id((it, it_index)_418))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, String)
    impl(T: type) Drop for Array[String] {
        drop(self: &Array[String]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_428) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_428))[0]
                    it_index : i64 = @var(@id((it, it_index)_428))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, Bucket)
    impl(T: type) Drop for Array[Bucket] {
        drop(self: &Array[Bucket]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_439) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_439))[0]
                    it_index : i64 = @var(@id((it, it_index)_439))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, (name: string, mem: ^TypeInfoStructMember, set: bool))
    impl(T: type) Drop for Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] {
        drop(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_459) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_459))[0]
                    it_index : i64 = @var(@id((it, it_index)_459))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, string)
    impl(T: type) Drop for Array[string] {
        drop(self: &Array[string]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_469) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_469))[0]
                    it_index : i64 = @var(@id((it, it_index)_469))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, u16)
    impl(T: type) Drop for Array[u16] {
        drop(self: &Array[u16]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_506) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_506))[0]
                    it_index : i64 = @var(@id((it, it_index)_506))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, u8)
    impl(T: type) Drop for Array[u8] {
        drop(self: &Array[u8]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_516) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_516))[0]
                    it_index : i64 = @var(@id((it, it_index)_516))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, ^AstArgument)
    impl(T: type) Drop for Array[^AstArgument] {
        drop(self: &Array[^AstArgument]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_526) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_526))[0]
                    it_index : i64 = @var(@id((it, it_index)_526))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, ^AstMatchCase)
    impl(T: type) Drop for Array[^AstMatchCase] {
        drop(self: &Array[^AstMatchCase]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_535) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_535))[0]
                    it_index : i64 = @var(@id((it, it_index)_535))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, Thread)
    impl(T: type) Drop for Array[Thread] {
        drop(self: &Array[Thread]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_548) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_548))[0]
                    it_index : i64 = @var(@id((it, it_index)_548))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, ^AstImpl)
    impl(T: type) Drop for Array[^AstImpl] {
        drop(self: &Array[^AstImpl]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_572) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_572))[0]
                    it_index : i64 = @var(@id((it, it_index)_572))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, ^CompileStructMemberJob)
    impl(T: type) Drop for Array[^CompileStructMemberJob] {
        drop(self: &Array[^CompileStructMemberJob]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_583) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_583))[0]
                    it_index : i64 = @var(@id((it, it_index)_583))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }
    // T = (type, BumpBucket)
    impl(T: type) Drop for Array[BumpBucket] {
        drop(self: &Array[BumpBucket]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_597) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_597))[0]
                    it_index : i64 = @var(@id((it, it_index)_597))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (Memory).drop(data[it])
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            free(data, allocator)
            data = null
            length = 0
        }
    }


impl(T: type) Clone for Cheez.Types.Abstract.GenericStructType if T : Clone {
    
}
// Polymorphic instances for impl(T: type) Clone for Cheez.Types.Abstract.GenericStructType if T : Clone
    // T = (type, Rc[Workspace])
    impl(T: type) Clone for Array[Rc[Workspace]] {
        clone(self: &Array[Rc[Workspace]]) -> Array[Rc[Workspace]] {
            result : Array[Rc[Workspace]] = (Array[Rc[Workspace]]).create(self.count(), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : []Rc[Workspace] = self.slice()
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &Rc[Workspace] = get_index(arr, it_index)
                            #link #anonymous {
                                v : &Rc[Workspace] = it
                                it_index : i64 = it_index
                                {
                                    &result.add(v.clone())
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            return result
        }
    }
    // T = (type, String)
    impl(T: type) Clone for Array[String] {
        clone(self: &Array[String]) -> Array[String] {
            result : Array[String] = (Array[String]).create(self.count(), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : []String = self.slice()
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &String = get_index(arr, it_index)
                            #link #anonymous {
                                v : &String = it
                                it_index : i64 = it_index
                                {
                                    &result.add(v.clone())
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            return result
        }
    }
    // T = (type, string)
    impl(T: type) Clone for Array[string] {
        clone(self: &Array[string]) -> Array[string] {
            result : Array[string] = (Array[string]).create(self.count(), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : []string = self.slice()
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &string = get_index(arr, it_index)
                            #link #anonymous {
                                v : &string = it
                                it_index : i64 = it_index
                                {
                                    &result.add(v.clone())
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            return result
        }
    }


impl(T: type) Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(T: type) Cheez.Types.Abstract.GenericStructType
    // T = (type, ^AstNode)
    impl(T: type) Array[^AstNode] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^AstNode] {
            s : Array[^AstNode] = new Array[^AstNode] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^AstNode))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^AstNode] {
            s : Array[^AstNode] = new Array[^AstNode] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^AstNode))))
            return s
        }
        
        reserve(self: &Array[^AstNode], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(^AstNode))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[^AstNode]) -> i64 {
            return length
        }
        
        count(self: &Array[^AstNode]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[^AstNode]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[^AstNode]) -> ^^AstNode {
            return data
        }
        
        clear(self: &Array[^AstNode]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_296) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_296))[0]
                    it_index : i64 = @var(@id((it, it_index)_296))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[^AstNode], val: ^AstNode) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[^AstNode], values: []^AstNode) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(^AstNode) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[^AstNode], val: ^AstNode) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[^AstNode]) -> ^AstNode {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[^AstNode]) -> &^AstNode {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[^AstNode], index: i64) -> Option[^AstNode] {
            if ((index < 0) or (index >= length)) {
                return Option[^AstNode].None
            } else {
                return Option[^AstNode].Some(data[index])
            }
        }
        
        remove_at(self: &Array[^AstNode], index: i64) -> ^AstNode {
            @assert(((index >= 0) and (index < self.get_length())))
            result : ^AstNode = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[^AstNode], index: i64) -> &^AstNode {
            return &data[index]
        }
        
        access(self: &Array[^AstNode], index: i64) -> &^AstNode #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[^AstNode], from: i64, len: i64) -> []^AstNode {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []^AstNode = cast([]^AstNode) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[^AstNode]) -> []^AstNode {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[^AstNode], from: i64) -> []^AstNode {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[^AstNode], len: i64) -> []^AstNode {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[^AstNode], cmp: fn(&^AstNode, &^AstNode) -> i64) -> &Array[^AstNode] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[^AstNode], from: i64, to: i64, cmp: fn(&^AstNode, &^AstNode) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : ^AstNode = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_299) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_299))[0]
                    it_index : i64 = @var(@id((it, it_index)_299))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[^AstNode]) -> ArrayIterator[^AstNode] {
            return new ArrayIterator[^AstNode] { array = self, index = 0 }
        }
    }
    // T = (type, Rc[Workspace])
    impl(T: type) Array[Rc[Workspace]] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[Rc[Workspace]] {
            s : Array[Rc[Workspace]] = new Array[Rc[Workspace]] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(Rc[Workspace]))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[Rc[Workspace]] {
            s : Array[Rc[Workspace]] = new Array[Rc[Workspace]] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(Rc[Workspace]))))
            return s
        }
        
        reserve(self: &Array[Rc[Workspace]], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(Rc[Workspace]))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[Rc[Workspace]]) -> i64 {
            return length
        }
        
        count(self: &Array[Rc[Workspace]]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[Rc[Workspace]]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[Rc[Workspace]]) -> ^Rc[Workspace] {
            return data
        }
        
        clear(self: &Array[Rc[Workspace]]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_329) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_329))[0]
                    it_index : i64 = @var(@id((it, it_index)_329))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[Rc[Workspace]], val: Rc[Workspace]) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[Rc[Workspace]], values: []Rc[Workspace]) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(Rc[Workspace]) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[Rc[Workspace]], val: Rc[Workspace]) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[Rc[Workspace]]) -> Rc[Workspace] {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[Rc[Workspace]]) -> &Rc[Workspace] {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[Rc[Workspace]], index: i64) -> Option[Rc[Workspace]] {
            if ((index < 0) or (index >= length)) {
                return Option[Rc[Workspace]].None
            } else {
                return Option[Rc[Workspace]].Some(data[index])
            }
        }
        
        remove_at(self: &Array[Rc[Workspace]], index: i64) -> Rc[Workspace] {
            @assert(((index >= 0) and (index < self.get_length())))
            result : Rc[Workspace] = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[Rc[Workspace]], index: i64) -> &Rc[Workspace] {
            return &data[index]
        }
        
        access(self: &Array[Rc[Workspace]], index: i64) -> &Rc[Workspace] #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[Rc[Workspace]], from: i64, len: i64) -> []Rc[Workspace] {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []Rc[Workspace] = cast([]Rc[Workspace]) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[Rc[Workspace]]) -> []Rc[Workspace] {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[Rc[Workspace]], from: i64) -> []Rc[Workspace] {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[Rc[Workspace]], len: i64) -> []Rc[Workspace] {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[Rc[Workspace]], cmp: fn(&Rc[Workspace], &Rc[Workspace]) -> i64) -> &Array[Rc[Workspace]] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[Rc[Workspace]], from: i64, to: i64, cmp: fn(&Rc[Workspace], &Rc[Workspace]) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : Rc[Workspace] = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_332) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_332))[0]
                    it_index : i64 = @var(@id((it, it_index)_332))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
            @destruct(pivot)
        }
        
        iterator(self: &Array[Rc[Workspace]]) -> ArrayIterator[Rc[Workspace]] {
            return new ArrayIterator[Rc[Workspace]] { array = self, index = 0 }
        }
    }
    // T = (type, ^FiberContext)
    impl(T: type) Array[^FiberContext] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^FiberContext] {
            s : Array[^FiberContext] = new Array[^FiberContext] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^FiberContext))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^FiberContext] {
            s : Array[^FiberContext] = new Array[^FiberContext] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^FiberContext))))
            return s
        }
        
        reserve(self: &Array[^FiberContext], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(^FiberContext))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[^FiberContext]) -> i64 {
            return length
        }
        
        count(self: &Array[^FiberContext]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[^FiberContext]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[^FiberContext]) -> ^^FiberContext {
            return data
        }
        
        clear(self: &Array[^FiberContext]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_337) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_337))[0]
                    it_index : i64 = @var(@id((it, it_index)_337))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[^FiberContext], val: ^FiberContext) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[^FiberContext], values: []^FiberContext) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(^FiberContext) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[^FiberContext], val: ^FiberContext) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[^FiberContext]) -> ^FiberContext {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[^FiberContext]) -> &^FiberContext {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[^FiberContext], index: i64) -> Option[^FiberContext] {
            if ((index < 0) or (index >= length)) {
                return Option[^FiberContext].None
            } else {
                return Option[^FiberContext].Some(data[index])
            }
        }
        
        remove_at(self: &Array[^FiberContext], index: i64) -> ^FiberContext {
            @assert(((index >= 0) and (index < self.get_length())))
            result : ^FiberContext = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[^FiberContext], index: i64) -> &^FiberContext {
            return &data[index]
        }
        
        access(self: &Array[^FiberContext], index: i64) -> &^FiberContext #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[^FiberContext], from: i64, len: i64) -> []^FiberContext {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []^FiberContext = cast([]^FiberContext) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[^FiberContext]) -> []^FiberContext {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[^FiberContext], from: i64) -> []^FiberContext {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[^FiberContext], len: i64) -> []^FiberContext {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[^FiberContext], cmp: fn(&^FiberContext, &^FiberContext) -> i64) -> &Array[^FiberContext] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[^FiberContext], from: i64, to: i64, cmp: fn(&^FiberContext, &^FiberContext) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : ^FiberContext = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_340) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_340))[0]
                    it_index : i64 = @var(@id((it, it_index)_340))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[^FiberContext]) -> ArrayIterator[^FiberContext] {
            return new ArrayIterator[^FiberContext] { array = self, index = 0 }
        }
    }
    // T = (type, (name: string, symbol: Symbol))
    impl(T: type) Array[(name: string, symbol: Symbol)] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[(name: string, symbol: Symbol)] {
            s : Array[(name: string, symbol: Symbol)] = new Array[(name: string, symbol: Symbol)] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof((name: string, symbol: Symbol)))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[(name: string, symbol: Symbol)] {
            s : Array[(name: string, symbol: Symbol)] = new Array[(name: string, symbol: Symbol)] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof((name: string, symbol: Symbol)))))
            return s
        }
        
        reserve(self: &Array[(name: string, symbol: Symbol)], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof((name: string, symbol: Symbol)))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[(name: string, symbol: Symbol)]) -> i64 {
            return length
        }
        
        count(self: &Array[(name: string, symbol: Symbol)]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[(name: string, symbol: Symbol)]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[(name: string, symbol: Symbol)]) -> ^(name: string, symbol: Symbol) {
            return data
        }
        
        clear(self: &Array[(name: string, symbol: Symbol)]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_359) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_359))[0]
                    it_index : i64 = @var(@id((it, it_index)_359))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[(name: string, symbol: Symbol)], val: (name: string, symbol: Symbol)) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[(name: string, symbol: Symbol)], values: [](name: string, symbol: Symbol)) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof((name: string, symbol: Symbol)) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[(name: string, symbol: Symbol)], val: (name: string, symbol: Symbol)) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[(name: string, symbol: Symbol)]) -> (name: string, symbol: Symbol) {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[(name: string, symbol: Symbol)]) -> &(name: string, symbol: Symbol) {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[(name: string, symbol: Symbol)], index: i64) -> Option[(name: string, symbol: Symbol)] {
            if ((index < 0) or (index >= length)) {
                return Option[(name: string, symbol: Symbol)].None
            } else {
                return Option[(name: string, symbol: Symbol)].Some(data[index])
            }
        }
        
        remove_at(self: &Array[(name: string, symbol: Symbol)], index: i64) -> (name: string, symbol: Symbol) {
            @assert(((index >= 0) and (index < self.get_length())))
            result : (name: string, symbol: Symbol) = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[(name: string, symbol: Symbol)], index: i64) -> &(name: string, symbol: Symbol) {
            return &data[index]
        }
        
        access(self: &Array[(name: string, symbol: Symbol)], index: i64) -> &(name: string, symbol: Symbol) #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[(name: string, symbol: Symbol)], from: i64, len: i64) -> [](name: string, symbol: Symbol) {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : [](name: string, symbol: Symbol) = cast([](name: string, symbol: Symbol)) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[(name: string, symbol: Symbol)]) -> [](name: string, symbol: Symbol) {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[(name: string, symbol: Symbol)], from: i64) -> [](name: string, symbol: Symbol) {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[(name: string, symbol: Symbol)], len: i64) -> [](name: string, symbol: Symbol) {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[(name: string, symbol: Symbol)], cmp: fn(&(name: string, symbol: Symbol), &(name: string, symbol: Symbol)) -> i64) -> &Array[(name: string, symbol: Symbol)] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[(name: string, symbol: Symbol)], from: i64, to: i64, cmp: fn(&(name: string, symbol: Symbol), &(name: string, symbol: Symbol)) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : (name: string, symbol: Symbol) = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_362) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_362))[0]
                    it_index : i64 = @var(@id((it, it_index)_362))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[(name: string, symbol: Symbol)]) -> ArrayIterator[(name: string, symbol: Symbol)] {
            return new ArrayIterator[(name: string, symbol: Symbol)] { array = self, index = 0 }
        }
    }
    // T = (type, ^AstDecl)
    impl(T: type) Array[^AstDecl] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^AstDecl] {
            s : Array[^AstDecl] = new Array[^AstDecl] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^AstDecl))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^AstDecl] {
            s : Array[^AstDecl] = new Array[^AstDecl] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^AstDecl))))
            return s
        }
        
        reserve(self: &Array[^AstDecl], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(^AstDecl))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[^AstDecl]) -> i64 {
            return length
        }
        
        count(self: &Array[^AstDecl]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[^AstDecl]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[^AstDecl]) -> ^^AstDecl {
            return data
        }
        
        clear(self: &Array[^AstDecl]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_372) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_372))[0]
                    it_index : i64 = @var(@id((it, it_index)_372))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[^AstDecl], val: ^AstDecl) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[^AstDecl], values: []^AstDecl) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(^AstDecl) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[^AstDecl], val: ^AstDecl) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[^AstDecl]) -> ^AstDecl {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[^AstDecl]) -> &^AstDecl {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[^AstDecl], index: i64) -> Option[^AstDecl] {
            if ((index < 0) or (index >= length)) {
                return Option[^AstDecl].None
            } else {
                return Option[^AstDecl].Some(data[index])
            }
        }
        
        remove_at(self: &Array[^AstDecl], index: i64) -> ^AstDecl {
            @assert(((index >= 0) and (index < self.get_length())))
            result : ^AstDecl = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[^AstDecl], index: i64) -> &^AstDecl {
            return &data[index]
        }
        
        access(self: &Array[^AstDecl], index: i64) -> &^AstDecl #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[^AstDecl], from: i64, len: i64) -> []^AstDecl {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []^AstDecl = cast([]^AstDecl) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[^AstDecl]) -> []^AstDecl {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[^AstDecl], from: i64) -> []^AstDecl {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[^AstDecl], len: i64) -> []^AstDecl {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[^AstDecl], cmp: fn(&^AstDecl, &^AstDecl) -> i64) -> &Array[^AstDecl] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[^AstDecl], from: i64, to: i64, cmp: fn(&^AstDecl, &^AstDecl) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : ^AstDecl = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_375) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_375))[0]
                    it_index : i64 = @var(@id((it, it_index)_375))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[^AstDecl]) -> ArrayIterator[^AstDecl] {
            return new ArrayIterator[^AstDecl] { array = self, index = 0 }
        }
    }
    // T = (type, ^AstConstDecl)
    impl(T: type) Array[^AstConstDecl] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^AstConstDecl] {
            s : Array[^AstConstDecl] = new Array[^AstConstDecl] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^AstConstDecl))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^AstConstDecl] {
            s : Array[^AstConstDecl] = new Array[^AstConstDecl] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^AstConstDecl))))
            return s
        }
        
        reserve(self: &Array[^AstConstDecl], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(^AstConstDecl))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[^AstConstDecl]) -> i64 {
            return length
        }
        
        count(self: &Array[^AstConstDecl]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[^AstConstDecl]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[^AstConstDecl]) -> ^^AstConstDecl {
            return data
        }
        
        clear(self: &Array[^AstConstDecl]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_381) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_381))[0]
                    it_index : i64 = @var(@id((it, it_index)_381))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[^AstConstDecl], val: ^AstConstDecl) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[^AstConstDecl], values: []^AstConstDecl) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(^AstConstDecl) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[^AstConstDecl], val: ^AstConstDecl) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[^AstConstDecl]) -> ^AstConstDecl {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[^AstConstDecl]) -> &^AstConstDecl {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[^AstConstDecl], index: i64) -> Option[^AstConstDecl] {
            if ((index < 0) or (index >= length)) {
                return Option[^AstConstDecl].None
            } else {
                return Option[^AstConstDecl].Some(data[index])
            }
        }
        
        remove_at(self: &Array[^AstConstDecl], index: i64) -> ^AstConstDecl {
            @assert(((index >= 0) and (index < self.get_length())))
            result : ^AstConstDecl = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[^AstConstDecl], index: i64) -> &^AstConstDecl {
            return &data[index]
        }
        
        access(self: &Array[^AstConstDecl], index: i64) -> &^AstConstDecl #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[^AstConstDecl], from: i64, len: i64) -> []^AstConstDecl {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []^AstConstDecl = cast([]^AstConstDecl) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[^AstConstDecl]) -> []^AstConstDecl {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[^AstConstDecl], from: i64) -> []^AstConstDecl {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[^AstConstDecl], len: i64) -> []^AstConstDecl {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[^AstConstDecl], cmp: fn(&^AstConstDecl, &^AstConstDecl) -> i64) -> &Array[^AstConstDecl] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[^AstConstDecl], from: i64, to: i64, cmp: fn(&^AstConstDecl, &^AstConstDecl) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : ^AstConstDecl = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_384) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_384))[0]
                    it_index : i64 = @var(@id((it, it_index)_384))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[^AstConstDecl]) -> ArrayIterator[^AstConstDecl] {
            return new ArrayIterator[^AstConstDecl] { array = self, index = 0 }
        }
    }
    // T = (type, LineInfo)
    impl(T: type) Array[LineInfo] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[LineInfo] {
            s : Array[LineInfo] = new Array[LineInfo] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(LineInfo))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[LineInfo] {
            s : Array[LineInfo] = new Array[LineInfo] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(LineInfo))))
            return s
        }
        
        reserve(self: &Array[LineInfo], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(LineInfo))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[LineInfo]) -> i64 {
            return length
        }
        
        count(self: &Array[LineInfo]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[LineInfo]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[LineInfo]) -> ^LineInfo {
            return data
        }
        
        clear(self: &Array[LineInfo]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_396) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_396))[0]
                    it_index : i64 = @var(@id((it, it_index)_396))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[LineInfo], val: LineInfo) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[LineInfo], values: []LineInfo) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(LineInfo) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[LineInfo], val: LineInfo) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[LineInfo]) -> LineInfo {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[LineInfo]) -> &LineInfo {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[LineInfo], index: i64) -> Option[LineInfo] {
            if ((index < 0) or (index >= length)) {
                return Option[LineInfo].None
            } else {
                return Option[LineInfo].Some(data[index])
            }
        }
        
        remove_at(self: &Array[LineInfo], index: i64) -> LineInfo {
            @assert(((index >= 0) and (index < self.get_length())))
            result : LineInfo = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[LineInfo], index: i64) -> &LineInfo {
            return &data[index]
        }
        
        access(self: &Array[LineInfo], index: i64) -> &LineInfo #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[LineInfo], from: i64, len: i64) -> []LineInfo {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []LineInfo = cast([]LineInfo) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[LineInfo]) -> []LineInfo {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[LineInfo], from: i64) -> []LineInfo {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[LineInfo], len: i64) -> []LineInfo {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[LineInfo], cmp: fn(&LineInfo, &LineInfo) -> i64) -> &Array[LineInfo] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[LineInfo], from: i64, to: i64, cmp: fn(&LineInfo, &LineInfo) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : LineInfo = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_399) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_399))[0]
                    it_index : i64 = @var(@id((it, it_index)_399))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[LineInfo]) -> ArrayIterator[LineInfo] {
            return new ArrayIterator[LineInfo] { array = self, index = 0 }
        }
    }
    // T = (type, VariableInfo)
    impl(T: type) Array[VariableInfo] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[VariableInfo] {
            s : Array[VariableInfo] = new Array[VariableInfo] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(VariableInfo))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[VariableInfo] {
            s : Array[VariableInfo] = new Array[VariableInfo] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(VariableInfo))))
            return s
        }
        
        reserve(self: &Array[VariableInfo], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(VariableInfo))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[VariableInfo]) -> i64 {
            return length
        }
        
        count(self: &Array[VariableInfo]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[VariableInfo]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[VariableInfo]) -> ^VariableInfo {
            return data
        }
        
        clear(self: &Array[VariableInfo]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_403) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_403))[0]
                    it_index : i64 = @var(@id((it, it_index)_403))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[VariableInfo], val: VariableInfo) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[VariableInfo], values: []VariableInfo) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(VariableInfo) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[VariableInfo], val: VariableInfo) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[VariableInfo]) -> VariableInfo {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[VariableInfo]) -> &VariableInfo {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[VariableInfo], index: i64) -> Option[VariableInfo] {
            if ((index < 0) or (index >= length)) {
                return Option[VariableInfo].None
            } else {
                return Option[VariableInfo].Some(data[index])
            }
        }
        
        remove_at(self: &Array[VariableInfo], index: i64) -> VariableInfo {
            @assert(((index >= 0) and (index < self.get_length())))
            result : VariableInfo = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[VariableInfo], index: i64) -> &VariableInfo {
            return &data[index]
        }
        
        access(self: &Array[VariableInfo], index: i64) -> &VariableInfo #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[VariableInfo], from: i64, len: i64) -> []VariableInfo {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []VariableInfo = cast([]VariableInfo) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[VariableInfo]) -> []VariableInfo {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[VariableInfo], from: i64) -> []VariableInfo {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[VariableInfo], len: i64) -> []VariableInfo {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[VariableInfo], cmp: fn(&VariableInfo, &VariableInfo) -> i64) -> &Array[VariableInfo] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[VariableInfo], from: i64, to: i64, cmp: fn(&VariableInfo, &VariableInfo) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : VariableInfo = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_406) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_406))[0]
                    it_index : i64 = @var(@id((it, it_index)_406))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[VariableInfo]) -> ArrayIterator[VariableInfo] {
            return new ArrayIterator[VariableInfo] { array = self, index = 0 }
        }
    }
    // T = (type, u64)
    impl(T: type) Array[u64] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[u64] {
            s : Array[u64] = new Array[u64] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(u64))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[u64] {
            s : Array[u64] = new Array[u64] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(u64))))
            return s
        }
        
        reserve(self: &Array[u64], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(u64))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[u64]) -> i64 {
            return length
        }
        
        count(self: &Array[u64]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[u64]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[u64]) -> ^u64 {
            return data
        }
        
        clear(self: &Array[u64]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_410) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_410))[0]
                    it_index : i64 = @var(@id((it, it_index)_410))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[u64], val: u64) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[u64], values: []u64) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(u64) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[u64], val: u64) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[u64]) -> u64 {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[u64]) -> &u64 {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[u64], index: i64) -> Option[u64] {
            if ((index < 0) or (index >= length)) {
                return Option[u64].None
            } else {
                return Option[u64].Some(data[index])
            }
        }
        
        remove_at(self: &Array[u64], index: i64) -> u64 {
            @assert(((index >= 0) and (index < self.get_length())))
            result : u64 = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[u64], index: i64) -> &u64 {
            return &data[index]
        }
        
        access(self: &Array[u64], index: i64) -> &u64 #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[u64], from: i64, len: i64) -> []u64 {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []u64 = cast([]u64) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[u64]) -> []u64 {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[u64], from: i64) -> []u64 {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[u64], len: i64) -> []u64 {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[u64], cmp: fn(&u64, &u64) -> i64) -> &Array[u64] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[u64], from: i64, to: i64, cmp: fn(&u64, &u64) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : u64 = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_413) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_413))[0]
                    it_index : i64 = @var(@id((it, it_index)_413))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[u64]) -> ArrayIterator[u64] {
            return new ArrayIterator[u64] { array = self, index = 0 }
        }
    }
    // T = (type, i64)
    impl(T: type) Array[i64] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[i64] {
            s : Array[i64] = new Array[i64] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(i64))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[i64] {
            s : Array[i64] = new Array[i64] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(i64))))
            return s
        }
        
        reserve(self: &Array[i64], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(i64))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[i64]) -> i64 {
            return length
        }
        
        count(self: &Array[i64]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[i64]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[i64]) -> ^i64 {
            return data
        }
        
        clear(self: &Array[i64]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_420) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_420))[0]
                    it_index : i64 = @var(@id((it, it_index)_420))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[i64], val: i64) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[i64], values: []i64) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(i64) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[i64], val: i64) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[i64]) -> i64 {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[i64]) -> &i64 {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[i64], index: i64) -> Option[i64] {
            if ((index < 0) or (index >= length)) {
                return Option[i64].None
            } else {
                return Option[i64].Some(data[index])
            }
        }
        
        remove_at(self: &Array[i64], index: i64) -> i64 {
            @assert(((index >= 0) and (index < self.get_length())))
            result : i64 = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[i64], index: i64) -> &i64 {
            return &data[index]
        }
        
        access(self: &Array[i64], index: i64) -> &i64 #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[i64], from: i64, len: i64) -> []i64 {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []i64 = cast([]i64) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[i64]) -> []i64 {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[i64], from: i64) -> []i64 {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[i64], len: i64) -> []i64 {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[i64], cmp: fn(&i64, &i64) -> i64) -> &Array[i64] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[i64], from: i64, to: i64, cmp: fn(&i64, &i64) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : i64 = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_423) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_423))[0]
                    it_index : i64 = @var(@id((it, it_index)_423))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[i64]) -> ArrayIterator[i64] {
            return new ArrayIterator[i64] { array = self, index = 0 }
        }
    }
    // T = (type, String)
    impl(T: type) Array[String] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[String] {
            s : Array[String] = new Array[String] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(String))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[String] {
            s : Array[String] = new Array[String] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(String))))
            return s
        }
        
        reserve(self: &Array[String], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(String))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[String]) -> i64 {
            return length
        }
        
        count(self: &Array[String]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[String]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[String]) -> ^String {
            return data
        }
        
        clear(self: &Array[String]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_431) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_431))[0]
                    it_index : i64 = @var(@id((it, it_index)_431))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[String], val: String) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[String], values: []String) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(String) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[String], val: String) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[String]) -> String {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[String]) -> &String {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[String], index: i64) -> Option[String] {
            if ((index < 0) or (index >= length)) {
                return Option[String].None
            } else {
                return Option[String].Some(data[index])
            }
        }
        
        remove_at(self: &Array[String], index: i64) -> String {
            @assert(((index >= 0) and (index < self.get_length())))
            result : String = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[String], index: i64) -> &String {
            return &data[index]
        }
        
        access(self: &Array[String], index: i64) -> &String #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[String], from: i64, len: i64) -> []String {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []String = cast([]String) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[String]) -> []String {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[String], from: i64) -> []String {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[String], len: i64) -> []String {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[String], cmp: fn(&String, &String) -> i64) -> &Array[String] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[String], from: i64, to: i64, cmp: fn(&String, &String) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : String = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_434) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_434))[0]
                    it_index : i64 = @var(@id((it, it_index)_434))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
            @destruct(pivot)
        }
        
        iterator(self: &Array[String]) -> ArrayIterator[String] {
            return new ArrayIterator[String] { array = self, index = 0 }
        }
    }
    // T = (type, Bucket)
    impl(T: type) Array[Bucket] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[Bucket] {
            s : Array[Bucket] = new Array[Bucket] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(Bucket))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[Bucket] {
            s : Array[Bucket] = new Array[Bucket] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(Bucket))))
            return s
        }
        
        reserve(self: &Array[Bucket], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(Bucket))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[Bucket]) -> i64 {
            return length
        }
        
        count(self: &Array[Bucket]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[Bucket]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[Bucket]) -> ^Bucket {
            return data
        }
        
        clear(self: &Array[Bucket]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_441) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_441))[0]
                    it_index : i64 = @var(@id((it, it_index)_441))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[Bucket], val: Bucket) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[Bucket], values: []Bucket) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(Bucket) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[Bucket], val: Bucket) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[Bucket]) -> Bucket {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[Bucket]) -> &Bucket {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[Bucket], index: i64) -> Option[Bucket] {
            if ((index < 0) or (index >= length)) {
                return Option[Bucket].None
            } else {
                return Option[Bucket].Some(data[index])
            }
        }
        
        remove_at(self: &Array[Bucket], index: i64) -> Bucket {
            @assert(((index >= 0) and (index < self.get_length())))
            result : Bucket = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[Bucket], index: i64) -> &Bucket {
            return &data[index]
        }
        
        access(self: &Array[Bucket], index: i64) -> &Bucket #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[Bucket], from: i64, len: i64) -> []Bucket {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []Bucket = cast([]Bucket) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[Bucket]) -> []Bucket {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[Bucket], from: i64) -> []Bucket {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[Bucket], len: i64) -> []Bucket {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[Bucket], cmp: fn(&Bucket, &Bucket) -> i64) -> &Array[Bucket] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[Bucket], from: i64, to: i64, cmp: fn(&Bucket, &Bucket) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : Bucket = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_444) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_444))[0]
                    it_index : i64 = @var(@id((it, it_index)_444))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[Bucket]) -> ArrayIterator[Bucket] {
            return new ArrayIterator[Bucket] { array = self, index = 0 }
        }
    }
    // T = (type, (name: string, mem: ^TypeInfoStructMember, set: bool))
    impl(T: type) Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] {
            s : Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] = new Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof((name: string, mem: ^TypeInfoStructMember, set: bool)))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] {
            s : Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] = new Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof((name: string, mem: ^TypeInfoStructMember, set: bool)))))
            return s
        }
        
        reserve(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof((name: string, mem: ^TypeInfoStructMember, set: bool)))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)]) -> i64 {
            return length
        }
        
        count(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)]) -> ^(name: string, mem: ^TypeInfoStructMember, set: bool) {
            return data
        }
        
        clear(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_461) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_461))[0]
                    it_index : i64 = @var(@id((it, it_index)_461))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], val: (name: string, mem: ^TypeInfoStructMember, set: bool)) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], values: [](name: string, mem: ^TypeInfoStructMember, set: bool)) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof((name: string, mem: ^TypeInfoStructMember, set: bool)) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], val: (name: string, mem: ^TypeInfoStructMember, set: bool)) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)]) -> (name: string, mem: ^TypeInfoStructMember, set: bool) {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)]) -> &(name: string, mem: ^TypeInfoStructMember, set: bool) {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], index: i64) -> Option[(name: string, mem: ^TypeInfoStructMember, set: bool)] {
            if ((index < 0) or (index >= length)) {
                return Option[(name: string, mem: ^TypeInfoStructMember, set: bool)].None
            } else {
                return Option[(name: string, mem: ^TypeInfoStructMember, set: bool)].Some(data[index])
            }
        }
        
        remove_at(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], index: i64) -> (name: string, mem: ^TypeInfoStructMember, set: bool) {
            @assert(((index >= 0) and (index < self.get_length())))
            result : (name: string, mem: ^TypeInfoStructMember, set: bool) = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], index: i64) -> &(name: string, mem: ^TypeInfoStructMember, set: bool) {
            return &data[index]
        }
        
        access(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], index: i64) -> &(name: string, mem: ^TypeInfoStructMember, set: bool) #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], from: i64, len: i64) -> [](name: string, mem: ^TypeInfoStructMember, set: bool) {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : [](name: string, mem: ^TypeInfoStructMember, set: bool) = cast([](name: string, mem: ^TypeInfoStructMember, set: bool)) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)]) -> [](name: string, mem: ^TypeInfoStructMember, set: bool) {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], from: i64) -> [](name: string, mem: ^TypeInfoStructMember, set: bool) {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], len: i64) -> [](name: string, mem: ^TypeInfoStructMember, set: bool) {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], cmp: fn(&(name: string, mem: ^TypeInfoStructMember, set: bool), &(name: string, mem: ^TypeInfoStructMember, set: bool)) -> i64) -> &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], from: i64, to: i64, cmp: fn(&(name: string, mem: ^TypeInfoStructMember, set: bool), &(name: string, mem: ^TypeInfoStructMember, set: bool)) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : (name: string, mem: ^TypeInfoStructMember, set: bool) = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_464) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_464))[0]
                    it_index : i64 = @var(@id((it, it_index)_464))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)]) -> ArrayIterator[(name: string, mem: ^TypeInfoStructMember, set: bool)] {
            return new ArrayIterator[(name: string, mem: ^TypeInfoStructMember, set: bool)] { array = self, index = 0 }
        }
    }
    // T = (type, string)
    impl(T: type) Array[string] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[string] {
            s : Array[string] = new Array[string] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(string))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[string] {
            s : Array[string] = new Array[string] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(string))))
            return s
        }
        
        reserve(self: &Array[string], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(string))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[string]) -> i64 {
            return length
        }
        
        count(self: &Array[string]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[string]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[string]) -> ^string {
            return data
        }
        
        clear(self: &Array[string]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_472) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_472))[0]
                    it_index : i64 = @var(@id((it, it_index)_472))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[string], val: string) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[string], values: []string) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(string) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[string], val: string) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[string]) -> string {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[string]) -> &string {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[string], index: i64) -> Option[string] {
            if ((index < 0) or (index >= length)) {
                return Option[string].None
            } else {
                return Option[string].Some(data[index])
            }
        }
        
        remove_at(self: &Array[string], index: i64) -> string {
            @assert(((index >= 0) and (index < self.get_length())))
            result : string = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[string], index: i64) -> &string {
            return &data[index]
        }
        
        access(self: &Array[string], index: i64) -> &string #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[string], from: i64, len: i64) -> []string {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []string = cast([]string) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[string]) -> []string {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[string], from: i64) -> []string {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[string], len: i64) -> []string {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[string], cmp: fn(&string, &string) -> i64) -> &Array[string] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[string], from: i64, to: i64, cmp: fn(&string, &string) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : string = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_475) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_475))[0]
                    it_index : i64 = @var(@id((it, it_index)_475))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[string]) -> ArrayIterator[string] {
            return new ArrayIterator[string] { array = self, index = 0 }
        }
    }
    // T = (type, u16)
    impl(T: type) Array[u16] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[u16] {
            s : Array[u16] = new Array[u16] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(u16))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[u16] {
            s : Array[u16] = new Array[u16] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(u16))))
            return s
        }
        
        reserve(self: &Array[u16], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(u16))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[u16]) -> i64 {
            return length
        }
        
        count(self: &Array[u16]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[u16]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[u16]) -> ^u16 {
            return data
        }
        
        clear(self: &Array[u16]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_508) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_508))[0]
                    it_index : i64 = @var(@id((it, it_index)_508))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[u16], val: u16) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[u16], values: []u16) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(u16) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[u16], val: u16) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[u16]) -> u16 {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[u16]) -> &u16 {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[u16], index: i64) -> Option[u16] {
            if ((index < 0) or (index >= length)) {
                return Option[u16].None
            } else {
                return Option[u16].Some(data[index])
            }
        }
        
        remove_at(self: &Array[u16], index: i64) -> u16 {
            @assert(((index >= 0) and (index < self.get_length())))
            result : u16 = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[u16], index: i64) -> &u16 {
            return &data[index]
        }
        
        access(self: &Array[u16], index: i64) -> &u16 #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[u16], from: i64, len: i64) -> []u16 {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []u16 = cast([]u16) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[u16]) -> []u16 {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[u16], from: i64) -> []u16 {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[u16], len: i64) -> []u16 {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[u16], cmp: fn(&u16, &u16) -> i64) -> &Array[u16] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[u16], from: i64, to: i64, cmp: fn(&u16, &u16) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : u16 = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_511) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_511))[0]
                    it_index : i64 = @var(@id((it, it_index)_511))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[u16]) -> ArrayIterator[u16] {
            return new ArrayIterator[u16] { array = self, index = 0 }
        }
    }
    // T = (type, u8)
    impl(T: type) Array[u8] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[u8] {
            s : Array[u8] = new Array[u8] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(u8))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[u8] {
            s : Array[u8] = new Array[u8] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(u8))))
            return s
        }
        
        reserve(self: &Array[u8], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(u8))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[u8]) -> i64 {
            return length
        }
        
        count(self: &Array[u8]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[u8]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[u8]) -> ^u8 {
            return data
        }
        
        clear(self: &Array[u8]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_518) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_518))[0]
                    it_index : i64 = @var(@id((it, it_index)_518))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[u8], val: u8) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[u8], values: []u8) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(u8) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[u8], val: u8) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[u8]) -> u8 {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[u8]) -> &u8 {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[u8], index: i64) -> Option[u8] {
            if ((index < 0) or (index >= length)) {
                return Option[u8].None
            } else {
                return Option[u8].Some(data[index])
            }
        }
        
        remove_at(self: &Array[u8], index: i64) -> u8 {
            @assert(((index >= 0) and (index < self.get_length())))
            result : u8 = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[u8], index: i64) -> &u8 {
            return &data[index]
        }
        
        access(self: &Array[u8], index: i64) -> &u8 #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[u8], from: i64, len: i64) -> []u8 {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []u8 = cast([]u8) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[u8]) -> []u8 {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[u8], from: i64) -> []u8 {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[u8], len: i64) -> []u8 {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[u8], cmp: fn(&u8, &u8) -> i64) -> &Array[u8] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[u8], from: i64, to: i64, cmp: fn(&u8, &u8) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : u8 = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_521) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_521))[0]
                    it_index : i64 = @var(@id((it, it_index)_521))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[u8]) -> ArrayIterator[u8] {
            return new ArrayIterator[u8] { array = self, index = 0 }
        }
    }
    // T = (type, ^AstArgument)
    impl(T: type) Array[^AstArgument] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^AstArgument] {
            s : Array[^AstArgument] = new Array[^AstArgument] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^AstArgument))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^AstArgument] {
            s : Array[^AstArgument] = new Array[^AstArgument] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^AstArgument))))
            return s
        }
        
        reserve(self: &Array[^AstArgument], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(^AstArgument))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[^AstArgument]) -> i64 {
            return length
        }
        
        count(self: &Array[^AstArgument]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[^AstArgument]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[^AstArgument]) -> ^^AstArgument {
            return data
        }
        
        clear(self: &Array[^AstArgument]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_528) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_528))[0]
                    it_index : i64 = @var(@id((it, it_index)_528))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[^AstArgument], val: ^AstArgument) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[^AstArgument], values: []^AstArgument) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(^AstArgument) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[^AstArgument], val: ^AstArgument) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[^AstArgument]) -> ^AstArgument {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[^AstArgument]) -> &^AstArgument {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[^AstArgument], index: i64) -> Option[^AstArgument] {
            if ((index < 0) or (index >= length)) {
                return Option[^AstArgument].None
            } else {
                return Option[^AstArgument].Some(data[index])
            }
        }
        
        remove_at(self: &Array[^AstArgument], index: i64) -> ^AstArgument {
            @assert(((index >= 0) and (index < self.get_length())))
            result : ^AstArgument = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[^AstArgument], index: i64) -> &^AstArgument {
            return &data[index]
        }
        
        access(self: &Array[^AstArgument], index: i64) -> &^AstArgument #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[^AstArgument], from: i64, len: i64) -> []^AstArgument {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []^AstArgument = cast([]^AstArgument) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[^AstArgument]) -> []^AstArgument {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[^AstArgument], from: i64) -> []^AstArgument {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[^AstArgument], len: i64) -> []^AstArgument {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[^AstArgument], cmp: fn(&^AstArgument, &^AstArgument) -> i64) -> &Array[^AstArgument] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[^AstArgument], from: i64, to: i64, cmp: fn(&^AstArgument, &^AstArgument) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : ^AstArgument = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_531) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_531))[0]
                    it_index : i64 = @var(@id((it, it_index)_531))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[^AstArgument]) -> ArrayIterator[^AstArgument] {
            return new ArrayIterator[^AstArgument] { array = self, index = 0 }
        }
    }
    // T = (type, ^AstMatchCase)
    impl(T: type) Array[^AstMatchCase] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^AstMatchCase] {
            s : Array[^AstMatchCase] = new Array[^AstMatchCase] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^AstMatchCase))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^AstMatchCase] {
            s : Array[^AstMatchCase] = new Array[^AstMatchCase] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^AstMatchCase))))
            return s
        }
        
        reserve(self: &Array[^AstMatchCase], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(^AstMatchCase))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[^AstMatchCase]) -> i64 {
            return length
        }
        
        count(self: &Array[^AstMatchCase]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[^AstMatchCase]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[^AstMatchCase]) -> ^^AstMatchCase {
            return data
        }
        
        clear(self: &Array[^AstMatchCase]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_537) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_537))[0]
                    it_index : i64 = @var(@id((it, it_index)_537))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[^AstMatchCase], val: ^AstMatchCase) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[^AstMatchCase], values: []^AstMatchCase) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(^AstMatchCase) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[^AstMatchCase], val: ^AstMatchCase) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[^AstMatchCase]) -> ^AstMatchCase {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[^AstMatchCase]) -> &^AstMatchCase {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[^AstMatchCase], index: i64) -> Option[^AstMatchCase] {
            if ((index < 0) or (index >= length)) {
                return Option[^AstMatchCase].None
            } else {
                return Option[^AstMatchCase].Some(data[index])
            }
        }
        
        remove_at(self: &Array[^AstMatchCase], index: i64) -> ^AstMatchCase {
            @assert(((index >= 0) and (index < self.get_length())))
            result : ^AstMatchCase = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[^AstMatchCase], index: i64) -> &^AstMatchCase {
            return &data[index]
        }
        
        access(self: &Array[^AstMatchCase], index: i64) -> &^AstMatchCase #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[^AstMatchCase], from: i64, len: i64) -> []^AstMatchCase {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []^AstMatchCase = cast([]^AstMatchCase) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[^AstMatchCase]) -> []^AstMatchCase {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[^AstMatchCase], from: i64) -> []^AstMatchCase {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[^AstMatchCase], len: i64) -> []^AstMatchCase {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[^AstMatchCase], cmp: fn(&^AstMatchCase, &^AstMatchCase) -> i64) -> &Array[^AstMatchCase] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[^AstMatchCase], from: i64, to: i64, cmp: fn(&^AstMatchCase, &^AstMatchCase) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : ^AstMatchCase = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_540) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_540))[0]
                    it_index : i64 = @var(@id((it, it_index)_540))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[^AstMatchCase]) -> ArrayIterator[^AstMatchCase] {
            return new ArrayIterator[^AstMatchCase] { array = self, index = 0 }
        }
    }
    // T = (type, Thread)
    impl(T: type) Array[Thread] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[Thread] {
            s : Array[Thread] = new Array[Thread] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(Thread))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[Thread] {
            s : Array[Thread] = new Array[Thread] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(Thread))))
            return s
        }
        
        reserve(self: &Array[Thread], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(Thread))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[Thread]) -> i64 {
            return length
        }
        
        count(self: &Array[Thread]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[Thread]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[Thread]) -> ^Thread {
            return data
        }
        
        clear(self: &Array[Thread]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_550) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_550))[0]
                    it_index : i64 = @var(@id((it, it_index)_550))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[Thread], val: Thread) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[Thread], values: []Thread) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(Thread) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[Thread], val: Thread) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[Thread]) -> Thread {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[Thread]) -> &Thread {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[Thread], index: i64) -> Option[Thread] {
            if ((index < 0) or (index >= length)) {
                return Option[Thread].None
            } else {
                return Option[Thread].Some(data[index])
            }
        }
        
        remove_at(self: &Array[Thread], index: i64) -> Thread {
            @assert(((index >= 0) and (index < self.get_length())))
            result : Thread = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[Thread], index: i64) -> &Thread {
            return &data[index]
        }
        
        access(self: &Array[Thread], index: i64) -> &Thread #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[Thread], from: i64, len: i64) -> []Thread {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []Thread = cast([]Thread) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[Thread]) -> []Thread {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[Thread], from: i64) -> []Thread {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[Thread], len: i64) -> []Thread {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[Thread], cmp: fn(&Thread, &Thread) -> i64) -> &Array[Thread] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[Thread], from: i64, to: i64, cmp: fn(&Thread, &Thread) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : Thread = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_553) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_553))[0]
                    it_index : i64 = @var(@id((it, it_index)_553))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
            @destruct(pivot)
        }
        
        iterator(self: &Array[Thread]) -> ArrayIterator[Thread] {
            return new ArrayIterator[Thread] { array = self, index = 0 }
        }
    }
    // T = (type, ^AstImpl)
    impl(T: type) Array[^AstImpl] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^AstImpl] {
            s : Array[^AstImpl] = new Array[^AstImpl] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^AstImpl))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^AstImpl] {
            s : Array[^AstImpl] = new Array[^AstImpl] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^AstImpl))))
            return s
        }
        
        reserve(self: &Array[^AstImpl], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(^AstImpl))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[^AstImpl]) -> i64 {
            return length
        }
        
        count(self: &Array[^AstImpl]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[^AstImpl]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[^AstImpl]) -> ^^AstImpl {
            return data
        }
        
        clear(self: &Array[^AstImpl]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_574) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_574))[0]
                    it_index : i64 = @var(@id((it, it_index)_574))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[^AstImpl], val: ^AstImpl) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[^AstImpl], values: []^AstImpl) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(^AstImpl) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[^AstImpl], val: ^AstImpl) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[^AstImpl]) -> ^AstImpl {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[^AstImpl]) -> &^AstImpl {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[^AstImpl], index: i64) -> Option[^AstImpl] {
            if ((index < 0) or (index >= length)) {
                return Option[^AstImpl].None
            } else {
                return Option[^AstImpl].Some(data[index])
            }
        }
        
        remove_at(self: &Array[^AstImpl], index: i64) -> ^AstImpl {
            @assert(((index >= 0) and (index < self.get_length())))
            result : ^AstImpl = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[^AstImpl], index: i64) -> &^AstImpl {
            return &data[index]
        }
        
        access(self: &Array[^AstImpl], index: i64) -> &^AstImpl #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[^AstImpl], from: i64, len: i64) -> []^AstImpl {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []^AstImpl = cast([]^AstImpl) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[^AstImpl]) -> []^AstImpl {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[^AstImpl], from: i64) -> []^AstImpl {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[^AstImpl], len: i64) -> []^AstImpl {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[^AstImpl], cmp: fn(&^AstImpl, &^AstImpl) -> i64) -> &Array[^AstImpl] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[^AstImpl], from: i64, to: i64, cmp: fn(&^AstImpl, &^AstImpl) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : ^AstImpl = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_577) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_577))[0]
                    it_index : i64 = @var(@id((it, it_index)_577))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[^AstImpl]) -> ArrayIterator[^AstImpl] {
            return new ArrayIterator[^AstImpl] { array = self, index = 0 }
        }
    }
    // T = (type, ^CompileStructMemberJob)
    impl(T: type) Array[^CompileStructMemberJob] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^CompileStructMemberJob] {
            s : Array[^CompileStructMemberJob] = new Array[^CompileStructMemberJob] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^CompileStructMemberJob))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[^CompileStructMemberJob] {
            s : Array[^CompileStructMemberJob] = new Array[^CompileStructMemberJob] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(^CompileStructMemberJob))))
            return s
        }
        
        reserve(self: &Array[^CompileStructMemberJob], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(^CompileStructMemberJob))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[^CompileStructMemberJob]) -> i64 {
            return length
        }
        
        count(self: &Array[^CompileStructMemberJob]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[^CompileStructMemberJob]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[^CompileStructMemberJob]) -> ^^CompileStructMemberJob {
            return data
        }
        
        clear(self: &Array[^CompileStructMemberJob]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_585) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_585))[0]
                    it_index : i64 = @var(@id((it, it_index)_585))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[^CompileStructMemberJob], val: ^CompileStructMemberJob) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[^CompileStructMemberJob], values: []^CompileStructMemberJob) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(^CompileStructMemberJob) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[^CompileStructMemberJob], val: ^CompileStructMemberJob) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[^CompileStructMemberJob]) -> ^CompileStructMemberJob {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[^CompileStructMemberJob]) -> &^CompileStructMemberJob {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[^CompileStructMemberJob], index: i64) -> Option[^CompileStructMemberJob] {
            if ((index < 0) or (index >= length)) {
                return Option[^CompileStructMemberJob].None
            } else {
                return Option[^CompileStructMemberJob].Some(data[index])
            }
        }
        
        remove_at(self: &Array[^CompileStructMemberJob], index: i64) -> ^CompileStructMemberJob {
            @assert(((index >= 0) and (index < self.get_length())))
            result : ^CompileStructMemberJob = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[^CompileStructMemberJob], index: i64) -> &^CompileStructMemberJob {
            return &data[index]
        }
        
        access(self: &Array[^CompileStructMemberJob], index: i64) -> &^CompileStructMemberJob #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[^CompileStructMemberJob], from: i64, len: i64) -> []^CompileStructMemberJob {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []^CompileStructMemberJob = cast([]^CompileStructMemberJob) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[^CompileStructMemberJob]) -> []^CompileStructMemberJob {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[^CompileStructMemberJob], from: i64) -> []^CompileStructMemberJob {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[^CompileStructMemberJob], len: i64) -> []^CompileStructMemberJob {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[^CompileStructMemberJob], cmp: fn(&^CompileStructMemberJob, &^CompileStructMemberJob) -> i64) -> &Array[^CompileStructMemberJob] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[^CompileStructMemberJob], from: i64, to: i64, cmp: fn(&^CompileStructMemberJob, &^CompileStructMemberJob) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : ^CompileStructMemberJob = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_588) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_588))[0]
                    it_index : i64 = @var(@id((it, it_index)_588))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[^CompileStructMemberJob]) -> ArrayIterator[^CompileStructMemberJob] {
            return new ArrayIterator[^CompileStructMemberJob] { array = self, index = 0 }
        }
    }
    // T = (type, BumpBucket)
    impl(T: type) Array[BumpBucket] {
        create(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[BumpBucket] {
            s : Array[BumpBucket] = new Array[BumpBucket] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(BumpBucket))))
            return s
        }
        
        new(initial_capacity: i64 = 10, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Array[BumpBucket] {
            s : Array[BumpBucket] = new Array[BumpBucket] { data = null, capacity = 0, length = 0, allocator = allocator }
            &s.reserve(initial_capacity)
            (C).memset(cast (&s.get_raw()), 0, cast(u64) ((&s.get_capacity() * @sizeof(BumpBucket))))
            return s
        }
        
        reserve(self: &Array[BumpBucket], size: i64) {
            @assert((length <= size))
            if (capacity >= size) {
                return
            } else {}
            capacity = size
            data = realloc_raw(data, cast (size), allocator)
            if (size > length) {
                (C).memset(cast (^data[length]), 0, cast(u64) (((size - length) * @sizeof(BumpBucket))))
            } else {}
            if (length > capacity) {
                length = capacity
            } else {}
        }
        
        get_length(self: &Array[BumpBucket]) -> i64 {
            return length
        }
        
        count(self: &Array[BumpBucket]) -> i64 {
            return length
        }
        
        get_capacity(self: &Array[BumpBucket]) -> i64 {
            return capacity
        }
        
        get_raw(self: &Array[BumpBucket]) -> ^BumpBucket {
            return data
        }
        
        clear(self: &Array[BumpBucket]) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_599) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_599))[0]
                    it_index : i64 = @var(@id((it, it_index)_599))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = 0
        }
        
        add(self: &Array[BumpBucket], val: BumpBucket) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        add_slice(self: &Array[BumpBucket], values: []BumpBucket) {
            required_size : i64 = (self.count() + (values).length)
            cap : i64 = self.get_capacity()
            loop {
                if !(cap <= required_size) then break else {}
                cap = (cap * 2)
            }
            self.reserve(cap)
            (C).memcpy(cast(^void) (^data[length]), cast(^void) ((values).data), cast ((@sizeof(BumpBucket) * (values).length)))
            length = (length + (values).length)
        }
        
        push(self: &Array[BumpBucket], val: BumpBucket) {
            if (self.get_capacity() <= self.get_length()) {
                self.reserve((self.get_capacity() * 2))
            } else {}
            data[length] = val
            length = (length + 1)
        }
        
        pop(self: &Array[BumpBucket]) -> BumpBucket {
            @assert((length > 0))
            length = (length - 1)
            return data[length]
        }
        
        peek_last(self: &Array[BumpBucket]) -> &BumpBucket {
            @assert((length > 0), "Array is empty")
            return &data[(length - 1)]
        }
        
        get(self: &Array[BumpBucket], index: i64) -> Option[BumpBucket] {
            if ((index < 0) or (index >= length)) {
                return Option[BumpBucket].None
            } else {
                return Option[BumpBucket].Some(data[index])
            }
        }
        
        remove_at(self: &Array[BumpBucket], index: i64) -> BumpBucket {
            @assert(((index >= 0) and (index < self.get_length())))
            result : BumpBucket = data[length]
            length = (length - 1)
            {
                i : i64 = index
                loop {
                    if !(i < length) then break else {}
                    defer i = (i + 1)
                    data[i] = data[(i + 1)]
                    i = (i + 1)
                }
            }
            return result
        }
        
        access_unchecked(self: &Array[BumpBucket], index: i64) -> &BumpBucket {
            return &data[index]
        }
        
        access(self: &Array[BumpBucket], index: i64) -> &BumpBucket #operator("[]") {
            if !((index >= 0) and (index < length)) {
                (C).printf("%lld`n", index)
            } else {}
            @assert(((index >= 0) and (index < length)), "Index was out of range")
            return &data[index]
        }
        
        sliceFL(self: &Array[BumpBucket], from: i64, len: i64) -> []BumpBucket {
            @assert((((from >= 0) and (len >= 0)) and ((from + len) <= length)), "Invalid range")
            slice : []BumpBucket = cast([]BumpBucket) (^data[from])
            (slice).length = len
            return slice
        }
        
        slice(self: &Array[BumpBucket]) -> []BumpBucket {
            return self.sliceFL(0, length)
        }
        
        sliceF(self: &Array[BumpBucket], from: i64) -> []BumpBucket {
            return self.sliceFL(from, (length - from))
        }
        
        sliceL(self: &Array[BumpBucket], len: i64) -> []BumpBucket {
            return self.sliceFL(0, len)
        }
        
        sort(self: &Array[BumpBucket], cmp: fn(&BumpBucket, &BumpBucket) -> i64) -> &Array[BumpBucket] {
            self.quick_sort(0, (length - 1), cmp)
            return self
        }
        
        quick_sort(self: &Array[BumpBucket], from: i64, to: i64, cmp: fn(&BumpBucket, &BumpBucket) -> i64) {
            if (from >= to) {
                return
            } else {}
            idx : i64 = from
            pivot : BumpBucket = data[to]
            #macro {
                local r : Range[i64] = new Range[i64] { start = from, end = to }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_602) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_602))[0]
                    it_index : i64 = @var(@id((it, it_index)_602))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (cmp(&data[i], &pivot) > 0) {
                                    // (data[idx], data[i]) = (data[i], data[idx])
                                        data[idx] = data[i]
                                        data[i] = data[idx]
                                    idx = (idx + 1)
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            // (data[idx], data[to]) = (data[to], data[idx])
                data[idx] = data[to]
                data[to] = data[idx]
            self.quick_sort(from, (idx - 1), cmp)
            self.quick_sort((idx + 1), to, cmp)
        }
        
        iterator(self: &Array[BumpBucket]) -> ArrayIterator[BumpBucket] {
            return new ArrayIterator[BumpBucket] { array = self, index = 0 }
        }
    }


impl(T: type) Cheez.Types.Abstract.GenericStructType if @is_default_constructable(T) {
    
}
// Polymorphic instances for impl(T: type) Cheez.Types.Abstract.GenericStructType if @is_default_constructable(T)
    // T = (type, ^AstNode)
    impl(T: type) Array[^AstNode] {
        resize(self: &Array[^AstNode], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_301) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_301))[0]
                    it_index : i64 = @var(@id((it, it_index)_301))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, ^FiberContext)
    impl(T: type) Array[^FiberContext] {
        resize(self: &Array[^FiberContext], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_342) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_342))[0]
                    it_index : i64 = @var(@id((it, it_index)_342))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, ^AstDecl)
    impl(T: type) Array[^AstDecl] {
        resize(self: &Array[^AstDecl], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_377) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_377))[0]
                    it_index : i64 = @var(@id((it, it_index)_377))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, ^AstConstDecl)
    impl(T: type) Array[^AstConstDecl] {
        resize(self: &Array[^AstConstDecl], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_386) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_386))[0]
                    it_index : i64 = @var(@id((it, it_index)_386))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, u64)
    impl(T: type) Array[u64] {
        resize(self: &Array[u64], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_415) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_415))[0]
                    it_index : i64 = @var(@id((it, it_index)_415))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, i64)
    impl(T: type) Array[i64] {
        resize(self: &Array[i64], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_425) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_425))[0]
                    it_index : i64 = @var(@id((it, it_index)_425))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, (name: string, mem: ^TypeInfoStructMember, set: bool))
    impl(T: type) Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] {
        resize(self: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_466) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_466))[0]
                    it_index : i64 = @var(@id((it, it_index)_466))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, string)
    impl(T: type) Array[string] {
        resize(self: &Array[string], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_477) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_477))[0]
                    it_index : i64 = @var(@id((it, it_index)_477))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, u16)
    impl(T: type) Array[u16] {
        resize(self: &Array[u16], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_513) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_513))[0]
                    it_index : i64 = @var(@id((it, it_index)_513))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, u8)
    impl(T: type) Array[u8] {
        resize(self: &Array[u8], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_523) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_523))[0]
                    it_index : i64 = @var(@id((it, it_index)_523))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, ^AstArgument)
    impl(T: type) Array[^AstArgument] {
        resize(self: &Array[^AstArgument], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_533) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_533))[0]
                    it_index : i64 = @var(@id((it, it_index)_533))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, ^AstMatchCase)
    impl(T: type) Array[^AstMatchCase] {
        resize(self: &Array[^AstMatchCase], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_542) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_542))[0]
                    it_index : i64 = @var(@id((it, it_index)_542))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, ^AstImpl)
    impl(T: type) Array[^AstImpl] {
        resize(self: &Array[^AstImpl], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_579) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_579))[0]
                    it_index : i64 = @var(@id((it, it_index)_579))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }
    // T = (type, ^CompileStructMemberJob)
    impl(T: type) Array[^CompileStructMemberJob] {
        resize(self: &Array[^CompileStructMemberJob], size: i64) {
            if (capacity < size) {
                self.reserve(size)
            } else {}
            #macro {
                local r : Range[i64] = new Range[i64] { start = size, end = length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_590) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_590))[0]
                    it_index : i64 = @var(@id((it, it_index)_590))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            (Memory).drop(data[it])
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            length = size
        }
    }


ArrayIterator :: struct(T: type) {
    array : 
    index : 
}
// Polymorphic instances for struct(T: type)
    // T = ^AstNode
    struct { // size: 16, alignment: 8
        array : &Array[^AstNode]
        index : i64
    }
    // T = Rc[Workspace]
    struct { // size: 16, alignment: 8
        array : &Array[Rc[Workspace]]
        index : i64
    }
    // T = ^FiberContext
    struct { // size: 16, alignment: 8
        array : &Array[^FiberContext]
        index : i64
    }
    // T = (name: string, symbol: Symbol)
    struct { // size: 16, alignment: 8
        array : &Array[(name: string, symbol: Symbol)]
        index : i64
    }
    // T = ^AstDecl
    struct { // size: 16, alignment: 8
        array : &Array[^AstDecl]
        index : i64
    }
    // T = ^AstConstDecl
    struct { // size: 16, alignment: 8
        array : &Array[^AstConstDecl]
        index : i64
    }
    // T = LineInfo
    struct { // size: 16, alignment: 8
        array : &Array[LineInfo]
        index : i64
    }
    // T = VariableInfo
    struct { // size: 16, alignment: 8
        array : &Array[VariableInfo]
        index : i64
    }
    // T = u64
    struct { // size: 16, alignment: 8
        array : &Array[u64]
        index : i64
    }
    // T = i64
    struct { // size: 16, alignment: 8
        array : &Array[i64]
        index : i64
    }
    // T = String
    struct { // size: 16, alignment: 8
        array : &Array[String]
        index : i64
    }
    // T = Bucket
    struct { // size: 16, alignment: 8
        array : &Array[Bucket]
        index : i64
    }
    // T = (name: string, mem: ^TypeInfoStructMember, set: bool)
    struct { // size: 16, alignment: 8
        array : &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)]
        index : i64
    }
    // T = string
    struct { // size: 16, alignment: 8
        array : &Array[string]
        index : i64
    }
    // T = u16
    struct { // size: 16, alignment: 8
        array : &Array[u16]
        index : i64
    }
    // T = u8
    struct { // size: 16, alignment: 8
        array : &Array[u8]
        index : i64
    }
    // T = ^AstArgument
    struct { // size: 16, alignment: 8
        array : &Array[^AstArgument]
        index : i64
    }
    // T = ^AstMatchCase
    struct { // size: 16, alignment: 8
        array : &Array[^AstMatchCase]
        index : i64
    }
    // T = Thread
    struct { // size: 16, alignment: 8
        array : &Array[Thread]
        index : i64
    }
    // T = ^AstImpl
    struct { // size: 16, alignment: 8
        array : &Array[^AstImpl]
        index : i64
    }
    // T = ^CompileStructMemberJob
    struct { // size: 16, alignment: 8
        array : &Array[^CompileStructMemberJob]
        index : i64
    }
    // T = BumpBucket
    struct { // size: 16, alignment: 8
        array : &Array[BumpBucket]
        index : i64
    }


impl(F: type, T: type) Into[Cheez.Types.Abstract.GenericStructType] for Cheez.Types.Abstract.GenericStructType if F : Into[T], #notyet {
    
}
// Polymorphic instances for impl(F: type, T: type) Into[Cheez.Types.Abstract.GenericStructType] for Cheez.Types.Abstract.GenericStructType if F : Into[T], #notyet
    // F = (type, string), T = (type, String)
    impl(F: type, T: type) Into[Array[String]] for Array[string] {
        into(self: &Array[string]) -> Array[String] {
            result : Array[String] = (Array[String]).create(self.get_length(), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = self.get_length() }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_479) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_479))[0]
                    it_index : i64 = @var(@id((it, it_index)_479))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                &result.add((string).into(self.access_unchecked(it)))
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            return result
        }
    }


impl(F: type, T: type) From[Cheez.Types.Abstract.GenericStructType] for Cheez.Types.Abstract.GenericStructType if T : From[F], #notyet {
    
}

for_extension_array_T : (arr: &Array[$T], code: Code, reverse: bool = false, by_ref: bool = true) : for_extension_array_T(arr: &Array[$T], code: Code, reverse: bool, by_ref: bool) {
    {
        it_index :  = 0
        loop {
            if !(it_index < (arr).get_length()) then break
            defer it_index = 1
            if reverse {
                it_index_rev :  = (((arr).length - it_index) - 1)
                if by_ref {
                    it :  = arr[it_index_rev]
                } else {
                    it :  = *arr[it_index_rev]
                }
                @insert(code, link = [it_index_rev], _break = break, _continue = continue)
            } else {
                if by_ref {
                    it :  = arr[it_index]
                } else {
                    it :  = *arr[it_index]
                }
                @insert(code, _break = break, _continue = continue)
            }
        }
    }
}
// Polymorphic instances for for_extension_array_T(arr: &Array[$T], code: Code, reverse: bool, by_ref: bool)
    /* T = (type, (name: string, mem: ^TypeInfoStructMember, set: bool)) */
    /*  */
    for_extension_array_T(arr: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, string) */
    /*  */
    for_extension_array_T(arr: &Array[string], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, ^AstNode) */
    /*  */
    for_extension_array_T(arr: &Array[^AstNode], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, ^AstArgument) */
    /*  */
    for_extension_array_T(arr: &Array[^AstArgument], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, ^AstDecl) */
    /*  */
    for_extension_array_T(arr: &Array[^AstDecl], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, ^AstMatchCase) */
    /*  */
    for_extension_array_T(arr: &Array[^AstMatchCase], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, Bucket) */
    /*  */
    for_extension_array_T(arr: &Array[Bucket], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, (name: string, symbol: Symbol)) */
    /*  */
    for_extension_array_T(arr: &Array[(name: string, symbol: Symbol)], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, Thread) */
    /*  */
    for_extension_array_T(arr: &Array[Thread], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, ^FiberContext) */
    /*  */
    for_extension_array_T(arr: &Array[^FiberContext], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, Rc[Workspace]) */
    /*  */
    for_extension_array_T(arr: &Array[Rc[Workspace]], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, ^AstImpl) */
    /*  */
    for_extension_array_T(arr: &Array[^AstImpl], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, ^CompileStructMemberJob) */
    /*  */
    for_extension_array_T(arr: &Array[^CompileStructMemberJob], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, BumpBucket) */
    /*  */
    for_extension_array_T(arr: &Array[BumpBucket], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }
    /* T = (type, LineInfo) */
    /*  */
    for_extension_array_T(arr: &Array[LineInfo], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (arr).get_length()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((arr).length - it_index) - 1)
                    if by_ref {
                        it :  = arr[it_index_rev]
                    } else {
                        it :  = *arr[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = arr[it_index]
                    } else {
                        it :  = *arr[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }


impl(T: type) Into[Cheez.Types.Abstract.GenericStructType] for []$T if T : Clone {
    
}
// Polymorphic instances for impl(T: type) Into[Cheez.Types.Abstract.GenericStructType] for []$T if T : Clone
    // T = (type, string)
    impl(T: type) Into[Array[string]] for []string {
        into(self: &[]string) -> Array[string] {
            result : Array[string] = (Array[string]).create((*self).length, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : []string = get_range_full(*self, new RangeFull {  })
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &string = get_index(arr, it_index)
                            #link #anonymous {
                                v : &string = it
                                it_index : i64 = it_index
                                {
                                    &result.add(v.clone())
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            return result
        }
    }
    // T = (type, String)
    impl(T: type) Into[Array[String]] for []String {
        into(self: &[]String) -> Array[String] {
            result : Array[String] = (Array[String]).create((*self).length, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : []String = get_range_full(*self, new RangeFull {  })
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &String = get_index(arr, it_index)
                            #link #anonymous {
                                v : &String = it
                                it_index : i64 = it_index
                                {
                                    &result.add(v.clone())
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            return result
        }
    }
    // T = (type, Rc[Workspace])
    impl(T: type) Into[Array[Rc[Workspace]]] for []Rc[Workspace] {
        into(self: &[]Rc[Workspace]) -> Array[Rc[Workspace]] {
            result : Array[Rc[Workspace]] = (Array[Rc[Workspace]]).create((*self).length, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : []Rc[Workspace] = get_range_full(*self, new RangeFull {  })
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &Rc[Workspace] = get_index(arr, it_index)
                            #link #anonymous {
                                v : &Rc[Workspace] = it
                                it_index : i64 = it_index
                                {
                                    &result.add(v.clone())
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            return result
        }
    }


#file allocator.che
use import std.mem.std_heap_allocator

Allocator :: trait {
    allocate :: f.Accept(this)
    reallocate :: f.Accept(this)
    free :: f.Accept(this)
}

alloc : ($T: type, allocator: ^Allocator = ^DEFAULT_STD_HEAP_ALLOCATOR) -> ^T : alloc($T: type, allocator: ^Allocator) -> ^T {
    return alloc_raw(T, 1, allocator)
}
// Polymorphic instances for alloc($T: type, allocator: ^Allocator) -> ^T
    /*  */
    /* T = Scope */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Scope {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = Data */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Data {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = FiberContext */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^FiberContext {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = PrefixErrorHandler */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^PrefixErrorHandler {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = ThreadData */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^ThreadData {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = Fiber */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Fiber {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = CBCFunction */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^CBCFunction {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = Interpreter */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Interpreter {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = MainCommand */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^MainCommand {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = RcData */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^RcData {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = FileLogger */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^FileLogger {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = BumpAllocator */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^BumpAllocator {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = Workspace */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Workspace {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = TypeInfoModule */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoModule {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = TypeInfoPoly */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoPoly {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = TypeInfoPointer */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoPointer {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = TypeInfoReference */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoReference {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = DefaultCodeRunner */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^DefaultCodeRunner {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = Compiler */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Compiler {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = CompileStructMemberJob */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^CompileStructMemberJob {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = CompileGlobalNodeJob */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^CompileGlobalNodeJob {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstUnary */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstUnary {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstUfc */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstUfc {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = TypeInfoArray */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoArray {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = TypeInfoSlice */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoSlice {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = TypeInfoStruct */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoStruct {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstArgument */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstArgument {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstCast */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstCast {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = TypeInfoFunction */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoFunction {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = Lexer */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Lexer {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstAssignment */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstAssignment {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstConstDecl */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstConstDecl {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstDecl */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstDecl {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstTuple */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstTuple {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstBinary */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstBinary {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstCall */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstCall {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstIndex */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstIndex {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstDot */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstDot {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstArrayType */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstArrayType {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstArray */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstArray {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstBlock */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstBlock {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstMatchCase */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstMatchCase {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstMatch */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstMatch {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstIf */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstIf {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstLoop */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstLoop {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstFor */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstFor {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstBreak */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstBreak {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstContinue */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstContinue {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstDefer */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstDefer {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstReturn */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstReturn {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstPoly */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstPoly {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstFunction */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstFunction {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstStruct */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstStruct {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstEnum */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstEnum {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstTrait */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstTrait {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstImpl */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstImpl {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstUse */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstUse {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstImport */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstImport {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstString */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstString {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstBool */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstBool {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstIdentifier */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstIdentifier {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = AstNumberLiteral */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstNumberLiteral {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = ByteCodeGenerator */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^ByteCodeGenerator {
        return alloc_raw(1, allocator)
    }
    /*  */
    /* T = LoadFileJob */
    alloc(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^LoadFileJob {
        return alloc_raw(1, allocator)
    }


alloc_raw : ($T: type, count: uint, allocator: ^Allocator = ^DEFAULT_STD_HEAP_ALLOCATOR) -> ^T : alloc_raw($T: type, count: uint, allocator: ^Allocator) -> ^T {
    return cast() ((allocator).allocate(cast (count), @sizeof(T), @alignof(T)))
}
// Polymorphic instances for alloc_raw($T: type, count: uint, allocator: ^Allocator) -> ^T
    /*  */
    /* T = char8 */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^char8 {
        return cast(^char8) (allocator.allocate(count, @sizeof(char8), @alignof(char8)))
    }
    /*  */
    /* T = ^void */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^^void {
        return cast(^^void) (allocator.allocate(count, @sizeof(^void), @alignof(^void)))
    }
    /*  */
    /* T = ^CompilationJob */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^^CompilationJob {
        return cast(^^CompilationJob) (allocator.allocate(count, @sizeof(^CompilationJob), @alignof(^CompilationJob)))
    }
    /*  */
    /* T = ^FiberContext */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^^FiberContext {
        return cast(^^FiberContext) (allocator.allocate(count, @sizeof(^FiberContext), @alignof(^FiberContext)))
    }
    /*  */
    /* T = u8 */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^u8 {
        return cast(^u8) (allocator.allocate(count, @sizeof(u8), @alignof(u8)))
    }
    /*  */
    /* T = Scope */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Scope {
        return cast(^Scope) (allocator.allocate(count, @sizeof(Scope), @alignof(Scope)))
    }
    /*  */
    /* T = Data */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Data {
        return cast(^Data) (allocator.allocate(count, @sizeof(Data), @alignof(Data)))
    }
    /*  */
    /* T = FiberContext */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^FiberContext {
        return cast(^FiberContext) (allocator.allocate(count, @sizeof(FiberContext), @alignof(FiberContext)))
    }
    /*  */
    /* T = PrefixErrorHandler */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^PrefixErrorHandler {
        return cast(^PrefixErrorHandler) (allocator.allocate(count, @sizeof(PrefixErrorHandler), @alignof(PrefixErrorHandler)))
    }
    /*  */
    /* T = ThreadData */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^ThreadData {
        return cast(^ThreadData) (allocator.allocate(count, @sizeof(ThreadData), @alignof(ThreadData)))
    }
    /*  */
    /* T = Fiber */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Fiber {
        return cast(^Fiber) (allocator.allocate(count, @sizeof(Fiber), @alignof(Fiber)))
    }
    /*  */
    /* T = CBCFunction */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^CBCFunction {
        return cast(^CBCFunction) (allocator.allocate(count, @sizeof(CBCFunction), @alignof(CBCFunction)))
    }
    /*  */
    /* T = Interpreter */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Interpreter {
        return cast(^Interpreter) (allocator.allocate(count, @sizeof(Interpreter), @alignof(Interpreter)))
    }
    /*  */
    /* T = MainCommand */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^MainCommand {
        return cast(^MainCommand) (allocator.allocate(count, @sizeof(MainCommand), @alignof(MainCommand)))
    }
    /*  */
    /* T = RcData */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^RcData {
        return cast(^RcData) (allocator.allocate(count, @sizeof(RcData), @alignof(RcData)))
    }
    /*  */
    /* T = FileLogger */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^FileLogger {
        return cast(^FileLogger) (allocator.allocate(count, @sizeof(FileLogger), @alignof(FileLogger)))
    }
    /*  */
    /* T = BumpAllocator */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^BumpAllocator {
        return cast(^BumpAllocator) (allocator.allocate(count, @sizeof(BumpAllocator), @alignof(BumpAllocator)))
    }
    /*  */
    /* T = Workspace */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Workspace {
        return cast(^Workspace) (allocator.allocate(count, @sizeof(Workspace), @alignof(Workspace)))
    }
    /*  */
    /* T = TypeInfoModule */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoModule {
        return cast(^TypeInfoModule) (allocator.allocate(count, @sizeof(TypeInfoModule), @alignof(TypeInfoModule)))
    }
    /*  */
    /* T = TypeInfoPoly */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoPoly {
        return cast(^TypeInfoPoly) (allocator.allocate(count, @sizeof(TypeInfoPoly), @alignof(TypeInfoPoly)))
    }
    /*  */
    /* T = TypeInfoPointer */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoPointer {
        return cast(^TypeInfoPointer) (allocator.allocate(count, @sizeof(TypeInfoPointer), @alignof(TypeInfoPointer)))
    }
    /*  */
    /* T = TypeInfoReference */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoReference {
        return cast(^TypeInfoReference) (allocator.allocate(count, @sizeof(TypeInfoReference), @alignof(TypeInfoReference)))
    }
    /*  */
    /* T = DefaultCodeRunner */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^DefaultCodeRunner {
        return cast(^DefaultCodeRunner) (allocator.allocate(count, @sizeof(DefaultCodeRunner), @alignof(DefaultCodeRunner)))
    }
    /*  */
    /* T = Compiler */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Compiler {
        return cast(^Compiler) (allocator.allocate(count, @sizeof(Compiler), @alignof(Compiler)))
    }
    /*  */
    /* T = CompileStructMemberJob */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^CompileStructMemberJob {
        return cast(^CompileStructMemberJob) (allocator.allocate(count, @sizeof(CompileStructMemberJob), @alignof(CompileStructMemberJob)))
    }
    /*  */
    /* T = CompileGlobalNodeJob */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^CompileGlobalNodeJob {
        return cast(^CompileGlobalNodeJob) (allocator.allocate(count, @sizeof(CompileGlobalNodeJob), @alignof(CompileGlobalNodeJob)))
    }
    /*  */
    /* T = AstUnary */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstUnary {
        return cast(^AstUnary) (allocator.allocate(count, @sizeof(AstUnary), @alignof(AstUnary)))
    }
    /*  */
    /* T = AstUfc */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstUfc {
        return cast(^AstUfc) (allocator.allocate(count, @sizeof(AstUfc), @alignof(AstUfc)))
    }
    /*  */
    /* T = TypeInfoArray */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoArray {
        return cast(^TypeInfoArray) (allocator.allocate(count, @sizeof(TypeInfoArray), @alignof(TypeInfoArray)))
    }
    /*  */
    /* T = TypeInfoSlice */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoSlice {
        return cast(^TypeInfoSlice) (allocator.allocate(count, @sizeof(TypeInfoSlice), @alignof(TypeInfoSlice)))
    }
    /*  */
    /* T = TypeInfoStruct */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoStruct {
        return cast(^TypeInfoStruct) (allocator.allocate(count, @sizeof(TypeInfoStruct), @alignof(TypeInfoStruct)))
    }
    /*  */
    /* T = AstArgument */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstArgument {
        return cast(^AstArgument) (allocator.allocate(count, @sizeof(AstArgument), @alignof(AstArgument)))
    }
    /*  */
    /* T = AstCast */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstCast {
        return cast(^AstCast) (allocator.allocate(count, @sizeof(AstCast), @alignof(AstCast)))
    }
    /*  */
    /* T = TypeInfoFunction */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^TypeInfoFunction {
        return cast(^TypeInfoFunction) (allocator.allocate(count, @sizeof(TypeInfoFunction), @alignof(TypeInfoFunction)))
    }
    /*  */
    /* T = Lexer */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Lexer {
        return cast(^Lexer) (allocator.allocate(count, @sizeof(Lexer), @alignof(Lexer)))
    }
    /*  */
    /* T = AstAssignment */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstAssignment {
        return cast(^AstAssignment) (allocator.allocate(count, @sizeof(AstAssignment), @alignof(AstAssignment)))
    }
    /*  */
    /* T = AstConstDecl */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstConstDecl {
        return cast(^AstConstDecl) (allocator.allocate(count, @sizeof(AstConstDecl), @alignof(AstConstDecl)))
    }
    /*  */
    /* T = AstDecl */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstDecl {
        return cast(^AstDecl) (allocator.allocate(count, @sizeof(AstDecl), @alignof(AstDecl)))
    }
    /*  */
    /* T = AstTuple */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstTuple {
        return cast(^AstTuple) (allocator.allocate(count, @sizeof(AstTuple), @alignof(AstTuple)))
    }
    /*  */
    /* T = AstBinary */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstBinary {
        return cast(^AstBinary) (allocator.allocate(count, @sizeof(AstBinary), @alignof(AstBinary)))
    }
    /*  */
    /* T = AstCall */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstCall {
        return cast(^AstCall) (allocator.allocate(count, @sizeof(AstCall), @alignof(AstCall)))
    }
    /*  */
    /* T = AstIndex */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstIndex {
        return cast(^AstIndex) (allocator.allocate(count, @sizeof(AstIndex), @alignof(AstIndex)))
    }
    /*  */
    /* T = AstDot */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstDot {
        return cast(^AstDot) (allocator.allocate(count, @sizeof(AstDot), @alignof(AstDot)))
    }
    /*  */
    /* T = AstArrayType */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstArrayType {
        return cast(^AstArrayType) (allocator.allocate(count, @sizeof(AstArrayType), @alignof(AstArrayType)))
    }
    /*  */
    /* T = AstArray */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstArray {
        return cast(^AstArray) (allocator.allocate(count, @sizeof(AstArray), @alignof(AstArray)))
    }
    /*  */
    /* T = AstBlock */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstBlock {
        return cast(^AstBlock) (allocator.allocate(count, @sizeof(AstBlock), @alignof(AstBlock)))
    }
    /*  */
    /* T = AstMatchCase */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstMatchCase {
        return cast(^AstMatchCase) (allocator.allocate(count, @sizeof(AstMatchCase), @alignof(AstMatchCase)))
    }
    /*  */
    /* T = AstMatch */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstMatch {
        return cast(^AstMatch) (allocator.allocate(count, @sizeof(AstMatch), @alignof(AstMatch)))
    }
    /*  */
    /* T = AstIf */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstIf {
        return cast(^AstIf) (allocator.allocate(count, @sizeof(AstIf), @alignof(AstIf)))
    }
    /*  */
    /* T = AstLoop */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstLoop {
        return cast(^AstLoop) (allocator.allocate(count, @sizeof(AstLoop), @alignof(AstLoop)))
    }
    /*  */
    /* T = AstFor */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstFor {
        return cast(^AstFor) (allocator.allocate(count, @sizeof(AstFor), @alignof(AstFor)))
    }
    /*  */
    /* T = AstBreak */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstBreak {
        return cast(^AstBreak) (allocator.allocate(count, @sizeof(AstBreak), @alignof(AstBreak)))
    }
    /*  */
    /* T = AstContinue */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstContinue {
        return cast(^AstContinue) (allocator.allocate(count, @sizeof(AstContinue), @alignof(AstContinue)))
    }
    /*  */
    /* T = AstDefer */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstDefer {
        return cast(^AstDefer) (allocator.allocate(count, @sizeof(AstDefer), @alignof(AstDefer)))
    }
    /*  */
    /* T = AstReturn */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstReturn {
        return cast(^AstReturn) (allocator.allocate(count, @sizeof(AstReturn), @alignof(AstReturn)))
    }
    /*  */
    /* T = AstPoly */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstPoly {
        return cast(^AstPoly) (allocator.allocate(count, @sizeof(AstPoly), @alignof(AstPoly)))
    }
    /*  */
    /* T = AstFunction */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstFunction {
        return cast(^AstFunction) (allocator.allocate(count, @sizeof(AstFunction), @alignof(AstFunction)))
    }
    /*  */
    /* T = AstStruct */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstStruct {
        return cast(^AstStruct) (allocator.allocate(count, @sizeof(AstStruct), @alignof(AstStruct)))
    }
    /*  */
    /* T = AstEnum */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstEnum {
        return cast(^AstEnum) (allocator.allocate(count, @sizeof(AstEnum), @alignof(AstEnum)))
    }
    /*  */
    /* T = AstTrait */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstTrait {
        return cast(^AstTrait) (allocator.allocate(count, @sizeof(AstTrait), @alignof(AstTrait)))
    }
    /*  */
    /* T = AstImpl */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstImpl {
        return cast(^AstImpl) (allocator.allocate(count, @sizeof(AstImpl), @alignof(AstImpl)))
    }
    /*  */
    /* T = AstUse */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstUse {
        return cast(^AstUse) (allocator.allocate(count, @sizeof(AstUse), @alignof(AstUse)))
    }
    /*  */
    /* T = AstImport */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstImport {
        return cast(^AstImport) (allocator.allocate(count, @sizeof(AstImport), @alignof(AstImport)))
    }
    /*  */
    /* T = AstString */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstString {
        return cast(^AstString) (allocator.allocate(count, @sizeof(AstString), @alignof(AstString)))
    }
    /*  */
    /* T = AstBool */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstBool {
        return cast(^AstBool) (allocator.allocate(count, @sizeof(AstBool), @alignof(AstBool)))
    }
    /*  */
    /* T = AstIdentifier */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstIdentifier {
        return cast(^AstIdentifier) (allocator.allocate(count, @sizeof(AstIdentifier), @alignof(AstIdentifier)))
    }
    /*  */
    /* T = AstNumberLiteral */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^AstNumberLiteral {
        return cast(^AstNumberLiteral) (allocator.allocate(count, @sizeof(AstNumberLiteral), @alignof(AstNumberLiteral)))
    }
    /*  */
    /* T = ByteCodeGenerator */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^ByteCodeGenerator {
        return cast(^ByteCodeGenerator) (allocator.allocate(count, @sizeof(ByteCodeGenerator), @alignof(ByteCodeGenerator)))
    }
    /*  */
    /* T = LoadFileJob */
    alloc_raw(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^LoadFileJob {
        return cast(^LoadFileJob) (allocator.allocate(count, @sizeof(LoadFileJob), @alignof(LoadFileJob)))
    }


realloc_raw : (mem: ^$T, count: uint, allocator: ^Allocator = ^DEFAULT_STD_HEAP_ALLOCATOR) -> ^T : realloc_raw(mem: ^$T, count: uint, allocator: ^Allocator) -> ^T {
    return cast ((allocator).reallocate(cast (mem), count, @sizeof(T), @alignof(T)))
}
// Polymorphic instances for realloc_raw(mem: ^$T, count: uint, allocator: ^Allocator) -> ^T
    /* T = (type, ^AstNode) */
    /*  */
    realloc_raw(mem: ^^AstNode, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^^AstNode {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(^AstNode), @alignof(^AstNode)))
    }
    /* T = (type, ^CompilationJob) */
    /*  */
    realloc_raw(mem: ^^CompilationJob, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^^CompilationJob {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(^CompilationJob), @alignof(^CompilationJob)))
    }
    /* T = (type, Rc[Workspace]) */
    /*  */
    realloc_raw(mem: ^Rc[Workspace], count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Rc[Workspace] {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(Rc[Workspace]), @alignof(Rc[Workspace])))
    }
    /* T = (type, ^FiberContext) */
    /*  */
    realloc_raw(mem: ^^FiberContext, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^^FiberContext {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(^FiberContext), @alignof(^FiberContext)))
    }
    /* T = (type, (name: string, symbol: Symbol)) */
    /*  */
    realloc_raw(mem: ^(name: string, symbol: Symbol), count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^(name: string, symbol: Symbol) {
        return cast (allocator.reallocate(cast (mem), count, @sizeof((name: string, symbol: Symbol)), @alignof((name: string, symbol: Symbol))))
    }
    /* T = (type, ^AstDecl) */
    /*  */
    realloc_raw(mem: ^^AstDecl, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^^AstDecl {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(^AstDecl), @alignof(^AstDecl)))
    }
    /* T = (type, ^AstConstDecl) */
    /*  */
    realloc_raw(mem: ^^AstConstDecl, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^^AstConstDecl {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(^AstConstDecl), @alignof(^AstConstDecl)))
    }
    /* T = (type, LineInfo) */
    /*  */
    realloc_raw(mem: ^LineInfo, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^LineInfo {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(LineInfo), @alignof(LineInfo)))
    }
    /* T = (type, VariableInfo) */
    /*  */
    realloc_raw(mem: ^VariableInfo, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^VariableInfo {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(VariableInfo), @alignof(VariableInfo)))
    }
    /* T = (type, u64) */
    /*  */
    realloc_raw(mem: ^u64, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^u64 {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(u64), @alignof(u64)))
    }
    /* T = (type, i64) */
    /*  */
    realloc_raw(mem: ^i64, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^i64 {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(i64), @alignof(i64)))
    }
    /* T = (type, String) */
    /*  */
    realloc_raw(mem: ^String, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^String {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(String), @alignof(String)))
    }
    /* T = (type, Bucket) */
    /*  */
    realloc_raw(mem: ^Bucket, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Bucket {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(Bucket), @alignof(Bucket)))
    }
    /* T = (type, (name: string, mem: ^TypeInfoStructMember, set: bool)) */
    /*  */
    realloc_raw(mem: ^(name: string, mem: ^TypeInfoStructMember, set: bool), count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^(name: string, mem: ^TypeInfoStructMember, set: bool) {
        return cast (allocator.reallocate(cast (mem), count, @sizeof((name: string, mem: ^TypeInfoStructMember, set: bool)), @alignof((name: string, mem: ^TypeInfoStructMember, set: bool))))
    }
    /* T = (type, string) */
    /*  */
    realloc_raw(mem: ^string, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^string {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(string), @alignof(string)))
    }
    /* T = (type, u16) */
    /*  */
    realloc_raw(mem: ^u16, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^u16 {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(u16), @alignof(u16)))
    }
    /* T = (type, u8) */
    /*  */
    realloc_raw(mem: ^u8, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^u8 {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(u8), @alignof(u8)))
    }
    /* T = (type, ^AstArgument) */
    /*  */
    realloc_raw(mem: ^^AstArgument, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^^AstArgument {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(^AstArgument), @alignof(^AstArgument)))
    }
    /* T = (type, ^AstMatchCase) */
    /*  */
    realloc_raw(mem: ^^AstMatchCase, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^^AstMatchCase {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(^AstMatchCase), @alignof(^AstMatchCase)))
    }
    /* T = (type, Thread) */
    /*  */
    realloc_raw(mem: ^Thread, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^Thread {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(Thread), @alignof(Thread)))
    }
    /* T = (type, ^AstImpl) */
    /*  */
    realloc_raw(mem: ^^AstImpl, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^^AstImpl {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(^AstImpl), @alignof(^AstImpl)))
    }
    /* T = (type, ^CompileStructMemberJob) */
    /*  */
    realloc_raw(mem: ^^CompileStructMemberJob, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^^CompileStructMemberJob {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(^CompileStructMemberJob), @alignof(^CompileStructMemberJob)))
    }
    /* T = (type, BumpBucket) */
    /*  */
    realloc_raw(mem: ^BumpBucket, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ^BumpBucket {
        return cast (allocator.reallocate(cast (mem), count, @sizeof(BumpBucket), @alignof(BumpBucket)))
    }


alloc_n : ($T: type, count: uint, allocator: ^Allocator = ^DEFAULT_STD_HEAP_ALLOCATOR) -> []T : alloc_n($T: type, count: uint, allocator: ^Allocator) -> []T {
    mem :  = cast() ((allocator).allocate(count, @sizeof(T), @alignof(T)))
    (mem).length = cast (count)
    return mem
}
// Polymorphic instances for alloc_n($T: type, count: uint, allocator: ^Allocator) -> []T
    /*  */
    /* T = u16 */
    alloc_n(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []u16 {
        mem : []u16 = cast([]u16) (cast(^u16) (allocator.allocate(count, @sizeof(u16), @alignof(u16))))
        (mem).length = cast (count)
        return mem
    }
    /*  */
    /* T = u8 */
    alloc_n(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []u8 {
        mem : []u8 = cast([]u8) (cast(^u8) (allocator.allocate(count, @sizeof(u8), @alignof(u8))))
        (mem).length = cast (count)
        return mem
    }
    /*  */
    /* T = ^TypeInfo */
    alloc_n(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []^TypeInfo {
        mem : []^TypeInfo = cast([]^TypeInfo) (cast(^^TypeInfo) (allocator.allocate(count, @sizeof(^TypeInfo), @alignof(^TypeInfo))))
        (mem).length = cast (count)
        return mem
    }
    /*  */
    /* T = Entry[i64, ^AstStruct] */
    alloc_n(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []Entry[i64, ^AstStruct] {
        mem : []Entry[i64, ^AstStruct] = cast([]Entry[i64, ^AstStruct]) (cast(^Entry[i64, ^AstStruct]) (allocator.allocate(count, @sizeof(Entry[i64, ^AstStruct]), @alignof(Entry[i64, ^AstStruct]))))
        (mem).length = cast (count)
        return mem
    }
    /*  */
    /* T = Entry[string, SourceFile] */
    alloc_n(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []Entry[string, SourceFile] {
        mem : []Entry[string, SourceFile] = cast([]Entry[string, SourceFile]) (cast(^Entry[string, SourceFile]) (allocator.allocate(count, @sizeof(Entry[string, SourceFile]), @alignof(Entry[string, SourceFile]))))
        (mem).length = cast (count)
        return mem
    }
    /*  */
    /* T = Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] */
    alloc_n(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] {
        mem : []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = cast([]Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]) (cast(^Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]) (allocator.allocate(count, @sizeof(Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]), @alignof(Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]))))
        (mem).length = cast (count)
        return mem
    }
    /*  */
    /* T = Entry[string, String] */
    alloc_n(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []Entry[string, String] {
        mem : []Entry[string, String] = cast([]Entry[string, String]) (cast(^Entry[string, String]) (allocator.allocate(count, @sizeof(Entry[string, String]), @alignof(Entry[string, String]))))
        (mem).length = cast (count)
        return mem
    }
    /*  */
    /* T = Entry[string, Symbol] */
    alloc_n(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []Entry[string, Symbol] {
        mem : []Entry[string, Symbol] = cast([]Entry[string, Symbol]) (cast(^Entry[string, Symbol]) (allocator.allocate(count, @sizeof(Entry[string, Symbol]), @alignof(Entry[string, Symbol]))))
        (mem).length = cast (count)
        return mem
    }
    /*  */
    /* T = Entry[i64, i64] */
    alloc_n(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []Entry[i64, i64] {
        mem : []Entry[i64, i64] = cast([]Entry[i64, i64]) (cast(^Entry[i64, i64]) (allocator.allocate(count, @sizeof(Entry[i64, i64]), @alignof(Entry[i64, i64]))))
        (mem).length = cast (count)
        return mem
    }
    /*  */
    /* T = Entry[string, string] */
    alloc_n(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []Entry[string, string] {
        mem : []Entry[string, string] = cast([]Entry[string, string]) (cast(^Entry[string, string]) (allocator.allocate(count, @sizeof(Entry[string, string]), @alignof(Entry[string, string]))))
        (mem).length = cast (count)
        return mem
    }
    /*  */
    /* T = Entry[TypeId, Array[^AstImpl]] */
    alloc_n(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []Entry[TypeId, Array[^AstImpl]] {
        mem : []Entry[TypeId, Array[^AstImpl]] = cast([]Entry[TypeId, Array[^AstImpl]]) (cast(^Entry[TypeId, Array[^AstImpl]]) (allocator.allocate(count, @sizeof(Entry[TypeId, Array[^AstImpl]]), @alignof(Entry[TypeId, Array[^AstImpl]]))))
        (mem).length = cast (count)
        return mem
    }
    /*  */
    /* T = TypeInfoStructMember */
    alloc_n(count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []TypeInfoStructMember {
        mem : []TypeInfoStructMember = cast([]TypeInfoStructMember) (cast(^TypeInfoStructMember) (allocator.allocate(count, @sizeof(TypeInfoStructMember), @alignof(TypeInfoStructMember))))
        (mem).length = cast (count)
        return mem
    }


realloc_n : (mem: []$T, count: uint, allocator: ^Allocator = ^DEFAULT_STD_HEAP_ALLOCATOR) -> []T : realloc_n(mem: []$T, count: uint, allocator: ^Allocator) -> []T {
    (mem).data = cast ((allocator).reallocate(cast ((mem).data), count, @sizeof(T), @alignof(T)))
    (mem).length = cast (count)
    return mem
}
// Polymorphic instances for realloc_n(mem: []$T, count: uint, allocator: ^Allocator) -> []T
    /* T = (type, u8) */
    /*  */
    realloc_n(mem: []u8, count: u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> []u8 {
        (mem).data = cast (allocator.reallocate(cast ((mem).data), count, @sizeof(u8), @alignof(u8)))
        (mem).length = cast (count)
        return mem
    }


free : (mem: ^$T, allocator: ^Allocator = ^DEFAULT_STD_HEAP_ALLOCATOR) : free(mem: ^$T, allocator: ^Allocator) {
    (allocator).free(cast (mem))
}
// Polymorphic instances for free(mem: ^$T, allocator: ^Allocator)
    /* T = (type, ^AstNode) */
    /*  */
    free(mem: ^^AstNode, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, ^CompilationJob) */
    /*  */
    free(mem: ^^CompilationJob, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, Rc[Workspace]) */
    /*  */
    free(mem: ^Rc[Workspace], allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, RcData) */
    /*  */
    free(mem: ^RcData, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, ^FiberContext) */
    /*  */
    free(mem: ^^FiberContext, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, (name: string, symbol: Symbol)) */
    /*  */
    free(mem: ^(name: string, symbol: Symbol), allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, ^AstDecl) */
    /*  */
    free(mem: ^^AstDecl, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, ^AstConstDecl) */
    /*  */
    free(mem: ^^AstConstDecl, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, LineInfo) */
    /*  */
    free(mem: ^LineInfo, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, VariableInfo) */
    /*  */
    free(mem: ^VariableInfo, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, u64) */
    /*  */
    free(mem: ^u64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, i64) */
    /*  */
    free(mem: ^i64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, String) */
    /*  */
    free(mem: ^String, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, MainCommand) */
    /*  */
    free(mem: ^MainCommand, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, Bucket) */
    /*  */
    free(mem: ^Bucket, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, (name: string, mem: ^TypeInfoStructMember, set: bool)) */
    /*  */
    free(mem: ^(name: string, mem: ^TypeInfoStructMember, set: bool), allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, string) */
    /*  */
    free(mem: ^string, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, u16) */
    /*  */
    free(mem: ^u16, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, u8) */
    /*  */
    free(mem: ^u8, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, ^AstArgument) */
    /*  */
    free(mem: ^^AstArgument, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, ^AstMatchCase) */
    /*  */
    free(mem: ^^AstMatchCase, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, Thread) */
    /*  */
    free(mem: ^Thread, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, Data) */
    /*  */
    free(mem: ^Data, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, ^AstImpl) */
    /*  */
    free(mem: ^^AstImpl, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, ^CompileStructMemberJob) */
    /*  */
    free(mem: ^^CompileStructMemberJob, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }
    /* T = (type, BumpBucket) */
    /*  */
    free(mem: ^BumpBucket, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast (mem))
    }


free_n : (mem: []$T, allocator: ^Allocator = ^DEFAULT_STD_HEAP_ALLOCATOR) : free_n(mem: []$T, allocator: ^Allocator) {
    (allocator).free(cast ((mem).data))
}
// Polymorphic instances for free_n(mem: []$T, allocator: ^Allocator)
    /* T = (type, u16) */
    /*  */
    free_n(mem: []u16, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast ((mem).data))
    }
    /* T = (type, u8) */
    /*  */
    free_n(mem: []u8, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast ((mem).data))
    }
    /* T = (type, Entry[i64, ^AstStruct]) */
    /*  */
    free_n(mem: []Entry[i64, ^AstStruct], allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast ((mem).data))
    }
    /* T = (type, Entry[string, SourceFile]) */
    /*  */
    free_n(mem: []Entry[string, SourceFile], allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast ((mem).data))
    }
    /* T = (type, Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]) */
    /*  */
    free_n(mem: []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast ((mem).data))
    }
    /* T = (type, Entry[string, String]) */
    /*  */
    free_n(mem: []Entry[string, String], allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast ((mem).data))
    }
    /* T = (type, Entry[string, Symbol]) */
    /*  */
    free_n(mem: []Entry[string, Symbol], allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast ((mem).data))
    }
    /* T = (type, Entry[i64, i64]) */
    /*  */
    free_n(mem: []Entry[i64, i64], allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast ((mem).data))
    }
    /* T = (type, Entry[string, string]) */
    /*  */
    free_n(mem: []Entry[string, string], allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast ((mem).data))
    }
    /* T = (type, Entry[TypeId, Array[^AstImpl]]) */
    /*  */
    free_n(mem: []Entry[TypeId, Array[^AstImpl]], allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) {
        allocator.free(cast ((mem).data))
    }


#file arena_allocator.che
use import std.mem.allocator

use import std.mem.std_heap_allocator

use import std.array

use import std.printable

util :  : import std.util

io :  : import std.io

C :  : import std.c

ArenaAllocator :: struct { // size: 64, alignment: 8
    parent : ^Allocator
    bucket_size : u64
    buckets : Array[Bucket]
}

impl Drop for ArenaAllocator {
    drop(self: &ArenaAllocator) {
        #macro {
            local arr : &Array[Bucket] = &buckets
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &Bucket = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            it : &Bucket = it
                            it_index : i64 = it_index
                            {
                                parent.free(cast(^void) (((*it).memory).data))
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
    }
}

impl ArenaAllocator {
    new(size: u64, alloc: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> ArenaAllocator {
        a : ArenaAllocator = new ArenaAllocator { parent = alloc, bucket_size = size, buckets = (Array[Bucket]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) }
        return a
    }
    
    clear(self: &ArenaAllocator) {
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = (buckets).length }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_102) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_102))[0]
                it_index : i64 = @var(@id((it, it_index)_102))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            (*access(&buckets, i)).filled = 0
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
    }
    
    dump(self: &ArenaAllocator, dump_buckets: bool = false) {
        (io).printfln("ArenaAllocator ({} buckets)", (buckets).length)
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = (buckets).length }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_104) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_104))[0]
                it_index : i64 = @var(@id((it, it_index)_104))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            bucket : &Bucket = access(&buckets, i)
                            (io).printfln("  Bucket {}: {}/{} bytes", (i, (*bucket).filled, ((*bucket).memory).length))
                            if dump_buckets {
                                current : u64 = 0
                                loop {
                                    if !(current < (*bucket).filled) then break else {}
                                    len : u64 = *cast(^u64) ((util).pointer_add(((*bucket).memory).data, cast(i64) (current)))
                                    if (len == 0) {
                                        current = (current + 8)
                                        continue
                                    } else {}
                                    (io).printfln("    {}: {} bytes", (current, len))
                                    current = (current + (len + 8))
                                    current = align(current, 8)
                                }
                            } else {}
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
    }
}

impl Allocator for ArenaAllocator {
    allocate(self: &ArenaAllocator, count: u64, elementSize: u64, alignment: u64) -> ^void {
        required_size : u64 = ((count * elementSize) + 8)
        if (alignment < 8) {
            alignment = 8
        } else {}
        free_bucket : ^Bucket = null
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = (buckets).length }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_106) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_106))[0]
                it_index : i64 = @var(@id((it, it_index)_106))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            bucket : &Bucket = access(&buckets, i)
                            if bucket.can_store(required_size, alignment) {
                                free_bucket = ^*bucket
                                #anonymous {
                                    it_index = (it_index + 1)
                                    it = (it + inc)
                                };
                                break
                            } else {}
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        if (cast(^void) (free_bucket) == null) {
            new_bucket_size : u64 = (required_size * 2)
            if (new_bucket_size < bucket_size) {
                new_bucket_size = bucket_size
            } else {}
            new_mem : []u8 = cast([]u8) (cast(^u8) (parent.allocate(new_bucket_size, @sizeof(u8), alignment)))
            (new_mem).length = cast (new_bucket_size)
            &buckets.add(new Bucket { memory = new_mem, filled = 0 })
            free_bucket = ^*access(&buckets, ((buckets).length - 1))
        } else {}
        ptr : ^u8 = &*free_bucket.allocate(required_size, alignment)
        len_ptr : ^u64 = cast(^u64) (ptr)
        *len_ptr = (count * elementSize)
        return cast(^void) ((util).pointer_add(ptr, 8))
    }
    
    reallocate(self: &ArenaAllocator, mem: ^void, count: u64, elementSize: u64, alignment: u64) -> ^void {
        if (mem == null) {
            return self.allocate(count, elementSize, alignment)
        } else {
            len : u64 = *cast(^u64) ((util).pointer_add(mem, -8))
            if (len >= (count * elementSize)) {
                return mem
            } else {}
            new_mem : ^void = self.allocate(count, elementSize, alignment)
            (C).memcpy(new_mem, mem, len)
            return new_mem
        }
    }
    
    free(self: &ArenaAllocator, mem: ^void) {}
}

align :: align(add: u64, align: u64) -> u64 {
    mul : u64 = ((add + align) - 1)
    mul = (mul - (mul % align))
    return mul
}

Bucket :: struct { // size: 24, alignment: 8
    memory : []u8
    filled : u64
}

impl Bucket {
    can_store(self: &Bucket, size: u64, align: u64) -> bool {
        next_address : ^u8 = (util).next_aligned((util).pointer_add((memory).data, cast(i64) (filled)), align)
        next_offset : u64 = (cast(u64) (next_address) - cast(u64) ((memory).data))
        free : u64 = (cast(u64) ((memory).length) - next_offset)
        return (free >= size)
    }
    
    allocate(self: &Bucket, size: u64, align: u64) -> ^u8 {
        next_address : ^u8 = (util).next_aligned((util).pointer_add((memory).data, cast(i64) (filled)), align)
        next_offset : u64 = (cast(u64) (next_address) - cast(u64) ((memory).data))
        filled = (next_offset + size)
        return next_address
    }
}

#file process.che
use import std.os.windows

use import std.os.windows_functions

use import std.os.windows_constants

use import std.os.windows_types

use import std.string

C :  : import std.c

io :  : import std.io

fmt :  : import std.fmt

find_on_path :: find_on_path(program: string) -> Option[String] {
    #anonymous {
        buffer : [260]char32 = default
        (C).memcpy(cast(^void) ((buffer).data), cast(^void) (((program).bytes).data), cast (((program).bytes).length))
        ok : bool = (0 != PathFindOnPathA(cast ((buffer).data), null))
        if !ok {
            return Option[String].None
        } else {}
        result : String = (String).from_cstring(cast ((buffer).data), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        return Option[String].Some(result)
    }
    #anonymous {}
}

run_process :: run_process(program: string, args: []string, working_dir: string) -> bool {
    #anonymous {
        si : STARTUPINFOA = new STARTUPINFOA {
            cb = @sizeof(STARTUPINFOA)
            lpReserved = default
            lpDesktop = default
            lpTitle = default
            dwX = default
            dwY = default
            dwXSize = default
            dwYSize = default
            dwXCountChars = default
            dwYCountChars = default
            dwFillAttribute = default
            dwFlags = default
            wShowWindow = default
            cbReserved2 = default
            lpReserved2 = default
            hStdInput = default
            hStdOutput = default
            hStdError = default
        }
        pi : PROCESS_INFORMATION = new PROCESS_INFORMATION { hProcess = default, hThread = default, dwProcessId = default, dwThreadId = default }
        command_line : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &command_line.appendf("`"{}`"", program)
        #macro {
            local arr : []string = args
            
            local reverse : bool : false
            local by_ref : bool : false
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : string = *get_index(arr, it_index)
                        #link #anonymous {
                            arg : string = it
                            it_index : i64 = it_index
                            {
                                &command_line.appendf(" `"{}`"", arg)
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        &command_line.append_char(cast(char32) (0))
        current_directory : String = (String).from_string(working_dir, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &current_directory.append_char(cast(char32) (0))
        ok : bool = (0 != CreateProcessA(null, cast (&command_line.get_raw()), null, null, 0, 0, null, cast (&current_directory.get_raw()), ^si, ^pi))
        if !ok {
            lastError : WindowsErrorCode = GetLastError()
            (io).println((fmt).format("failed to create process: 0x{:x}", cast([]^any) ([cast(^any) (lastError)])))
            @destruct(current_directory);
            @destruct(command_line);
            return false
        } else {}
        WaitForSingleObject((pi).hProcess, INFINITE)
        CloseHandle((pi).hThread)
        CloseHandle((pi).hProcess)
        @destruct(current_directory);
        @destruct(command_line);
        return true
    }
    #anonymous {}
}

#file string.che
io :  : import std.io

util :  : import std.util

C :  : import std.c

fmt :  : import std.fmt

use import std.array

use import std.hash

use import std.unicode

use import std.printable

use import std.mem.allocator

use import std.mem.std_heap_allocator

import std.alloca

use import std.os.windows

use import std.os.windows_functions

use import std.os.windows_constants

String :: struct { // size: 40, alignment: 8
    data : []u8
    length : i64
    allocator : ^Allocator
}

impl Drop for String {
    drop(self: &String) {
        if (cast(^void) (allocator) != null) {
            free_n(data, allocator)
        } else {}
        data = null
        length = 0
    }
}

impl String {
    empty(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> String {
        return new String { data = null, length = 0, allocator = allocator }
    }
    
    with_capacity(cap: i64, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> String {
        result : String = new String { data = null, length = 0, allocator = allocator }
        &result.reserve(cap)
        return result
    }
    
    from_raw_ptr(ptr: ^u8, cap: i64) -> String {
        sl : []u8 = cast([]u8) (ptr)
        (sl).length = cap
        return new String { data = sl, length = 0, allocator = null }
    }
    
    from_string(str: string, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> String {
        s : String = (Self).empty(allocator)
        &s.append_string(str)
        return s
    }
    
    from_cstring(str: ^char8, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> String {
        s : String = (Self).empty(allocator)
        &s.append_cstring(str)
        return s
    }
    
    from_utf16(str: []u16) -> Result[String, ()] {
        #anonymous {
            required_size : i32 = WideCharToMultiByte(CP_UTF8, 0, (str).data, cast ((str).length), null, 0, null, null)
            result : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            &result.resize(cast(i64) (required_size))
            bytes_written : i32 = WideCharToMultiByte(CP_UTF8, 0, (str).data, cast ((str).length), &result.get_raw(), required_size, null, null)
            if (bytes_written == 0) {
                @destruct(result);
                return Result[String, ()].Err(())
            } else {}
            return Result[String, ()].Ok(result)
        }
    }
    
    get_capacity(self: &String) -> i64 {
        return (data).length
    }
    
    get_length(self: &String) -> i64 {
        return length
    }
    
    get_raw(self: &String) -> ^u8 {
        return (data).data
    }
    
    char_at(self: &String, i: i64) -> char32 #operator("[]") {
        @id((code_point, len)_108) : (char32, i32) = (Utf8).decode(get_range(data, new Range[i64] { start = i, end = (data).length }))
        code_point : char32 = @var(@id((code_point, len)_108))[0]
        len : i32 = @var(@id((code_point, len)_108))[1]
        return code_point
    }
    
    set_char_at(self: &String, i: i64, c: u8) #operator("set[]") {
        *get_index(data, i) = c
    }
    
    reserve_more(self: &String, amount: i64) {
        self.reserve((length + amount))
    }
    
    reserve(self: &String, size: i64) {
        if ((data).length > size) {
            return
        } else {}
        (data).length = size
        if (cast(^void) ((data).data) == null) {
            length = 0
            data = alloc_n(cast (size), allocator)
        } else {
            data = realloc_n(data, cast (size), allocator)
            if (length > (data).length) {
                length = (data).length
            } else {}
        }
    }
    
    clear(self: &String) {
        length = 0
    }
    
    resize(self: &String, size: i64) {
        self.reserve(size)
        length = size
    }
    
    append(self: &String, other: &String) -> &String #operator("+=") {
        if (cast(^void) (((*other).data).data) == null) {
            return self
        } else {}
        newLength : i64 = (length + (*other).length)
        self.reserve(newLength)
        (C).memcpy(cast (^(data).data[length]), cast (((*other).data).data), cast(u64) (((*other).length * @sizeof(u8))))
        length = newLength
        return self
    }
    
    append_string(self: &String, other: string) -> &String #operator("+=") {
        newLength : i64 = (length + ((other).bytes).length)
        self.reserve(newLength)
        (C).memcpy(cast (^(data).data[length]), cast (((other).bytes).data), cast (((other).bytes).length))
        length = newLength
        return self
    }
    
    append_cstring(self: &String, other: ^char8) -> &String #operator("+=") {
        otherLen : u64 = (C).strlen(other)
        newLength : i64 = (length + cast(i64) (otherLen))
        self.reserve(newLength)
        (C).memcpy(cast (^(data).data[length]), cast (other), otherLen)
        length = newLength
        return self
    }
    
    append_char(self: &String, ch: char32) -> &String #operator("+=") {
        @id((bytes, count)_109) : ([4]u8, i32) = (Utf8).encode(ch)
        bytes : [4]u8 = @var(@id((bytes, count)_109))[0]
        count : i32 = @var(@id((bytes, count)_109))[1]
        newLength : i64 = (length + cast(i64) (count))
        self.reserve(newLength)
        (C).memcpy(cast(^void) (^*get_index(data, length)), cast(^void) (^*get_index(&bytes, 0)), cast (count))
        length = newLength
        return self
    }
    
    sliceFT(self: &String, from: i64, to: i64) -> string {
        slice : string = @string_from_ptr_and_length(^*get_index(data, from), (to - from))
        return slice
    }
    
    sliceFL(self: &String, from: i64, len: i64) -> string {
        slice : string = @string_from_ptr_and_length(^*get_index(data, from), len)
        return slice
    }
    
    slice(self: &String) -> string {
        return self.sliceFL(0, length)
    }
    
    sliceF(self: &String, from: i64) -> string {
        return self.sliceFL(from, (length - from))
    }
    
    sliceL(self: &String, len: i64) -> string {
        return self.sliceFL(0, len)
    }
    
    index_of(self: &String, ch: char32) -> i64 {
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = length }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_110) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_110))[0]
                it_index : i64 = @var(@id((it, it_index)_110))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            if (*get_index(data, i) == cast(u8) (ch)) {
                                #anonymous {
                                    it_index = (it_index + 1)
                                    it = (it + inc)
                                };
                                return i
                            } else {}
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        return -1
    }
    
    as_cstring(self: &String) -> ^char8 {
        self.reserve((length + 1))
        *get_index(data, length) = 0u8
        return cast ((data).data)
    }
}

impl Equatable[String] for String {
    equal(self: &String, other: &String) -> bool {
        str : string = self.slice()
        oth : string = other.slice()
        return streq_string(str, oth)
    }
}

impl Equatable[string] for String {
    equal(self: &String, other: &string) -> bool {
        str : string = self.slice()
        return streq_string(str, *other)
    }
}

impl Equatable[string] for string {
    equal(self: &string, b: &string) -> bool {
        return streq_string(*self, *b)
    }
}

impl Hashable for String {
    hash(self: &String) -> u64 {
        str : string = self.slice()
        return &str.hash()
    }
}

impl Clone for String {
    clone(self: &String) -> String {
        other : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &other.append(self)
        return other
    }
}

impl String {
    append_print(self: &String, pr: ^Printable) -> &String #operator("+=") {
        pr.print(self, "")
        return self
    }
    
    appendf(&String, format: string, arguments: $T) {
        if @is_tuple(T) {
            if ((T).length == 0) {
                args :  = [^arguments]
            } else {
                args :  = default
                @for_tuple_values(arguments, (v: , i: ) => {
                    if @types_match(@typeof(v), &$_) {
                        *args[i] = ^*v
                    } else {
                        *args[i] = ^v
                    }
                })
            }
        } else {
            args :  = [^arguments]
        }
        (self).append_printables(format, args)
    }
    // Polymorphic instances for appendf(&String, format: string, arguments: $T)
        /* T = (type, string) */
        /*  */
        appendf(self: &String, format: string, arguments: string) {
            #anonymous {
                args : [1]^Printable = [cast(^Printable) (^arguments)]
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
        /* T = (type, f32) */
        /*  */
        appendf(self: &String, format: string, arguments: f32) {
            #anonymous {
                args : [1]^Printable = [cast(^Printable) (^arguments)]
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
        /* T = (type, f64) */
        /*  */
        appendf(self: &String, format: string, arguments: f64) {
            #anonymous {
                args : [1]^Printable = [cast(^Printable) (^arguments)]
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
        /* T = (type, i64) */
        /*  */
        appendf(self: &String, format: string, arguments: i64) {
            #anonymous {
                args : [1]^Printable = [cast(^Printable) (^arguments)]
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
        /* T = (type, char32) */
        /*  */
        appendf(self: &String, format: string, arguments: char32) {
            #anonymous {
                args : [1]^Printable = [cast(^Printable) (^arguments)]
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
        /* T = (type, (string, i64, i64, i64)) */
        /*  */
        appendf(self: &String, format: string, arguments: (string, i64, i64, i64)) {
            #anonymous {
                #anonymous {
                    args : [4]^Printable = default
                    {
                        {
                            i : u0 : 0
                            v : string = arguments[0]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                        {
                            i : u0 : 1
                            v : i64 = arguments[1]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                        {
                            i : u0 : 2
                            v : i64 = arguments[2]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                        {
                            i : u0 : 3
                            v : i64 = arguments[3]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                    }
                }
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
        /* T = (type, (TokenType, Location)) */
        /*  */
        appendf(self: &String, format: string, arguments: (TokenType, Location)) {
            #anonymous {
                #anonymous {
                    args : [2]^Printable = default
                    {
                        {
                            i : u0 : 0
                            v : TokenType = arguments[0]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                        {
                            i : u0 : 1
                            v : Location = arguments[1]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                    }
                }
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
        /* T = (type, (f64, f64)) */
        /*  */
        appendf(self: &String, format: string, arguments: (f64, f64)) {
            #anonymous {
                #anonymous {
                    args : [2]^Printable = default
                    {
                        {
                            i : u0 : 0
                            v : f64 = arguments[0]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                        {
                            i : u0 : 1
                            v : f64 = arguments[1]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                    }
                }
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
        /* T = (type, String) */
        /*  */
        appendf(self: &String, format: string, arguments: String) {
            #anonymous {
                args : [1]^Printable = [cast(^Printable) (^arguments)]
            }
            self.append_printables(format, cast([]^Printable) (args))
            @destruct(arguments)
        }
        /* T = (type, ()) */
        /*  */
        appendf(self: &String, format: string, arguments: ()) {
            #anonymous {
                #anonymous {
                    args : [1]^Printable = [cast(^Printable) (^arguments)]
                }
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
        /* T = (type, (i64, u64, i64)) */
        /*  */
        appendf(self: &String, format: string, arguments: (i64, u64, i64)) {
            #anonymous {
                #anonymous {
                    args : [3]^Printable = default
                    {
                        {
                            i : u0 : 0
                            v : i64 = arguments[0]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                        {
                            i : u0 : 1
                            v : u64 = arguments[1]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                        {
                            i : u0 : 2
                            v : i64 = arguments[2]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                    }
                }
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
        /* T = (type, (u64, u64)) */
        /*  */
        appendf(self: &String, format: string, arguments: (u64, u64)) {
            #anonymous {
                #anonymous {
                    args : [2]^Printable = default
                    {
                        {
                            i : u0 : 0
                            v : u64 = arguments[0]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                        {
                            i : u0 : 1
                            v : u64 = arguments[1]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                    }
                }
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
        /* T = (type, (i64, u64, i64)) */
        /*  */
        appendf(self: &String, format: string, arguments: (i64, u64, i64)) {
            #anonymous {
                #anonymous {
                    args : [3]^Printable = default
                    {
                        {
                            i : u0 : 0
                            v : i64 = arguments[0]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                        {
                            i : u0 : 1
                            v : u64 = arguments[1]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                        {
                            i : u0 : 2
                            v : i64 = arguments[2]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                    }
                }
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
        /* T = (type, (u64, u64)) */
        /*  */
        appendf(self: &String, format: string, arguments: (u64, u64)) {
            #anonymous {
                #anonymous {
                    args : [2]^Printable = default
                    {
                        {
                            i : u0 : 0
                            v : u64 = arguments[0]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                        {
                            i : u0 : 1
                            v : u64 = arguments[1]
                            {
                                #anonymous {
                                    *get_index(&args, i) = cast(^Printable) (^v)
                                }
                            }
                        }
                    }
                }
            }
            self.append_printables(format, cast([]^Printable) (args))
        }
    
    
    append_printables(self: &String, format: string, args: []^Printable) {
        formatSpecifier : String = {
            len : u0 : 64
            mem : []u8 = @alloca(u8, len)
            @tempvar_213((String).from_raw_ptr((mem).data, (mem).length))
        }
        state : i64 = 0
        argIndex : i64 = 0
        #macro {
            local arr : string = format
            
            bytes : []u8 = (arr).bytes
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (bytes).length) then break else {}
                    @id((it, len)_112) : (char32, i32) = (Utf8).decode(get_range(bytes, new Range[i64] { start = it_index, end = (bytes).length }))
                    it : char32 = @var(@id((it, len)_112))[0]
                    len : i32 = @var(@id((it, len)_112))[1]
                    #link #anonymous {
                        c : char32 = it
                        it_index : i64 = it_index
                        {
                            if (state == 0) {
                                if (c == '``') {
                                    state = 2
                                } else if (c == '{') {
                                    state = 1
                                } else {
                                    append_char(self, c)
                                }
                            } else if (state == 2) {
                                append_char(self, c)
                                state = 0
                            } else if (state == 1) {
                                if (c == '}') {
                                    state = 0
                                    format : string = ""
                                    colon : i64 = &formatSpecifier.index_of(':')
                                    if (colon >= 1) {
                                        argIndex = (fmt).parse_int(&formatSpecifier.sliceL(colon))
                                    } else if ((colon == -1) and ((formatSpecifier).length > 0)) {
                                        argIndex = (fmt).parse_int(&formatSpecifier.slice())
                                    } else {}
                                    if (colon != -1) {
                                        format = &formatSpecifier.sliceF((colon + 1))
                                    } else {}
                                    if (argIndex >= (args).length) {
                                        (C).printf("[%lld] `"%.*s`": arg index to out of bounds: %lld, args: %lld`n", it_index, ((format).bytes).length, ((format).bytes).data, argIndex, (args).length)
                                        @destruct(formatSpecifier);
                                        return
                                    } else {}
                                    *get_index(args, argIndex).print(self, format)
                                    argIndex = (argIndex + 1)
                                    (formatSpecifier).length = 0
                                } else {
                                    append_char(&formatSpecifier, c)
                                }
                            } else {}
                        }
                    }
                    it_index = (it_index + cast(i64) (len))
                }
            }
        }
        @destruct(formatSpecifier)
    }
    
    format(format: string, args: $T) -> Self {
        s :  = (Self).empty()
        (s).appendf(format, args)
        return s
    }
    
    split_at_char(self: &String, c: char32, remove_empty: bool = false) -> Array[string] {
        result : Array[string] = (Array[string]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        start : i64 = 0
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = length }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_113) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_113))[0]
                it_index : i64 = @var(@id((it, it_index)_113))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            if (*get_index(data, i) == cast(u8) (c)) {
                                sub : string = self.sliceFT(start, i)
                                if ((((sub).bytes).length > 0) or !remove_empty) {
                                    &result.add(sub)
                                } else {}
                                start = (i + 1)
                            } else {}
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        if (start < length) {
            sub : string = self.sliceF(start)
            if ((((sub).bytes).length > 0) or !remove_empty) {
                &result.add(sub)
            } else {}
        } else {}
        return result
    }
}

StringLineIterator :: struct { // size: 16, alignment: 8
    remaining : string
}

for_extension_string_line_iterator :: for_extension_string_line_iterator(self: StringLineIterator, body: Code) #for {
    it_index :  = 0
    bytes :  = ((self).remaining).bytes
    loop {
        if ((bytes).length <= 0) then break
        defer {
            it_index = 1
        }
        line_end :  = -1
        for c, i : bytes {
            if (char(c) == '`0') {
                line_end = i
                break
            }
        }
        if (line_end == -1) {
            line_end = (bytes).length
        }
        line :  = bytes[0..line_end]
        bytes = bytes[(line_end + 1)..(bytes).length]
        it :  = string((line).data, (line).length)
        @insert(body)
    }
}

StringSplitCharIterator :: struct { // size: 24, alignment: 8
    remaining : string
    split_at : char32
    remove_empty : bool
}

impl StringSplitCharIterator {
    to_array(self: StringSplitCharIterator) -> Array[string] {
        result : Array[string] = (Array[string]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        #macro {
            local self : StringSplitCharIterator = self
            
            it_index : i64 = 0
            loop {
                if !((((self).remaining).bytes).length > 0) then break else {}
                index : i64 = (self).remaining.index_of((self).split_at)
                it : string = if (index < 0) {
                    (self).remaining <- ""
                } else {
                    tmp : string = get_range_to((self).remaining, new RangeTo[i64] { end = index })
                    (self).remaining = get_range_from((self).remaining, new RangeFrom[i64] { start = (index + 1) })
                    tmp
                }
                if (((it).bytes).length != 0) {
                    #link #anonymous {
                        part : string = it
                        it_index : i64 = it_index
                        {
                            &result.add(part)
                        }
                    }
                    it_index = (it_index + 1)
                } else {}
            }
        }
        return result
    }
}

for_extension_string_split_char_iterator :: for_extension_string_split_char_iterator(self: StringSplitCharIterator, body: Code) #for {
    it_index :  = 0
    loop {
        if !((((self).remaining).bytes).length > 0) then break
        index :  = ((self).remaining).index_of((self).split_at)
        it :  = if (index < 0) {
            (self).remaining <- ""
        } else {
            tmp :  = (self).remaining[..index]
            (self).remaining = (self).remaining[(index + 1)..]
            tmp
        }
        if (((it).bytes).length != 0) {
            @insert(body)
            it_index = 1
        }
    }
}

impl Printable for String {
    print(self: &String, str: &String, format: string) {
        append(str, self)
    }
}

streql : (a: $T, b: $T2, len: int) -> bool : streql(a: $T, b: $T2, len: int) -> bool {
    alen :  = (T).get_length(a)
    blen :  = (T2).get_length(b)
    if (len > alen) {
        len = alen
    }
    if (len > blen) {
        len = blen
    }
    for i : 0..len {
        if ((T).char_at(a, i) != (T2).char_at(b, i)) {
            return false
        }
    }
    return true
}

streq : (a: $T, b: $T2) -> bool : streq(a: $T, b: $T2) -> bool {
    len :  = (T).get_length(a)
    blen :  = (T2).get_length(b)
    if (len != blen) {
        return false
    }
    for i : 0..len {
        if ((T).char_at(a, i) != (T2).char_at(b, i)) {
            return false
        }
    }
    return true
}
// Polymorphic instances for streq(a: $T, b: $T2) -> bool
    /* T = (type, string), T2 = (type, string) */
    /*  */
    streq(a: string, b: string) -> bool {
        len : i64 = (string).get_length(a)
        blen : i64 = (string).get_length(b)
        if (len != blen) {
            return false
        } else {}
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = len }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_437) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_437))[0]
                it_index : i64 = @var(@id((it, it_index)_437))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            if ((string).char_at(a, i) != (string).char_at(b, i)) {
                                #anonymous {
                                    it_index = (it_index + 1)
                                    it = (it + inc)
                                };
                                return false
                            } else {}
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        return true
    }


streq_string :: streq_string(a: string, b: string) -> bool {
    return streq(a, b)
}

impl string {
    get_length(self: string) -> i64 {
        return ((self).bytes).length
    }
    
    char_at(self: string, i: i64) -> char32 {
        return cast(char32) (*get_index(self, i))
    }
    
    to_string(self: string) -> String {
        return (String).from_string(self, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    }
    
    to_owned(self: string) -> String {
        return (String).from_string(self, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    }
    
    slice(self: string, from: i64 = 0, length: i64 = -1) -> string {
        if (length < 0) {
            length = (((self).bytes).length - from)
        } else {}
        result : string = @string_from_ptr_and_length((util).pointer_add_sized(((self).bytes).data, from), length)
        return result
    }
    
    lines(self: string) -> StringLineIterator {
        return new StringLineIterator { remaining = self }
    }
    
    split_at_char(self: string, c: char32, remove_empty: bool = false) -> StringSplitCharIterator {
        return new StringSplitCharIterator { remaining = self, split_at = c, remove_empty = remove_empty }
    }
    
    starts_with(self: string, prefix: string) -> bool {
        self_bytes : []u8 = (self).bytes
        pref_bytes : []u8 = (prefix).bytes
        if ((pref_bytes).length > (self_bytes).length) {
            return false
        } else {}
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = (pref_bytes).length }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_115) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_115))[0]
                it_index : i64 = @var(@id((it, it_index)_115))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            if (*get_index(self_bytes, i) != *get_index(pref_bytes, i)) {
                                #anonymous {
                                    it_index = (it_index + 1)
                                    it = (it + inc)
                                };
                                return false
                            } else {}
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        return true
    }
    
    ends_with(self: string, postfix: string) -> bool {
        self_bytes : []u8 = (self).bytes
        post_bytes : []u8 = (postfix).bytes
        if ((post_bytes).length > (self_bytes).length) {
            return false
        } else {}
        offset : i64 = ((self_bytes).length - (post_bytes).length)
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = (post_bytes).length }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_117) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_117))[0]
                it_index : i64 = @var(@id((it, it_index)_117))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            if (*get_index(self_bytes, (offset + i)) != *get_index(post_bytes, i)) {
                                #anonymous {
                                    it_index = (it_index + 1)
                                    it = (it + inc)
                                };
                                return false
                            } else {}
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        return true
    }
    
    sub_string(self: string, from_byte: i64, to_byte: i64 = -1) -> string {
        if (to_byte == -1) {
            to_byte = ((self).bytes).length
        } else {}
        @assert(((((from_byte >= 0) and (from_byte <= ((self).bytes).length)) and (from_byte <= to_byte)) and (to_byte <= ((self).bytes).length)))
        sub_bytes : []u8 = get_range((self).bytes, new Range[i64] { start = from_byte, end = to_byte })
        return @string_from_ptr_and_length((sub_bytes).data, (sub_bytes).length)
    }
    
    trim(self: string) -> string {
        if (((self).bytes).length == 0) {
            return ""
        } else {}
        start : i64 = -1
        end : i64 = -1
        #macro {
            local arr : []u8 = (self).bytes
            
            local reverse : bool : false
            local by_ref : bool : false
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : u8 = *get_index(arr, it_index)
                        #link #anonymous {
                            it : u8 = it
                            it_index : i64 = it_index
                            {
                                c : char32 = cast(char32) (it)
                                if !(char).is_whitespace(c) {
                                    if (start == -1) {
                                        start = it_index
                                    } else {}
                                    end = it_index
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        if ((start == -1) and (end == -1)) {
            return ""
        } else {}
        end = (end + 1)
        @assert(((((start >= 0) and (start < ((self).bytes).length)) and (start <= end)) and (end <= ((self).bytes).length)))
        return self.sub_string(start, end)
    }
    
    contains(self: string, ch: char32) -> bool {
        #macro {
            local arr : string = self
            
            bytes : []u8 = (arr).bytes
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (bytes).length) then break else {}
                    @id((it, len)_120) : (char32, i32) = (Utf8).decode(get_range(bytes, new Range[i64] { start = it_index, end = (bytes).length }))
                    it : char32 = @var(@id((it, len)_120))[0]
                    len : i32 = @var(@id((it, len)_120))[1]
                    #link #anonymous {
                        c : char32 = it
                        it_index : i64 = it_index
                        {
                            if (c == ch) {
                                return true
                            } else {}
                        }
                    }
                    it_index = (it_index + cast(i64) (len))
                }
            }
        }
        return false
    }
    
    count_char(self: string, ch: char32) -> i64 {
        count : i64 = 0
        #macro {
            local arr : string = self
            
            bytes : []u8 = (arr).bytes
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (bytes).length) then break else {}
                    @id((it, len)_121) : (char32, i32) = (Utf8).decode(get_range(bytes, new Range[i64] { start = it_index, end = (bytes).length }))
                    it : char32 = @var(@id((it, len)_121))[0]
                    len : i32 = @var(@id((it, len)_121))[1]
                    #link #anonymous {
                        c : char32 = it
                        it_index : i64 = it_index
                        {
                            if (c == ch) {
                                count = (count + 1)
                            } else {}
                        }
                    }
                    it_index = (it_index + cast(i64) (len))
                }
            }
        }
        return count
    }
    
    index_of(self: string, ch: char32) -> i64 {
        bytes : []u8 = (self).bytes
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = (bytes).length }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_122) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_122))[0]
                it_index : i64 = @var(@id((it, it_index)_122))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            if (*get_index(bytes, i) == cast(u8) (ch)) {
                                #anonymous {
                                    it_index = (it_index + 1)
                                    it = (it + inc)
                                };
                                return i
                            } else {}
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        return -1
    }
    
    last_index_of(self: string, ch: char32) -> i64 {
        @id((ch_bytes, ch_len)_124) : ([4]u8, i32) = (Utf8).encode(ch)
        ch_bytes : [4]u8 = @var(@id((ch_bytes, ch_len)_124))[0]
        ch_len : i32 = @var(@id((ch_bytes, ch_len)_124))[1]
        #macro {
            local r : Range[i64] = new Range[i64] { start = (((self).bytes).length - cast(i64) (ch_len)), end = 0 }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_125) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_125))[0]
                it_index : i64 = @var(@id((it, it_index)_125))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        @set_break_and_continue(outer)
                        {
                            #macro {
                                local r : Range[i64] = new Range[i64] { start = 0, end = cast(i64) (ch_len) }
                                
                                rev : bool = ((r).end < (r).start)
                                inc : i64 = if rev then -1 else 1
                                
                                {
                                    @id((it, it_index)_127) : (i64, i64) = ((r).start, 0)
                                    it : i64 = @var(@id((it, it_index)_127))[0]
                                    it_index : i64 = @var(@id((it, it_index)_127))[1]
                                    loop {
                                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                                        defer #anonymous {
                                            it_index = (it_index + 1)
                                            it = (it + inc)
                                        }
                                        #link #anonymous {
                                            k : i64 = it
                                            it_index : i64 = it_index
                                            {
                                                if (*get_index((self).bytes, (i + k)) != *get_index(&ch_bytes, k)) then #anonymous {
                                                    it_index = (it_index + 1)
                                                    it = (it + inc)
                                                };
                                                #anonymous {
                                                    it_index = (it_index + 1)
                                                    it = (it + inc)
                                                };
                                                continue else {}
                                            }
                                        }
                                        #anonymous {
                                            it_index = (it_index + 1)
                                            it = (it + inc)
                                        }
                                    }
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            };
                            return i
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        return -1
    }
    
    index_of_string(self: string, str: string) -> i64 {
        if (((str).bytes).length == 0) {
            return 0
        } else {}
        bytes : []u8 = (self).bytes
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = ((self).bytes).length }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_129) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_129))[0]
                it_index : i64 = @var(@id((it, it_index)_129))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        @set_break_and_continue(outer)
                        {
                            #macro {
                                local r : Range[i64] = new Range[i64] { start = 0, end = ((str).bytes).length }
                                
                                rev : bool = ((r).end < (r).start)
                                inc : i64 = if rev then -1 else 1
                                
                                {
                                    @id((it, it_index)_131) : (i64, i64) = ((r).start, 0)
                                    it : i64 = @var(@id((it, it_index)_131))[0]
                                    it_index : i64 = @var(@id((it, it_index)_131))[1]
                                    loop {
                                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                                        defer #anonymous {
                                            it_index = (it_index + 1)
                                            it = (it + inc)
                                        }
                                        #link #anonymous {
                                            k : i64 = it
                                            it_index : i64 = it_index
                                            {
                                                if (*get_index(self, (i + k)) != *get_index(str, k)) then #anonymous {
                                                    it_index = (it_index + 1)
                                                    it = (it + inc)
                                                };
                                                #anonymous {
                                                    it_index = (it_index + 1)
                                                    it = (it + inc)
                                                };
                                                continue else {}
                                            }
                                        }
                                        #anonymous {
                                            it_index = (it_index + 1)
                                            it = (it + inc)
                                        }
                                    }
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            };
                            return i
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        return -1
    }
    
    to_cstring(self: string) -> ^char8 {
        str_c : ^char8 = alloc_raw(cast ((((self).bytes).length + 1)), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        str_c[((self).bytes).length] = cast (0)
        (C).memcpy(cast (str_c), cast (((self).bytes).data), cast (((self).bytes).length))
        return str_c
    }
    
    to_utf16(self: string) -> Result[Array[u16], ()] {
        #anonymous {
            required_size : i32 = MultiByteToWideChar(CP_UTF8, 0, ((self).bytes).data, cast (((self).bytes).length), null, 0)
            wide_char_str : Array[u16] = (Array[u16]).create(cast ((required_size + 1)), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            &wide_char_str.resize(cast(i64) (required_size))
            *&wide_char_str.access_unchecked(cast(i64) (required_size)) = 0
            bytes_written : i32 = MultiByteToWideChar(CP_UTF8, 0, ((self).bytes).data, cast (((self).bytes).length), &wide_char_str.get_raw(), required_size)
            if (bytes_written < required_size) {
                @assert(false)
                @destruct(wide_char_str);
                return Result[Array[u16], ()].Err(())
            } else {}
            return Result[Array[u16], ()].Ok(wide_char_str)
        }
    }
}

impl Into[String] for string {
    into(self: &string) -> String {
        return *self.to_owned()
    }
}

impl char32 {
    is_whitespace(self: char32) -> bool {
        return match @tempvar_214(self) {
            ' ' -> true
            '`t' -> true
            '`r' -> true
            '`n' -> true
            _ -> false
        }
    }
    
    is_alpha(self: char32) -> bool {
        return (((self >= 'a') and (self <= 'z')) or ((self >= 'A') and (self <= 'Z')))
    }
    
    is_digit(self: char32) -> bool {
        return ((self >= '0') and (self <= '9'))
    }
    
    is_bin_digit(self: char32) -> bool {
        return ((self >= '0') and (self <= '1'))
    }
    
    is_hex_digit(self: char32) -> bool {
        return ((((self >= '0') and (self <= '9')) or ((self >= 'a') and (self <= 'f'))) or ((self >= 'A') and (self <= 'F')))
    }
}

impl ^char8 {
    get_length(self: ^char8) -> i64 {
        return cast ((C).strlen(self))
    }
    
    char_at(self: ^char8, i: i64) -> char32 {
        return cast(char32) (self[i])
    }
    
    to_string(self: ^char8) -> String {
        return (String).from_cstring(self, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    }
}

for_extension_string_builtin :: for_extension_string_builtin(arr: string, code: Code) #for {
    bytes :  = (arr).bytes
    {
        it_index :  = 0
        loop {
            if !(it_index < (bytes).length) then break
            (it, len) :  = (Utf8).decode(bytes[it_index..(bytes).length])
            @insert(code, _break = break, _continue = continue)
            it_index = int(len)
        }
    }
}

#file time.che
import std.os.windows

use import std.os.windows_functions

get_time_microseconds :: get_time_microseconds() -> i64 {
    #anonymous {
        freq : i64 = 1
        QueryPerformanceFrequency(^freq)
        time : i64 = 0
        QueryPerformanceCounter(^time)
        time = (time * 1000000)
        time = (time / freq)
        return time
    }
    #anonymous {}
}

get_time_milliseconds :: get_time_milliseconds() -> i64 {
    #anonymous {
        freq : i64 = 1
        QueryPerformanceFrequency(^freq)
        time : i64 = 0
        QueryPerformanceCounter(^time)
        time = (time * 1000000)
        time = (time / freq)
        return (time / 1000)
    }
    #anonymous {}
}

#file clap.che
use import std.array

use import std.string

use import std.mem.allocator

use import std.util

fs :  : import std.io.fs

io :  : import std.io

fmt :  : import std.fmt

C :  : import std.c

use import std.os.windows_functions

console_debug_print : bool : false

indent_size : u0 : 2

Clap :: struct { // size: 0, alignment: 1
    
}

parse_arguments_from_string : ($T: type, str: string) -> ^T : parse_arguments_from_string($T: type, str: string) -> ^T {
    args :  = (Array[String]).create()
    State :  : enum<> { // size: , alignment: 
        Unquoted : 
        Whitespace : 
        Escaped : 
        Quoted : 
    }
    use State
    state :  = Whitespace
    start :  = 0
    current :  = (String).empty()
    for c : str {
        match (state, c) {
            (Escaped, $c) -> {
                state = Quoted
                current = c
            }
            (Unquoted, $c) if (char).is_whitespace(c) -> {
                (args).add((current).clone())
                (current).clear()
                state = Whitespace
            }
            (Unquoted, $c) -> {
                current = c
            }
            (Whitespace, '`0') -> {
                state = Quoted
            }
            (Whitespace, $c) if !(char).is_whitespace(c) -> {
                current = c
                state = Unquoted
            }
            (Quoted, '`0') -> {
                (args).add((current).clone())
                (current).clear()
                state = Whitespace
            }
            (Quoted, '`0') -> {
                state = Escaped
            }
            (Quoted, $c) -> {
                current = c
            }
        }
    }
    if (state == Unquoted) {
        (args).add((current).clone())
        (current).clear()
    }
    return parse_arguments(T, (args).slice())
}

parse_arguments : ($T: type, args: []String) -> ^T : parse_arguments($T: type, args: []String) -> ^T {
    result :  = alloc(T)
    ok :  = parse_arguments_help(@type_info(T), &args, result)
    if !ok {
        (Memory).drop(*result)
        free(result)
        return null
    }
    return result
}
// Polymorphic instances for parse_arguments($T: type, args: []String) -> ^T
    /*  */
    /* T = MainCommand */
    parse_arguments(args: []String) -> ^MainCommand {
        result : ^MainCommand = alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        ok : bool = parse_arguments_help(@type_info(MainCommand), &args, result)
        if !ok {
            (Memory).drop(*result)
            free(result, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            return null
        } else {}
        return result
    }


get_cmd_args :: get_cmd_args() -> Array[String] {
    #anonymous {
        cmdLineArgs : ^u16 = GetCommandLineW()
        count : i32 = 0i32
        args : ^^u16 = CommandLineToArgvW(cmdLineArgs, ^count)
        return to_ascii_strings(args, cast(i64) (count))
    }
    #anonymous {}
}

get_help_message :: get_help_message(type_info: ^TypeInfo) -> String {
    result : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    append_string(&result, "Usage:`n")
    get_help_message_helper(type_info, &result, indent_size)
    return result
}

parse_arguments_help : (type_info: ^TypeInfo, args: &[]String, result: ^$T) -> bool : parse_arguments_help(type_info: ^TypeInfo, args: &[]String, result: ^$T) -> bool {
    if console_debug_print {
        (io).formatln("parsing help: {}", [(type_info).kind])
        log_args(args)
    }
    require_arg :  : (args: ) ->  {
        if ((args).length < 1) {
            (io).println("[ERROR] missing required argument for option")
            return false
        }
        return true
    }
    return match &*type_info {
        _ if (type_info == @type_info(String)) -> {
            if !require_arg(*args) {
                return false
            }
            *cast() (result) = (args[0]).clone()
            *args = args[1..]
            true
        }
        _ if (type_info == @type_info(Array[String])) -> parse_arguments_string_array(args, result)
        _ if (type_info == @type_info(Option[String])) -> {
            temp :  = @alloca(String, 1)
            parse_arguments_help(@type_info(String), args, (temp).data)
            *cast() (result) = Some(*(temp).data)
            true
        }
        TypeInfoEnum($info) -> parse_arguments_enum(^*info, args, result)
        TypeInfoStruct($info) -> parse_arguments_struct(^*info, args, result)
        TypeInfoInt(_) -> {
            if !require_arg(*args) {
                return false
            }
            *cast() (result) = (fmt).parse_int((args[0]).slice())
            *args = args[1..]
            true
        }
        TypeInfoBool(_) -> {
            *cast() (result) = true
            true
        }
        _ -> {
            (io).printfln("[ERROR] Can't parse into type {}", @typename(T))
            false
        }
    }
}
// Polymorphic instances for parse_arguments_help(type_info: ^TypeInfo, args: &[]String, result: ^$T) -> bool
    /* T = (type, void) */
    /*  */
    parse_arguments_help(type_info: ^TypeInfo, args: &[]String, result: ^void) -> bool {
        #anonymous {}
        require_arg :: require_arg(args: []String) -> bool {
            if ((args).length < 1) {
                (io).println("[ERROR] missing required argument for option")
                return false
            } else {}
            return true
        }
        return match @tempvar_746(&*type_info) {
            _ if (cast(^void) (type_info) == cast(^void) (@type_info(String))) -> {
                if !require_arg(*args) {
                    return false
                } else {}
                *cast(^String) (result) = get_index(*args, 0).clone()
                *args = get_range_from(*args, new RangeFrom[i64] { start = 1 })
                true
            }
            _ if (cast(^void) (type_info) == cast(^void) (@type_info(Array[String]))) -> parse_arguments_string_array(args, result)
            _ if (cast(^void) (type_info) == cast(^void) (@type_info(Option[String]))) -> {
                temp : []String = @alloca(String, 1)
                parse_arguments_help(@type_info(String), args, (temp).data)
                *cast(^Option[String]) (result) = Option[String].Some(*(temp).data)
                true
            }
            TypeInfoEnum($info) -> parse_arguments_enum(^*info, args, result)
            TypeInfoStruct($info) -> parse_arguments_struct(^*info, args, result)
            TypeInfoInt(_) -> {
                if !require_arg(*args) {
                    return false
                } else {}
                *cast(^i64) (result) = (fmt).parse_int(get_index(*args, 0).slice())
                *args = get_range_from(*args, new RangeFrom[i64] { start = 1 })
                true
            }
            TypeInfoBool(_) -> {
                *cast(^bool) (result) = true
                true
            }
            _ -> {
                (io).printfln("[ERROR] Can't parse into type {}", "void")
                false
            }
        }
    }
    /* T = (type, MainCommand) */
    /*  */
    parse_arguments_help(type_info: ^TypeInfo, args: &[]String, result: ^MainCommand) -> bool {
        #anonymous {}
        require_arg :: require_arg(args: []String) -> bool {
            if ((args).length < 1) {
                (io).println("[ERROR] missing required argument for option")
                return false
            } else {}
            return true
        }
        return match @tempvar_817(&*type_info) {
            _ if (cast(^void) (type_info) == cast(^void) (@type_info(String))) -> {
                if !require_arg(*args) {
                    return false
                } else {}
                *cast(^String) (result) = get_index(*args, 0).clone()
                *args = get_range_from(*args, new RangeFrom[i64] { start = 1 })
                true
            }
            _ if (cast(^void) (type_info) == cast(^void) (@type_info(Array[String]))) -> parse_arguments_string_array(args, cast(^void) (result))
            _ if (cast(^void) (type_info) == cast(^void) (@type_info(Option[String]))) -> {
                temp : []String = @alloca(String, 1)
                parse_arguments_help(@type_info(String), args, (temp).data)
                *cast(^Option[String]) (result) = Option[String].Some(*(temp).data)
                true
            }
            TypeInfoEnum($info) -> parse_arguments_enum(^*info, args, cast(^void) (result))
            TypeInfoStruct($info) -> parse_arguments_struct(^*info, args, cast(^void) (result))
            TypeInfoInt(_) -> {
                if !require_arg(*args) {
                    return false
                } else {}
                *cast(^i64) (result) = (fmt).parse_int(get_index(*args, 0).slice())
                *args = get_range_from(*args, new RangeFrom[i64] { start = 1 })
                true
            }
            TypeInfoBool(_) -> {
                *cast(^bool) (result) = true
                true
            }
            _ -> {
                (io).printfln("[ERROR] Can't parse into type {}", "MainCommand")
                false
            }
        }
    }
    /* T = (type, String) */
    /*  */
    parse_arguments_help(type_info: ^TypeInfo, args: &[]String, result: ^String) -> bool {
        #anonymous {}
        require_arg :: require_arg(args: []String) -> bool {
            if ((args).length < 1) {
                (io).println("[ERROR] missing required argument for option")
                return false
            } else {}
            return true
        }
        return match @tempvar_822(&*type_info) {
            _ if (cast(^void) (type_info) == cast(^void) (@type_info(String))) -> {
                if !require_arg(*args) {
                    return false
                } else {}
                *result = get_index(*args, 0).clone()
                *args = get_range_from(*args, new RangeFrom[i64] { start = 1 })
                true
            }
            _ if (cast(^void) (type_info) == cast(^void) (@type_info(Array[String]))) -> parse_arguments_string_array(args, cast(^void) (result))
            _ if (cast(^void) (type_info) == cast(^void) (@type_info(Option[String]))) -> {
                temp : []String = @alloca(String, 1)
                parse_arguments_help(@type_info(String), args, (temp).data)
                *cast(^Option[String]) (result) = Option[String].Some(*(temp).data)
                true
            }
            TypeInfoEnum($info) -> parse_arguments_enum(^*info, args, cast(^void) (result))
            TypeInfoStruct($info) -> parse_arguments_struct(^*info, args, cast(^void) (result))
            TypeInfoInt(_) -> {
                if !require_arg(*args) {
                    return false
                } else {}
                *cast(^i64) (result) = (fmt).parse_int(get_index(*args, 0).slice())
                *args = get_range_from(*args, new RangeFrom[i64] { start = 1 })
                true
            }
            TypeInfoBool(_) -> {
                *cast(^bool) (result) = true
                true
            }
            _ -> {
                (io).printfln("[ERROR] Can't parse into type {}", "String")
                false
            }
        }
    }


parse_arguments_string_array :: parse_arguments_string_array(args: &[]String, result: ^void) -> bool {
    #anonymous {}
    array : ^Array[String] = cast(^Array[String]) (result)
    *array = (Array[String]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    loop {
        if !((*args).length > 0) then break else {}
        arg : &String = get_index(*args, 0)
        @assert(((*arg).length > 0))
        if (char_at(&*arg, 0) == '-') {
            return true
        } else {}
        &*array.add(arg.clone())
        *args = get_range_from(*args, new RangeFrom[i64] { start = 1 })
    }
    return true
}

parse_arguments_enum :: parse_arguments_enum(type_info: ^TypeInfoEnum, args: &[]String, result: ^void) -> bool {
    #anonymous {}
    if ((*args).length == 0) {
        (io).println("[ERROR] Missing command. Possible commands:")
        #macro {
            local arr : []TypeInfoEnumMember = (*type_info).members
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : &TypeInfoEnumMember = get_index(arr, it_index)
                        #link #anonymous {
                            it : &TypeInfoEnumMember = it
                            it_index : i64 = it_index
                            {
                                (io).printfln("  {}", get_display_name_for_member(it))
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return false
    } else {}
    command : &String = get_index(*args, 0)
    *args = get_range_from(*args, new RangeFrom[i64] { start = 1 })
    #macro {
        local arr : []TypeInfoEnumMember = (*type_info).members
        
        local reverse : bool : false
        local by_ref : bool : true
        {
            it_index : i64 = 0
            loop {
                if !(it_index < (arr).length) then break else {}
                defer it_index = (it_index + 1)
                #anonymous {
                    it : &TypeInfoEnumMember = get_index(arr, it_index)
                    #link #anonymous {
                        mem : &TypeInfoEnumMember = it
                        it_index : i64 = it_index
                        {
                            mem_name : string = get_display_name_for_member(mem)
                            if streq(command.slice(), mem_name) {
                                tag_ptr : ^i64 = cast(^i64) (result)
                                *tag_ptr = (*mem).tag
                                if (cast(^void) ((*mem).typ) != null) {
                                    tag_size : i64 = (*(*type_info).tag_type).size
                                    value_ptr : ^void = pointer_add(result, tag_size)
                                    if !parse_arguments_help((*mem).typ, args, value_ptr) {
                                        it_index = (it_index + 1);
                                        return false
                                    } else {}
                                } else {}
                                it_index = (it_index + 1);
                                return true
                            } else {}
                        }
                    }
                }
                it_index = (it_index + 1)
            }
        }
    }
    (C).puts("3")
    (io).printfln("[ERROR] Unknown command: {}", command.slice())
    (C).puts("4")
    return false
}

parse_arguments_struct :: parse_arguments_struct(type_info: ^TypeInfoStruct, args: &[]String, result: ^void) -> bool {
    #anonymous {}
    MemberInfo :: (string, ^TypeInfoStructMember, bool) = (name: string, mem: ^TypeInfoStructMember, set: bool)
    members : Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] = (Array[MemberInfo]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    #macro {
        local arr : []TypeInfoStructMember = (*type_info).members
        
        local reverse : bool : false
        local by_ref : bool : true
        {
            it_index : i64 = 0
            loop {
                if !(it_index < (arr).length) then break else {}
                defer it_index = (it_index + 1)
                #anonymous {
                    it : &TypeInfoStructMember = get_index(arr, it_index)
                    #link #anonymous {
                        m : &TypeInfoStructMember = it
                        it_index : i64 = it_index
                        {
                            mem_name : string = get_display_name_for_member(m)
                            if m.has_attribute("ignore") {
                                it_index = (it_index + 1);
                                continue
                            } else {}
                            &members.add((mem_name, ^*m, false))
                        }
                    }
                }
                it_index = (it_index + 1)
            }
        }
    }
    get_member :: get_member(arr: &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)], name: string) -> ^(name: string, mem: ^TypeInfoStructMember, set: bool) {
        #macro {
            local arr : &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] = arr
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &(name: string, mem: ^TypeInfoStructMember, set: bool) = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            it : &(name: string, mem: ^TypeInfoStructMember, set: bool) = it
                            it_index : i64 = it_index
                            {
                                if streq((*it).name, name) {
                                    it_index = (it_index + 1);
                                    return ^*it
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return null
    }
    loop {
        if !((*args).length > 0) then break else {}
        arg : &String = get_index(*args, 0)
        @assert(((*arg).length > 0))
        *args = get_range_from(*args, new RangeFrom[i64] { start = 1 })
        if (char_at(&*arg, 0) == '-') {
            name : string = arg.sliceF(1)
            mem_info : ^(name: string, mem: ^TypeInfoStructMember, set: bool) = get_member(&members, name)
            if (cast(^void) (mem_info) == null) {
                (io).printfln("[ERROR] unknown argument '{}'", name)
                @destruct(members);
                return false
            } else {}
            if (*mem_info).set {
                (io).printfln("[ERROR] option '{}' was already specified", (*mem_info).name)
            } else {}
            if !parse_arguments_help((*(*mem_info).mem).typ, args, pointer_add(result, (*(*mem_info).mem).offset)) {
                @destruct(members);
                return false
            } else {}
            (*mem_info).set = true
        } else {
            (io).printfln("[CLP] Error: not implemented, arg: {}", arg.slice())
            @assert(false, "Not implemented")
            @destruct(members);
            return false
        }
    }
    #macro {
        local arr : &Array[(name: string, mem: ^TypeInfoStructMember, set: bool)] = &members
        
        local reverse : bool : false
        local by_ref : bool : true
        {
            it_index : i64 = 0
            loop {
                if !(it_index < arr.get_length()) then break else {}
                defer it_index = (it_index + 1)
                #anonymous {
                    #anonymous {
                        it : &(name: string, mem: ^TypeInfoStructMember, set: bool) = access(&*arr, it_index)
                    }
                    #link #anonymous {
                        mem_info : &(name: string, mem: ^TypeInfoStructMember, set: bool) = it
                        it_index : i64 = it_index
                        {
                            if (*mem_info).set then it_index = (it_index + 1);
                            continue else {}
                            default_value : ^any = (*(*mem_info).mem).value
                            if (cast(^void) (@type_info_of_any(default_value)) == null) {
                                (io).printfln("[ERROR] please provide a value for option '{}'", (*(*mem_info).mem).name)
                                it_index = (it_index + 1);
                                @destruct(members);
                                return false
                            } else {}
                            if !assign_value_to_member((*mem_info).mem, pointer_add(result, (*(*mem_info).mem).offset), default_value) {
                                it_index = (it_index + 1);
                                @destruct(members);
                                return false
                            } else {}
                        }
                    }
                }
                it_index = (it_index + 1)
            }
        }
    }
    @destruct(members);
    return true
}

get_help_message_helper :: get_help_message_helper(type_info: ^TypeInfo, result: &String, indent: i64) {
    match @tempvar_11(&*type_info) {
        _ if (cast(^void) (^type_info) == cast(^void) (@type_info(String))) -> {
            indent_string(result, indent)
            append_string(result, "String")
        }
        _ if (cast(^void) (^type_info) == cast(^void) (@type_info(Array[String]))) -> {
            append_string(result, "Array[String]")
        }
        TypeInfoStruct($ti) -> get_help_message_struct(^*ti, result, indent)
        TypeInfoEnum($ti) -> get_help_message_enum(^*ti, result, indent)
    }
}

get_help_message_struct :: get_help_message_struct(type_info: ^TypeInfoStruct, result: &String, indent: i64) {
    old_indent : i64 = indent
    indent = (indent + indent_size)
    description_indent : i64 = {
        m : i64 = 0
        #macro {
            local arr : []TypeInfoStructMember = (*type_info).members
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : &TypeInfoStructMember = get_index(arr, it_index)
                        #link #anonymous {
                            mem : &TypeInfoStructMember = it
                            it_index : i64 = it_index
                            {
                                if ((((*mem).name).bytes).length > m) {
                                    m = (((*mem).name).bytes).length
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        next_aligned_num(((m + 1) + 8), indent_size)
    }
    #macro {
        local arr : []TypeInfoStructMember = (*type_info).members
        
        local reverse : bool : false
        local by_ref : bool : true
        {
            it_index : i64 = 0
            loop {
                if !(it_index < (arr).length) then break else {}
                defer it_index = (it_index + 1)
                #anonymous {
                    it : &TypeInfoStructMember = get_index(arr, it_index)
                    #link #anonymous {
                        mem : &TypeInfoStructMember = it
                        it_index : i64 = it_index
                        {
                            indent_string(result, indent)
                            mem_name : string = get_display_name_for_member(mem)
                            result.appendf("-{}", mem_name)
                            help_text_att : ^TypeInfoAttribute = mem.get_attribute("help")
                            if (cast(^void) (help_text_att) != null) {
                                @assert((((*help_text_att).args).length == 1))
                                @assert((cast(^void) (@type_info_of_any(get_index((*help_text_att).args, 0))) == cast(^void) (@type_info(string))))
                                text : String = (String).from_string(*cast(^string) (@ptr_of_any(get_index((*help_text_att).args, 0))), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                                lines : Array[string] = &text.split_at_char('`n', true)
                                #macro {
                                    local arr : &Array[string] = &lines
                                    
                                    local reverse : bool : false
                                    local by_ref : bool : true
                                    {
                                        it_index : i64 = 0
                                        loop {
                                            if !(it_index < arr.get_length()) then break else {}
                                            defer it_index = (it_index + 1)
                                            #anonymous {
                                                #anonymous {
                                                    it : &string = access(&*arr, it_index)
                                                }
                                                #link #anonymous {
                                                    line : &string = it
                                                    it_index : i64 = it_index
                                                    {
                                                        if (it_index == 0) {
                                                            indent_string(result, ((description_indent - ((mem_name).bytes).length) - 1))
                                                        } else {
                                                            append_string(result, "`n")
                                                            indent_string(result, (description_indent + indent))
                                                        }
                                                        append_string(result, *line)
                                                    }
                                                }
                                            }
                                            it_index = (it_index + 1)
                                        }
                                    }
                                }
                                @destruct(lines)
                                @destruct(text)
                            } else {}
                            append_string(result, "`n")
                        }
                    }
                }
                it_index = (it_index + 1)
            }
        }
    }
    if (((*type_info).members).length > 0) {
        append_string(result, "`n")
        #macro {
            local arr : []TypeInfoStructMember = (*type_info).members
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : &TypeInfoStructMember = get_index(arr, it_index)
                        #link #anonymous {
                            mem : &TypeInfoStructMember = it
                            it_index : i64 = it_index
                            {
                                mem_name : string = get_display_name_for_member(mem)
                                get_help_message_member(result, (*mem).typ, mem_name, "-{}: ", indent, ((description_indent - ((mem_name).bytes).length) - 3))
                                append_string(result, "`n")
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
    } else {}
}

get_help_message_enum :: get_help_message_enum(type_info: ^TypeInfoEnum, result: &String, indent: i64) {
    old_indent : i64 = indent
    indent = (indent + indent_size)
    description_indent : i64 = {
        m : i64 = 0
        #macro {
            local arr : []TypeInfoEnumMember = (*type_info).members
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : &TypeInfoEnumMember = get_index(arr, it_index)
                        #link #anonymous {
                            mem : &TypeInfoEnumMember = it
                            it_index : i64 = it_index
                            {
                                if ((((*mem).name).bytes).length > m) {
                                    m = (((*mem).name).bytes).length
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        next_aligned_num((m + 8), indent_size)
    }
    #macro {
        local arr : []TypeInfoEnumMember = (*type_info).members
        
        local reverse : bool : false
        local by_ref : bool : true
        {
            it_index : i64 = 0
            loop {
                if !(it_index < (arr).length) then break else {}
                defer it_index = (it_index + 1)
                #anonymous {
                    it : &TypeInfoEnumMember = get_index(arr, it_index)
                    #link #anonymous {
                        mem : &TypeInfoEnumMember = it
                        it_index : i64 = it_index
                        {
                            indent_string(result, indent)
                            mem_name : string = get_display_name_for_member(mem)
                            append_string(result, mem_name)
                            help_text_att : ^TypeInfoAttribute = mem.get_attribute("help")
                            if (cast(^void) (help_text_att) != null) {
                                @assert((((*help_text_att).args).length == 1))
                                @assert((cast(^void) (@type_info_of_any(get_index((*help_text_att).args, 0))) == cast(^void) (@type_info(string))))
                                text : String = (String).from_string(*cast(^string) (@ptr_of_any(get_index((*help_text_att).args, 0))), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                                lines : Array[string] = &text.split_at_char('`n', true)
                                #macro {
                                    local arr : &Array[string] = &lines
                                    
                                    local reverse : bool : false
                                    local by_ref : bool : true
                                    {
                                        it_index : i64 = 0
                                        loop {
                                            if !(it_index < arr.get_length()) then break else {}
                                            defer it_index = (it_index + 1)
                                            #anonymous {
                                                #anonymous {
                                                    it : &string = access(&*arr, it_index)
                                                }
                                                #link #anonymous {
                                                    line : &string = it
                                                    it_index : i64 = it_index
                                                    {
                                                        if (it_index == 0) {
                                                            indent_string(result, (description_indent - ((mem_name).bytes).length))
                                                        } else {
                                                            append_string(result, "`n")
                                                            indent_string(result, (description_indent + indent))
                                                        }
                                                        append_string(result, *line)
                                                    }
                                                }
                                            }
                                            it_index = (it_index + 1)
                                        }
                                    }
                                }
                                @destruct(lines)
                                @destruct(text)
                            } else {}
                            append_string(result, "`n")
                        }
                    }
                }
                it_index = (it_index + 1)
            }
        }
    }
    printed_details_string : bool = false
    #macro {
        local arr : []TypeInfoEnumMember = (*type_info).members
        
        local reverse : bool : false
        local by_ref : bool : true
        {
            it_index : i64 = 0
            loop {
                if !(it_index < (arr).length) then break else {}
                defer it_index = (it_index + 1)
                #anonymous {
                    it : &TypeInfoEnumMember = get_index(arr, it_index)
                    #link #anonymous {
                        mem : &TypeInfoEnumMember = it
                        it_index : i64 = it_index
                        {
                            if (cast(^void) ((*mem).typ) == null) then it_index = (it_index + 1);
                            continue else {}
                            if !printed_details_string {
                                append_string(result, "`n")
                                printed_details_string = true
                            } else {}
                            mem_name : string = get_display_name_for_member(mem)
                            get_help_message_member(result, (*mem).typ, mem_name, "{}: ", indent, ((description_indent - (((*mem).name).bytes).length) - 2))
                            append_string(result, "`n")
                        }
                    }
                }
                it_index = (it_index + 1)
            }
        }
    }
}

get_help_message_member :: get_help_message_member(result: &String, type_info: ^TypeInfo, name: string, format: string, indent: i64, indent2: i64) {
    match @tempvar_14(&*type_info) {
        $_ if (cast(^void) (type_info) == cast(^void) (@type_info(String))) -> {
            indent_string(result, indent)
            result.appendf(format, name)
            indent_string(result, indent2)
            append_string(result, "String")
        }
        $_ if (cast(^void) (type_info) == cast(^void) (@type_info(Array[String]))) -> {
            indent_string(result, indent)
            result.appendf(format, name)
            indent_string(result, indent2)
            append_string(result, "Array[String]")
        }
        TypeInfoStruct($ti) -> {
            if (((*ti).members).length > 0) {
                indent_string(result, indent)
                result.appendf(format, name)
                append_string(result, "`n")
                get_help_message_helper(type_info, result, (indent + indent_size))
            } else {}
        }
        TypeInfoEnum($ti) -> {
            if (((*ti).members).length > 0) {
                indent_string(result, indent)
                result.appendf(format, name)
                append_string(result, "`n")
                get_help_message_helper(type_info, result, (indent + indent_size))
            } else {}
        }
        $_ -> {
            indent_string(result, indent)
            result.appendf(format, name)
            indent_string(result, indent2)
        }
    }
}

assign_value_to_member :: assign_value_to_member(member: ^TypeInfoStructMember, result: ^void, value: ^any) -> bool {
    if (cast(^void) ((*member).typ) == cast(^void) (@type_info_of_any(value))) {
        (C).memcpy(result, @ptr_of_any(value), cast ((*(*member).typ).size))
        return true
    } else {}
    (io).printfln("[ERROR] can't assign a value of type ... to ...", ())
    return false
}

to_ascii_strings :: to_ascii_strings(argv: ^^u16, argc: i64) -> Array[String] {
    array : Array[String] = (Array[String]).create(argc, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    #macro {
        local r : Range[i64] = new Range[i64] { start = 0, end = argc }
        
        rev : bool = ((r).end < (r).start)
        inc : i64 = if rev then -1 else 1
        
        {
            @id((it, it_index)_16) : (i64, i64) = ((r).start, 0)
            it : i64 = @var(@id((it, it_index)_16))[0]
            it_index : i64 = @var(@id((it, it_index)_16))[1]
            loop {
                if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                defer #anonymous {
                    it_index = (it_index + 1)
                    it = (it + inc)
                }
                #link #anonymous {
                    i : i64 = it
                    it_index : i64 = it_index
                    {
                        str : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                        {
                            k : i64 = 0
                            loop {
                                if !(argv[i][k] != 0) then break else {}
                                defer k = (k + 1)
                                append_char(&str, cast(char32) (argv[i][k]))
                                k = (k + 1)
                            }
                        }
                        &array.add(str)
                    }
                }
                #anonymous {
                    it_index = (it_index + 1)
                    it = (it + inc)
                }
            }
        }
    }
    return array
}

indent_string :: indent_string(str: &String, amount: i64) {
    str.reserve_more(amount)
    #macro {
        local r : Range[i64] = new Range[i64] { start = 0, end = amount }
        
        rev : bool = ((r).end < (r).start)
        inc : i64 = if rev then -1 else 1
        
        {
            @id((it, it_index)_19) : (i64, i64) = ((r).start, 0)
            it : i64 = @var(@id((it, it_index)_19))[0]
            it_index : i64 = @var(@id((it, it_index)_19))[1]
            loop {
                if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                defer #anonymous {
                    it_index = (it_index + 1)
                    it = (it + inc)
                }
                #link #anonymous {
                    it : i64 = it
                    it_index : i64 = it_index
                    {
                        append_string(str, " ")
                    }
                }
                #anonymous {
                    it_index = (it_index + 1)
                    it = (it + inc)
                }
            }
        }
    }
}

get_display_name_for_member : (mem: &$T) -> string : get_display_name_for_member(mem: &$T) -> string {
    name_att :  = (mem).get_attribute("name")
    if (name_att == null) {
        return (mem).name
    }
    @assert((((name_att).args).length == 1))
    @assert((@type_info_of_any((name_att).args[0]) == @type_info(string)))
    name :  = *cast() (@ptr_of_any((name_att).args[0]))
    return name
}
// Polymorphic instances for get_display_name_for_member(mem: &$T) -> string
    /* T = (type, TypeInfoEnumMember) */
    /*  */
    get_display_name_for_member(mem: &TypeInfoEnumMember) -> string {
        name_att : ^TypeInfoAttribute = mem.get_attribute("name")
        if (cast(^void) (name_att) == null) {
            return (*mem).name
        } else {}
        @assert((((*name_att).args).length == 1))
        @assert((cast(^void) (@type_info_of_any(get_index((*name_att).args, 0))) == cast(^void) (@type_info(string))))
        name : string = *cast(^string) (@ptr_of_any(get_index((*name_att).args, 0)))
        return name
    }
    /* T = (type, TypeInfoStructMember) */
    /*  */
    get_display_name_for_member(mem: &TypeInfoStructMember) -> string {
        name_att : ^TypeInfoAttribute = mem.get_attribute("name")
        if (cast(^void) (name_att) == null) {
            return (*mem).name
        } else {}
        @assert((((*name_att).args).length == 1))
        @assert((cast(^void) (@type_info_of_any(get_index((*name_att).args, 0))) == cast(^void) (@type_info(string))))
        name : string = *cast(^string) (@ptr_of_any(get_index((*name_att).args, 0)))
        return name
    }


log_args :: log_args(args: []String) {}

#file logger.che
use import std.string

use import std.thread

use import std.rc

fmt :  : import std.fmt

io :  : import std.io

fs :  : import std.io.fs

CONSOLE_LOGGER : ConsoleLogger = new ConsoleLogger {  }

g_logger : ^Logger = cast(^Logger) (^CONSOLE_LOGGER)

Logger :: trait {
    log :: f.Accept(this)
}

impl Logger {
    set_global_logger(logger: ^Logger) {
        g_logger = logger
    }
}

ConsoleLogger :: struct { // size: 0, alignment: 1
    
}

impl Logger for ConsoleLogger {
    log(self: &ConsoleLogger, format: string, args: []^any = cast([]^any) ([]), prefix: string = "") {
        msg : String = (fmt).format(format, args)
        if strings_not_equal(prefix, "") {
            (io).formatln(cast(^any) ("[{}] [{}] {}"), cast([]^any) ([cast(^any) ((*(Thread).current()).id), cast(^any) (prefix), cast(^any) (msg)]))
        } else {
            (io).formatln(cast(^any) ("[{}] {}"), cast([]^any) ([cast(^any) ((*(Thread).current()).id), cast(^any) (msg)]))
        }
        @destruct(msg)
    }
}

FileLogger :: struct { // size: 48, alignment: 8
    log_file : String
    mutex : Mutex
}

impl FileLogger {
    new(log_file: string) -> Rc[Logger] {
        logger : Rc[FileLogger] = (Rc[FileLogger]).new(new FileLogger { log_file = log_file.to_owned(), mutex = (Mutex).new() })
        &logger.get().clear()
        return logger.change_type()
    }
    
    clear(self: &FileLogger) {
        &mutex.lock()
        (fs).write_file(&log_file.slice(), "")
        &mutex.release()
    }
    
    log_error(self: &FileLogger, format: string, args: []^any = cast([]^any) ([])) {
        self.log(format, args, "[ERROR]")
    }
}

impl Logger for FileLogger {
    log(self: &FileLogger, format: string, args: []^any = cast([]^any) ([]), prefix: string = "") {
        msg : String = (fmt).format(format, args)
        str : String = (fmt).format("[{}] {} {}`n", cast([]^any) ([cast(^any) ((*(Thread).current()).id), cast(^any) (prefix), cast(^any) (msg)]))
        &mutex.lock()
        (fs).append_file(&log_file.slice(), &str.slice())
        &mutex.release()
        @destruct(str)
        @destruct(msg)
    }
}

#file compiler.che
use import std.array

use import std.fiber

use import std.hash

use import std.map

use import std.mem.arena_allocator

use import std.mem.bump_allocator

use import std.mem.std_heap_allocator

use import std.printable

use import std.rc

use import std.ring_queue

use import std.string

use import std.thread

use import std.time

use import std.os.windows

use import std.os.windows_constants

use import std.os.windows_functions

use import std.os.windows_types

mem :  : import std.mem.allocator

C :  : import std.c

io :  : import std.io

fmt :  : import std.fmt

fs :  : import std.io.fs

use import logging.logger

use import ast

use import ast_dumper

use import bytecode_generator

use import config

use import error_handler

use import interpreter

use import jobs

use import lexer

use import parser

use import scope

use import string_database

use import types

use import value

enable_profiler : bool : false

CHEEZ_FILE_EXTENSION : string_literal : ".cheez"

wait_until :: wait_until(cond: Code, on_error: Code, on_yield: Code = {}, on_resume: Code = {}) #macro {
    fiber_context :  = (Fiber).user_data(FiberContext)
    if ((fiber_context).job).cancelled {
        @insert(on_error)
        loop {
            (Fiber).yield()
        }
    }
    ((fiber_context).job).progressed = true
    loop {
        if @insert(cond) then break
        if DEBUG_ENABLED then if DEBUG_WAIT then (g_logger).log("suspending on {}", [@expr_to_string(@insert(cond))], ((fiber_context).job).get_name())
        @insert(on_yield)
        (Fiber).yield()
        @insert(on_resume)
        if DEBUG_ENABLED then if DEBUG_WAIT then (g_logger).log("resuming on {}", [@expr_to_string(@insert(cond))], ((fiber_context).job).get_name())
        ((fiber_context).job).progressed = false
        if ((fiber_context).job).cancelled {
            @insert(on_error)
            loop {
                (Fiber).yield()
            }
        }
    }
    if DEBUG_ENABLED then if DEBUG_WAIT then (g_logger).log("done on {}", [@expr_to_string(@insert(cond))], ((fiber_context).job).get_name())
    ((fiber_context).job).progressed = true
}

compile_files :: compile_files(files: []String, thread_count: i64) {
    console_error_handler : ConsoleErrorHandler = (ConsoleErrorHandler).new(null)
    g_logger.log("compile files: {}", cast([]^any) ([cast(^any) (files)]), "")
    if ((thread_count < 1) or (thread_count > 32)) {
        &console_error_handler.report_error("Invalid thread_count: {}", cast([]^any) ([cast(^any) (thread_count)]), "", cast([](fmt: string, args: []^any)) ([]))
        @destruct(console_error_handler);
        return
    } else {}
    compiler : Rc[Compiler] = (Compiler).new(thread_count, cast(^ErrorHandler) (^console_error_handler))
    main_workspace : Rc[Workspace] = &compiler.get().get_main_workspace()
    #macro {
        local arr : []String = files
        
        local reverse : bool : false
        local by_ref : bool : true
        {
            it_index : i64 = 0
            loop {
                if !(it_index < (arr).length) then break else {}
                defer it_index = (it_index + 1)
                #anonymous {
                    it : &String = get_index(arr, it_index)
                    #link #anonymous {
                        file : &String = it
                        it_index : i64 = it_index
                        {
                            &main_workspace.get().create_and_add_job((LoadFileJob).new(file.clone()))
                        }
                    }
                }
                it_index = (it_index + 1)
            }
        }
    }
    &(*&compiler.get()).user_defined_builtins.add(("_get_compiler", Symbol.NativeFunc((NativeFunctionWrapper).new(cast(Fn(^Interpreter)) ((interp: ^Interpreter) => {
        frame : ^StackFrame = &*interp.top_frame()
        &*frame.set_return(g_compiler)
    })))))
    &(*&compiler.get()).user_defined_builtins.add(("_println", Symbol.NativeFunc((NativeFunctionWrapper).new(cast(Fn(^Interpreter)) ((interp: ^Interpreter) => {
        frame : ^StackFrame = &*interp.top_frame()
        (io).set_console_foreground_color(ConsoleColor.Green)
        (io).formatln(cast(^any) ("{}"), cast([]^any) ([cast(^any) (&*frame.get_arg(0))]))
        (io).set_console_foreground_color(ConsoleColor.White)
    })))))
    &(*&compiler.get()).user_defined_builtins.add(("_print", Symbol.NativeFunc((NativeFunctionWrapper).new(cast(Fn(^Interpreter)) ((interp: ^Interpreter) => {
        frame : ^StackFrame = &*interp.top_frame()
        (io).set_console_foreground_color(ConsoleColor.Green)
        (io).format(cast(^any) ("{}"), cast([]^any) ([cast(^any) (&*frame.get_arg(0))]))
        (io).set_console_foreground_color(ConsoleColor.White)
    })))))
    &(*&compiler.get()).user_defined_builtins.add(("_debugbreak", Symbol.NativeFunc((NativeFunctionWrapper).new(cast(Fn(^Interpreter)) ((interp: ^Interpreter) => {})))))
    start : i64 = get_time_milliseconds()
    &compiler.get().start_compilation()
    &compiler.get().wait_until_done()
    end : i64 = get_time_milliseconds()
    dur : i64 = (end - start)
    g_logger.log("[Compiler] Compilation took {} ms", cast([]^any) ([cast(^any) (dur)]), "")
    @destruct(main_workspace)
    @destruct(compiler)
    @destruct(console_error_handler)
}

FiberContext :: struct { // size: 40, alignment: 8
    fiber : ^Fiber
    interp : ^Interpreter
    job : ^CompilationJob = null
    thread : u64 = -1
}

FunctionTypeWrapper :: struct { // size: 8, alignment: 8
    typ : ^TypeInfoFunction
}

impl Hashable for FunctionTypeWrapper {
    hash(self: &FunctionTypeWrapper) -> u64 {
        return @bin_xor((cast(u64) (((*typ).param_types).length) * 987654321), 0x268af332e)
    }
}

impl Equatable[FunctionTypeWrapper] for FunctionTypeWrapper {
    equal(self: &FunctionTypeWrapper, other: &FunctionTypeWrapper) -> bool {
        return (TypeInfo).same(cast(^TypeInfo) (typ), cast(^TypeInfo) ((*other).typ))
    }
}

SourceFile :: struct { // size: 80, alignment: 8
    path : string
    content : string
    global_scope : ^Scope
    nodes : Array[^AstNode] = (Array[^AstNode]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
}

Workspace :: struct { // size: 632, alignment: 8
    id : i64
    _compiler : ^void
    jobs : RingQueue[^CompilationJob] = (RingQueue[^CompilationJob]).new(10, null)
    mutex : Mutex
    mutex_ast : Mutex
    mutex_bc : Mutex
    mutex_job : Mutex
    mutex_scope : Mutex
    mutex_type : Mutex
    error_handler : ^ErrorHandler
    string_database : StringDatabase
    all_nodes : Array[^AstNode] = (Array[^AstNode]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    structs : Map[i64, ^AstStruct] = (Map[int, ^AstStruct]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    structs_mutex : Mutex = (Mutex).new()
    string_sources_file : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    string_location : Location = new Location {
        line = 1
        column = 1
        file = default
        byte_index = default
        byte_length = default
        end_column = default
        end_line = default
    }
    sources : Map[string, SourceFile] = (Map[string, SourceFile]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    native_function_wrappers : Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = (Map[FunctionTypeWrapper, NativeFunctionWrapper2]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    next_ast_id : i64 = 1
    ast_allocator : ^Allocator
    bc_allocator : ^Allocator
    job_allocator : ^Allocator
    scope_allocator : ^Allocator
    type_allocator : ^Allocator
}

impl Workspace {
    new(id: i64, compiler: &Compiler, error_handler: ^ErrorHandler) -> Rc[Workspace] {
        AllocatorType :: BumpAllocator = BumpAllocator
        create_allocator :: create_allocator(size: u64) -> ^Allocator {
            allocator : ^BumpAllocator = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            *allocator = (AllocatorType).new(size, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            return cast(^Allocator) (allocator)
        }
        workspace : Rc[Workspace] = (Rc[Workspace]).new(new Workspace {
            id = id
            _compiler = cast(^void) (^*compiler)
            mutex = (Mutex).new()
            mutex_ast = (Mutex).new()
            mutex_bc = (Mutex).new()
            mutex_job = (Mutex).new()
            mutex_scope = (Mutex).new()
            mutex_type = (Mutex).new()
            string_database = (StringDatabase).new()
            error_handler = cast(^ErrorHandler) ((PrefixErrorHandler).new(&*error_handler, (fmt).format("Workspace #{}", cast([]^any) ([cast(^any) (id)]))))
            ast_allocator = create_allocator(0x1000)
            bc_allocator = create_allocator(0x1000)
            job_allocator = create_allocator(0x1000)
            scope_allocator = create_allocator(0x1000)
            type_allocator = create_allocator(0x1000)
            jobs = (RingQueue[^CompilationJob]).new(10, null)
            all_nodes = (Array[^AstNode]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            structs = (Map[int, ^AstStruct]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            structs_mutex = (Mutex).new()
            string_sources_file = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            string_location = new Location {
                line = 1
                column = 1
                file = default
                byte_index = default
                byte_length = default
                end_column = default
                end_line = default
            }
            sources = (Map[string, SourceFile]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            native_function_wrappers = (Map[FunctionTypeWrapper, NativeFunctionWrapper2]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            next_ast_id = 1
        })
        string_sources_file : String = (fmt).format("string_sources_{}{}", cast([]^any) ([cast(^any) (id), cast(^any) (CHEEZ_FILE_EXTENSION)]))
        @destruct((*&workspace.get()).string_sources_file);
        (*&workspace.get()).string_sources_file = match @tempvar_215((fs).get_full_path(&string_sources_file.slice())) {
            Result[String, ()].Ok($path) -> path
            Result[String, ()].Err(_) -> &string_sources_file.clone()
        }
        &(*compiler).sources.set(&(*&workspace.get()).string_sources_file.slice(), "".to_owned())
        ((*&workspace.get()).string_location).file = &(*&workspace.get()).string_sources_file.slice()
        (fs).write_file(&(*&workspace.get()).string_sources_file.slice(), "")
        @destruct(string_sources_file);
        return workspace
    }
    
    get_compiler(self: &Workspace) -> &Compiler {
        return &*cast(^Compiler) (_compiler)
    }
    
    add_load_file_job(self: &Workspace, filename: string) -> ^CompilationJob {
        _ : fn(&Workspace, filename: string) -> ^CompilationJob = self.add_load_file_job
        return self.create_and_add_job((LoadFileJob).new(filename.to_owned()))
    }
    
    define_builtin_types(self: &Workspace, scope: &Scope) {
        scope.define_value("u8", @type_info(type), Value.Type(@type_info(u8)))
        scope.define_value("u16", @type_info(type), Value.Type(@type_info(u16)))
        scope.define_value("u32", @type_info(type), Value.Type(@type_info(u32)))
        scope.define_value("u64", @type_info(type), Value.Type(@type_info(u64)))
        scope.define_value("i8", @type_info(type), Value.Type(@type_info(i8)))
        scope.define_value("i16", @type_info(type), Value.Type(@type_info(i16)))
        scope.define_value("i32", @type_info(type), Value.Type(@type_info(i32)))
        scope.define_value("i64", @type_info(type), Value.Type(@type_info(i64)))
        scope.define_value("f32", @type_info(type), Value.Type(@type_info(f32)))
        scope.define_value("f64", @type_info(type), Value.Type(@type_info(f64)))
        scope.define_value("char8", @type_info(type), Value.Type(@type_info(char8)))
        scope.define_value("char16", @type_info(type), Value.Type(@type_info(char16)))
        scope.define_value("char32", @type_info(type), Value.Type(@type_info(char32)))
        scope.define_value("bool", @type_info(type), Value.Type(@type_info(bool)))
        scope.define_value("string", @type_info(type), Value.Type(@type_info(string)))
        scope.define_value("void", @type_info(type), Value.Type(@type_info(void)))
        scope.define_value("type", @type_info(type), Value.Type(@type_info(type)))
        scope.define_value("int", @type_info(type), Value.Type(@type_info(int)))
        scope.define_value("float", @type_info(type), Value.Type(@type_info(float)))
        scope.define_value("char", @type_info(type), Value.Type(@type_info(char)))
        scope.define_value("String", @type_info(type), Value.Type(@type_info(String)))
        self.register_native_function_type()
        self.register_native_function_type()
        self.register_native_function_type()
        self.register_native_function_type()
        #macro {
            local arr : &Array[(name: string, symbol: Symbol)] = &(*self.get_compiler()).user_defined_builtins
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &(name: string, symbol: Symbol) = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            user_def_sym : &(name: string, symbol: Symbol) = it
                            it_index : i64 = it_index
                            {
                                scope.define_symbol((*user_def_sym).name, (*user_def_sym).symbol)
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
    }
    
    lock(self: &Workspace, mutex: &Mutex) {
        mutex.lock()
    }
    
    release(self: &Workspace, mutex: &Mutex) {
        mutex.release()
    }
    
    get_file(self: &Workspace, path: string) -> Option[^SourceFile] {
        return match @tempvar_216(&sources.get(path)) {
            Option[&SourceFile].Some($file) -> Option[^SourceFile].Some(cast(^SourceFile) (file))
            Option[&SourceFile].None -> Option[^SourceFile].None
        }
    }
    
    load_file(self: &Workspace, path: string) -> Result[Option[^SourceFile], ()] {
        self.lock(&mutex)
        defer self.release(&mutex)
        self.release(&mutex);
        return match @tempvar_217(&sources.get(path)) {
            Option[&SourceFile].Some($source) -> Result[Option[^SourceFile], ()].Ok(Option[^SourceFile].None)
            Option[&SourceFile].None -> {
                content : string = match @tempvar_218(self.get_compiler().get_source(path)) {
                    Result[string, ()].Ok($content) -> content
                    Result[string, ()].Err(_) -> {
                        self.release(&mutex);
                        return Result[Option[^SourceFile], ()].Err
                    }
                }
                &sources.set(path, new SourceFile { path = path, content = content, global_scope = self.new_scope(null, false), nodes = (Array[^AstNode]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) })
                result : ^SourceFile = ^*&sources.at(path)
                self.define_builtin_types(&*(*result).global_scope)
                if (&(*self.get_compiler()).threads.count() > 1) {
                    @destruct((*(*result).global_scope).mutex);
                    (*(*result).global_scope).mutex = Option[Mutex].Some((Mutex).new())
                } else {}
                Result[Option[^SourceFile], ()].Ok(Option[^SourceFile].Some(result))
            }
        }
    }
    
    add_string_source(self: &Workspace, content: string) -> Rc[Lexer] {
        self.lock(&mutex)
        defer self.release(&mutex)
        string_sources : &String = get_unchecked(&(*self.get_compiler()).sources, &string_sources_file.slice())
        string_sources.append_string(content)
        (fs).append_file(&string_sources_file.slice(), content)
        lexer : Rc[Lexer] = (Lexer).from_string(content, &string_database)
        (*&lexer.get()).location = string_location
        (*&lexer.get()).offset = (string_location).byte_index
        (string_location).byte_index = string_sources.get_length()
        (@tempvar_219(string_location)).line = ((@tempvar_219(string_location)).line + content.count_char('`n'))
        (string_location).column = 1
        self.release(&mutex);
        return lexer
    }
    
    register_struct(self: &Workspace, typ: ^TypeInfoStruct, ast: ^AstStruct) {
        self.lock(&mutex)
        defer self.release(&mutex)
        set(&structs, cast(i64) (typ), ast)
        self.release(&mutex)
    }
    
    get_struct_ast(self: &Workspace, typ: ^TypeInfoStruct) -> Option[^AstStruct] {
        self.lock(&mutex)
        defer self.release(&mutex)
        self.release(&mutex);
        return match @tempvar_220(&structs.get(cast(i64) (typ))) {
            Option[&^AstStruct].Some($ast) -> Option[^AstStruct].Some(*ast)
            Option[&^AstStruct].None -> Option[^AstStruct].None
        }
    }
    
    create_and_add_job(&Workspace, job: $T) -> ^CompilationJob {
        job_ptr :  = create_job(job)
        add_job(job_ptr)
        return job_ptr
    }
    // Polymorphic instances for create_and_add_job(&Workspace, job: $T) -> ^CompilationJob
        /* T = (type, LoadFileJob) */
        /*  */
        create_and_add_job(self: &Workspace, job: LoadFileJob) -> ^CompilationJob {
            job_ptr : ^CompilationJob = self.create_job(job)
            self.add_job(job_ptr)
            return job_ptr
        }
    
    
    create_job(&Workspace, job: $T) -> ^CompilationJob {
        (self).lock(&mutex_job)
        defer (self).release(&mutex_job)
        ptr :  = (mem).alloc(T, job_allocator)
        *ptr = job
        (ptr).compiler = ^*get_compiler()
        (ptr).workspace = ^*self
        return ptr
    }
    // Polymorphic instances for create_job(&Workspace, job: $T) -> ^CompilationJob
        /* T = (type, CompileStructMemberJob) */
        /*  */
        create_job(self: &Workspace, job: CompileStructMemberJob) -> ^CompilationJob {
            self.lock(&mutex_job)
            defer self.release(&mutex_job)
            ptr : ^CompileStructMemberJob = (mem).alloc(job_allocator)
            *ptr = job
            (*ptr).compiler = ^*self.get_compiler()
            (*ptr).workspace = ^*self
            self.release(&mutex_job);
            return cast(^CompilationJob) (ptr)
        }
        /* T = (type, CompileGlobalNodeJob) */
        /*  */
        create_job(self: &Workspace, job: CompileGlobalNodeJob) -> ^CompilationJob {
            self.lock(&mutex_job)
            defer self.release(&mutex_job)
            ptr : ^CompileGlobalNodeJob = (mem).alloc(job_allocator)
            *ptr = job
            (*ptr).compiler = ^*self.get_compiler()
            (*ptr).workspace = ^*self
            self.release(&mutex_job);
            return cast(^CompilationJob) (ptr)
        }
        /* T = (type, LoadFileJob) */
        /*  */
        create_job(self: &Workspace, job: LoadFileJob) -> ^CompilationJob {
            self.lock(&mutex_job)
            defer self.release(&mutex_job)
            ptr : ^LoadFileJob = (mem).alloc(job_allocator)
            *ptr = job
            (*ptr).compiler = ^*self.get_compiler()
            (*ptr).workspace = ^*self
            self.release(&mutex_job);
            return cast(^CompilationJob) (ptr)
        }
    
    
    add_job(self: &Workspace, job: ^CompilationJob) {
        self.lock(&mutex_job)
        defer self.release(&mutex_job)
        &jobs.push(job)
        self.release(&mutex_job)
    }
    
    run_job(self: &Workspace, context: ^FiberContext) {
        (*context).job.execute()
    }
    
    new_scope(self: &Workspace, parent: ^Scope = null, constant: bool = false) -> ^Scope {
        self.lock(&mutex_scope)
        defer self.release(&mutex_scope)
        scope : ^Scope = (mem).alloc(scope_allocator)
        *scope = new Scope {
            parent = parent
            constant = constant
            symbols = (Map[string, Symbol]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            impls = Option[Map[TypeId, Array[^AstImpl]]].None
            mutex = Option[Mutex].None
        }
        self.release(&mutex_scope);
        return scope
    }
    
    new_type(&Workspace, type_info: $T) -> ^T {
        (self).lock(&mutex_type)
        defer (self).release(&mutex_type)
        result :  = (mem).alloc(T, type_allocator)
        *result = type_info
        return result
    }
    // Polymorphic instances for new_type(&Workspace, type_info: $T) -> ^T
        /* T = (type, TypeInfoModule) */
        /*  */
        new_type(self: &Workspace, type_info: TypeInfoModule) -> ^TypeInfoModule {
            self.lock(&mutex_type)
            defer self.release(&mutex_type)
            result : ^TypeInfoModule = (mem).alloc(type_allocator)
            *result = type_info
            self.release(&mutex_type);
            return result
        }
        /* T = (type, TypeInfoPoly) */
        /*  */
        new_type(self: &Workspace, type_info: TypeInfoPoly) -> ^TypeInfoPoly {
            self.lock(&mutex_type)
            defer self.release(&mutex_type)
            result : ^TypeInfoPoly = (mem).alloc(type_allocator)
            *result = type_info
            self.release(&mutex_type);
            return result
        }
        /* T = (type, TypeInfoPointer) */
        /*  */
        new_type(self: &Workspace, type_info: TypeInfoPointer) -> ^TypeInfoPointer {
            self.lock(&mutex_type)
            defer self.release(&mutex_type)
            result : ^TypeInfoPointer = (mem).alloc(type_allocator)
            *result = type_info
            self.release(&mutex_type);
            return result
        }
        /* T = (type, TypeInfoReference) */
        /*  */
        new_type(self: &Workspace, type_info: TypeInfoReference) -> ^TypeInfoReference {
            self.lock(&mutex_type)
            defer self.release(&mutex_type)
            result : ^TypeInfoReference = (mem).alloc(type_allocator)
            *result = type_info
            self.release(&mutex_type);
            return result
        }
        /* T = (type, TypeInfoArray) */
        /*  */
        new_type(self: &Workspace, type_info: TypeInfoArray) -> ^TypeInfoArray {
            self.lock(&mutex_type)
            defer self.release(&mutex_type)
            result : ^TypeInfoArray = (mem).alloc(type_allocator)
            *result = type_info
            self.release(&mutex_type);
            return result
        }
        /* T = (type, TypeInfoSlice) */
        /*  */
        new_type(self: &Workspace, type_info: TypeInfoSlice) -> ^TypeInfoSlice {
            self.lock(&mutex_type)
            defer self.release(&mutex_type)
            result : ^TypeInfoSlice = (mem).alloc(type_allocator)
            *result = type_info
            self.release(&mutex_type);
            return result
        }
        /* T = (type, TypeInfoStruct) */
        /*  */
        new_type(self: &Workspace, type_info: TypeInfoStruct) -> ^TypeInfoStruct {
            self.lock(&mutex_type)
            defer self.release(&mutex_type)
            result : ^TypeInfoStruct = (mem).alloc(type_allocator)
            *result = type_info
            self.release(&mutex_type);
            return result
        }
        /* T = (type, TypeInfoFunction) */
        /*  */
        new_type(self: &Workspace, type_info: TypeInfoFunction) -> ^TypeInfoFunction {
            self.lock(&mutex_type)
            defer self.release(&mutex_type)
            result : ^TypeInfoFunction = (mem).alloc(type_allocator)
            *result = type_info
            self.release(&mutex_type);
            return result
        }
    
    
    new_module_type(self: &Workspace) -> ^TypeInfo {
        typ : ^TypeInfoModule = self.new_type(new TypeInfoModule { size = 0, alignment = 1, impl_funcs = cast([]TypeInfoImplFunction) ([]), traits = cast([]TypeInfoTraitImpl) ([]) })
        return cast(^TypeInfo) (typ)
    }
    
    poly_type(self: &Workspace) -> ^TypeInfo {
        typ : ^TypeInfoPoly = self.new_type(new TypeInfoPoly { size = 0, alignment = 1, impl_funcs = cast([]TypeInfoImplFunction) ([]), traits = cast([]TypeInfoTraitImpl) ([]) })
        return cast(^TypeInfo) (typ)
    }
    
    pointer_type(self: &Workspace, target: ^TypeInfo, mutable: bool) -> ^TypeInfo {
        size : i64 = match @tempvar_221(target) {
            TypeInfoTrait(_) -> 16
            TypeInfoAny(_) -> 24
        }
        typ : ^TypeInfoPointer = self.new_type(new TypeInfoPointer {
            size = size
            alignment = 8
            impl_funcs = cast([]TypeInfoImplFunction) ([])
            traits = cast([]TypeInfoTraitImpl) ([])
            target = target
            is_mut = mutable
            is_fat = (size > 8)
        })
        return cast(^TypeInfo) (typ)
    }
    
    reference_type(self: &Workspace, target: ^TypeInfo, mutable: bool) -> ^TypeInfo {
        size : i64 = match @tempvar_224(target) {
            TypeInfoTrait(_) -> 16
            TypeInfoAny(_) -> 24
        }
        typ : ^TypeInfoReference = self.new_type(new TypeInfoReference {
            size = size
            alignment = 8
            impl_funcs = cast([]TypeInfoImplFunction) ([])
            traits = cast([]TypeInfoTraitImpl) ([])
            target = target
            is_mut = mutable
            is_fat = (size > 8)
        })
        return cast(^TypeInfo) (typ)
    }
    
    new_type_data_array(&Workspace, $T: type, count: int) -> []T {
        (self).lock(&mutex_type)
        defer (self).release(&mutex_type)
        result :  = (mem).alloc_n(T, cast (count), type_allocator)
        (C).memset((result).data, 0, cast ((@sizeof(T) * count)))
        return result
    }
    // Polymorphic instances for new_type_data_array(&Workspace, $T: type, count: int) -> []T
        /*  */
        /* T = TypeInfoStructMember */
        new_type_data_array(self: &Workspace, count: i64) -> []TypeInfoStructMember {
            self.lock(&mutex_type)
            defer self.release(&mutex_type)
            result : []TypeInfoStructMember = (mem).alloc_n(cast (count), type_allocator)
            (C).memset(cast(^void) ((result).data), 0, cast ((@sizeof(TypeInfoStructMember) * count)))
            self.release(&mutex_type);
            return result
        }
    
    
    new_ast(&Workspace, ast: $T) -> ^T {
        (self).lock(&mutex_ast)
        defer (self).release(&mutex_ast)
        result :  = (mem).alloc(T, ast_allocator)
        *result = ast
        (result).id = next_ast_id
        next_ast_id = 1
        return result
    }
    // Polymorphic instances for new_ast(&Workspace, ast: $T) -> ^T
        /* T = (type, AstUnary) */
        /*  */
        new_ast(self: &Workspace, ast: AstUnary) -> ^AstUnary {
            self.lock(&mutex_ast)
            defer self.release(&mutex_ast)
            result : ^AstUnary = (mem).alloc(ast_allocator)
            *result = ast
            (*result).id = next_ast_id
            next_ast_id = (next_ast_id + 1)
            self.release(&mutex_ast);
            return result
        }
        /* T = (type, AstUfc) */
        /*  */
        new_ast(self: &Workspace, ast: AstUfc) -> ^AstUfc {
            self.lock(&mutex_ast)
            defer self.release(&mutex_ast)
            result : ^AstUfc = (mem).alloc(ast_allocator)
            *result = ast
            (*result).id = next_ast_id
            next_ast_id = (next_ast_id + 1)
            self.release(&mutex_ast);
            return result
        }
        /* T = (type, AstArgument) */
        /*  */
        new_ast(self: &Workspace, ast: AstArgument) -> ^AstArgument {
            self.lock(&mutex_ast)
            defer self.release(&mutex_ast)
            result : ^AstArgument = (mem).alloc(ast_allocator)
            *result = ast
            (*result).id = next_ast_id
            next_ast_id = (next_ast_id + 1)
            self.release(&mutex_ast);
            return result
        }
        /* T = (type, AstCast) */
        /*  */
        new_ast(self: &Workspace, ast: AstCast) -> ^AstCast {
            self.lock(&mutex_ast)
            defer self.release(&mutex_ast)
            result : ^AstCast = (mem).alloc(ast_allocator)
            *result = ast
            (*result).id = next_ast_id
            next_ast_id = (next_ast_id + 1)
            self.release(&mutex_ast);
            return result
        }
    
    
    register_native_function_type(&Workspace, $FuncType: type) {
        (self).lock(&mutex)
        defer (self).release(&mutex)
        helper :  : (func: , interp: ) {
            frame :  = (interp).top_frame()
            ArgTupleType :  : @param_type_tuple(FuncType)
            slots :  = default
            args :  = &*cast() ((slots).data)
            index :  = 0
            @for_function_parameters(FuncType, (ArgType: , i: ) => {
                ptr := cast(^ArgType) (^args[i])
                *ptr = frame.get(i, ArgType)
                index += ((@sizeof(ArgType) + 7) / 8)
            })
            if ((FuncType).return_type == void) {
                @call_with_tuple_args(cast() (func), args)
            } else {
                result :  = @call_with_tuple_args(cast() (func), args)
                (frame).set_return(result)
            }
        }
        type_wrapper :  = match @type_info(FuncType) {
            TypeInfoFunction($ti) -> FunctionTypeWrapper(ti)
            _ -> {
                return
            }
        }
        h :  = helper
        if !(native_function_wrappers).contains(type_wrapper) {
            native_function_wrappers[type_wrapper] = helper
        }
    }
    // Polymorphic instances for register_native_function_type(&Workspace, $FuncType: type)
        /*  */
        /* FuncType = fn(^String) */
        register_native_function_type(self: &Workspace) {
            self.lock(&mutex)
            defer self.release(&mutex)
            helper :: helper(func: fn(), interp: ^Interpreter) {
                frame : ^StackFrame = &*interp.top_frame()
                ArgTupleType :: @param_type_tuple(fn(^String)) = (^String)
                slots : [1]u64 = default
                args : &(^String) = &*cast(^(^String)) ((slots).data)
                index : i64 = 0
                {
                    {
                        i : u0 : 0
                        ArgType :: ^String = ^String
                        {
                            ptr : ^^String = ^*args[i]
                            *ptr = &*frame.get(i)
                            index = (index + ((@sizeof(ArgType) + 7) / 8))
                        }
                    }
                }
                #anonymous {
                    cast(fn(^String)) (func)(*args[0])
                }
            }
            type_wrapper : FunctionTypeWrapper = match @tempvar_758(@type_info(fn(^String))) {
                TypeInfoFunction($ti) -> new FunctionTypeWrapper { typ = ti }
                _ -> {
                    self.release(&mutex);
                    return
                }
            }
            h : fn(func: fn(), interp: ^Interpreter) = helper
            if !&native_function_wrappers.contains(type_wrapper) {
                set(&native_function_wrappers, type_wrapper, helper)
            } else {}
            self.release(&mutex)
        }
        /*  */
        /* FuncType = fn(^String, string) -> ^String */
        register_native_function_type(self: &Workspace) {
            self.lock(&mutex)
            defer self.release(&mutex)
            helper :: helper(func: fn(), interp: ^Interpreter) {
                frame : ^StackFrame = &*interp.top_frame()
                ArgTupleType :: @param_type_tuple(fn(^String, string) -> ^String) = (^String, string)
                slots : [3]u64 = default
                args : &(^String, string) = &*cast(^(^String, string)) ((slots).data)
                index : i64 = 0
                {
                    {
                        i : u0 : 0
                        ArgType :: ^String = ^String
                        {
                            ptr : ^^String = ^*args[i]
                            *ptr = &*frame.get(i)
                            index = (index + ((@sizeof(ArgType) + 7) / 8))
                        }
                    }
                    {
                        i : u0 : 1
                        ArgType :: string = string
                        {
                            ptr : ^string = ^*args[i]
                            *ptr = &*frame.get(i)
                            index = (index + ((@sizeof(ArgType) + 7) / 8))
                        }
                    }
                }
                #anonymous {
                    result : ^String = cast(fn(^String, string) -> ^String) (func)(*args[0], *args[1])
                    &*frame.set_return(result)
                }
            }
            type_wrapper : FunctionTypeWrapper = match @tempvar_760(@type_info(fn(^String, string) -> ^String)) {
                TypeInfoFunction($ti) -> new FunctionTypeWrapper { typ = ti }
                _ -> {
                    self.release(&mutex);
                    return
                }
            }
            h : fn(func: fn(), interp: ^Interpreter) = helper
            if !&native_function_wrappers.contains(type_wrapper) {
                set(&native_function_wrappers, type_wrapper, helper)
            } else {}
            self.release(&mutex)
        }
        /*  */
        /* FuncType = fn(^Compiler) -> ^Workspace */
        register_native_function_type(self: &Workspace) {
            self.lock(&mutex)
            defer self.release(&mutex)
            helper :: helper(func: fn(), interp: ^Interpreter) {
                frame : ^StackFrame = &*interp.top_frame()
                ArgTupleType :: @param_type_tuple(fn(^Compiler) -> ^Workspace) = (^Compiler)
                slots : [1]u64 = default
                args : &(^Compiler) = &*cast(^(^Compiler)) ((slots).data)
                index : i64 = 0
                {
                    {
                        i : u0 : 0
                        ArgType :: ^Compiler = ^Compiler
                        {
                            ptr : ^^Compiler = ^*args[i]
                            *ptr = &*frame.get(i)
                            index = (index + ((@sizeof(ArgType) + 7) / 8))
                        }
                    }
                }
                #anonymous {
                    result : ^Workspace = cast(fn(^Compiler) -> ^Workspace) (func)(*args[0])
                    &*frame.set_return(result)
                }
            }
            type_wrapper : FunctionTypeWrapper = match @tempvar_762(@type_info(fn(^Compiler) -> ^Workspace)) {
                TypeInfoFunction($ti) -> new FunctionTypeWrapper { typ = ti }
                _ -> {
                    self.release(&mutex);
                    return
                }
            }
            h : fn(func: fn(), interp: ^Interpreter) = helper
            if !&native_function_wrappers.contains(type_wrapper) {
                set(&native_function_wrappers, type_wrapper, helper)
            } else {}
            self.release(&mutex)
        }
        /*  */
        /* FuncType = fn(^Workspace, string) -> ^CompilationJob */
        register_native_function_type(self: &Workspace) {
            self.lock(&mutex)
            defer self.release(&mutex)
            helper :: helper(func: fn(), interp: ^Interpreter) {
                frame : ^StackFrame = &*interp.top_frame()
                ArgTupleType :: @param_type_tuple(fn(^Workspace, string) -> ^CompilationJob) = (^Workspace, string)
                slots : [3]u64 = default
                args : &(^Workspace, string) = &*cast(^(^Workspace, string)) ((slots).data)
                index : i64 = 0
                {
                    {
                        i : u0 : 0
                        ArgType :: ^Workspace = ^Workspace
                        {
                            ptr : ^^Workspace = ^*args[i]
                            *ptr = &*frame.get(i)
                            index = (index + ((@sizeof(ArgType) + 7) / 8))
                        }
                    }
                    {
                        i : u0 : 1
                        ArgType :: string = string
                        {
                            ptr : ^string = ^*args[i]
                            *ptr = &*frame.get(i)
                            index = (index + ((@sizeof(ArgType) + 7) / 8))
                        }
                    }
                }
                #anonymous {
                    result : ^CompilationJob = cast(fn(^Workspace, string) -> ^CompilationJob) (func)(*args[0], *args[1])
                    &*frame.set_return(result)
                }
            }
            type_wrapper : FunctionTypeWrapper = match @tempvar_764(@type_info(fn(^Workspace, string) -> ^CompilationJob)) {
                TypeInfoFunction($ti) -> new FunctionTypeWrapper { typ = ti }
                _ -> {
                    self.release(&mutex);
                    return
                }
            }
            h : fn(func: fn(), interp: ^Interpreter) = helper
            if !&native_function_wrappers.contains(type_wrapper) {
                set(&native_function_wrappers, type_wrapper, helper)
            } else {}
            self.release(&mutex)
        }
    
    
    get_native_function_wrapper(self: &Workspace, ti: ^TypeInfoFunction) -> Option[fn(fn(), ^Interpreter)] {
        self.lock(&mutex)
        defer self.release(&mutex)
        self.release(&mutex);
        return match @tempvar_227(&native_function_wrappers.get(new FunctionTypeWrapper { typ = ti })) {
            Option[&fn(fn(), ^Interpreter)].Some($wrapper) -> Option[fn(fn(), ^Interpreter)].Some(*wrapper)
            Option[&fn(fn(), ^Interpreter)].None -> Option[fn(fn(), ^Interpreter)].None
        }
    }
}

g_compiler : ^Compiler = null

Compiler :: struct { // size: 1568, alignment: 8
    dummy : [1024]u8 = default
    workspaces : Array[Rc[Workspace]] = (Array[Rc[Workspace]]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    fibers : Array[^FiberContext] = (Array[^FiberContext]).create(1024, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    ready_fibers : RingQueue[^FiberContext] = (RingQueue[^FiberContext]).new(10, null)
    waiting_fibers : RingQueue[^FiberContext] = (RingQueue[^FiberContext]).new(10, null)
    any_progress : bool = false
    mutex : Mutex
    thread_count : i64
    threads : Array[Thread]
    active_threads : i64 = 0
    global_error_handler : ^ErrorHandler
    string_database : StringDatabase
    code_runner : Rc[CodeRunner]
    sources : Map[string, String] = (Map[string, String]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    module_path : string = "D:\dev\CheezLang\modules"
    user_defined_builtins : Array[(name: string, symbol: Symbol)] = (Array[(string, Symbol)]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    thread_func_ptr : Fn() = cast(Fn()) (null)
}

impl Drop for Compiler {
    drop(self: &Compiler) {}
}

impl TextProvider for Compiler {
    get_text(self: &Compiler, filename: string) -> string {
        return match @tempvar_228(&(*self).sources.get(filename)) {
            Option[&String].Some($content) -> content.slice()
            Option[&String].None -> @assert(false)
        }
    }
}

impl Compiler {
    new(thread_count: i64, error_handler: ^ErrorHandler) -> Rc[Compiler] {
        comp : Rc[Compiler] = (Rc[Compiler]).new(new Compiler {
            mutex = (Mutex).new()
            thread_count = thread_count
            threads = (Array[Thread]).create(thread_count, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            global_error_handler = error_handler
            string_database = (StringDatabase).new()
            code_runner = (Rc[CodeRunner]).new(new DefaultCodeRunner {  })
            dummy = default
            workspaces = (Array[Rc[Workspace]]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            fibers = (Array[^FiberContext]).create(1024, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            ready_fibers = (RingQueue[^FiberContext]).new(10, null)
            waiting_fibers = (RingQueue[^FiberContext]).new(10, null)
            any_progress = false
            active_threads = 0
            sources = (Map[string, String]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            module_path = "D:\dev\CheezLang\modules"
            user_defined_builtins = (Array[(string, Symbol)]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            thread_func_ptr = cast(Fn()) (null)
        })
        g_compiler = ^*&comp.get()
        (*(*&comp.get()).global_error_handler).text_provider = cast(^TextProvider) (^*&comp.get())
        &(*&comp.get()).workspaces.add((Workspace).new(0, &comp.get(), error_handler))
        #anonymous {
            (*&comp.get()).thread_func_ptr = cast (&comp.get().thread_func)
            return comp
        }
    }
    
    lock(self: &Compiler) {
        if (&threads.get_length() > 1) then &mutex.lock() else {}
    }
    
    release(self: &Compiler) {
        if (&threads.get_length() > 1) then &mutex.release() else {}
    }
    
    run_job(self: &Compiler, context: ^FiberContext) {
        (*context).job.execute()
    }
    
    get_main_workspace(self: &Compiler) -> Rc[Workspace] {
        return access(&workspaces, 0).clone()
    }
    
    get_source(self: &Compiler, path: string) -> Result[string, ()] {
        self.lock()
        defer self.release()
        if !&sources.contains(path) {
            content : Result[String, FsError] = (fs).read_file(path)
            self.release();
            return match @tempvar_229(content) {
                Result[String, FsError].Ok($content) -> {
                    path = &string_database.intern(path)
                    result : string = &content.slice()
                    &sources.set(path, content)
                    Result[string, ()].Ok(result)
                }
                Result[String, FsError].Err($msg) -> {
                    Result[string, ()].Err
                }
            }
        } else {}
        self.release();
        return Result[string, ()].Ok(get_unchecked(&sources, path).slice())
    }
    
    create_workspace(self: &Compiler) -> ^Workspace {
        _ : fn(&Compiler) -> ^Workspace = self.create_workspace
        &workspaces.add((Workspace).new(&workspaces.count(), self, global_error_handler))
        return ^*&workspaces.peek_last().get()
    }
}

impl Compiler {
    start_compilation(self: &Compiler) {
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = thread_count }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_142) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_142))[0]
                it_index : i64 = @var(@id((it, it_index)_142))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        it : i64 = it
                        it_index : i64 = it_index
                        {
                            &threads.add((Thread).new((*self).thread_func_ptr))
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
    }
    
    on_done(self: &Compiler, callback: Fn()) {
        Data :: struct { // size: 32, alignment: 8
            thread : Thread
            callback : Fn()
            compiler : ^Compiler
        }
        thread_func :: thread_func(data: ^Data) {
            &*(*data).compiler.wait_for_threads()
            g_logger.log("on_done: Done waiting for all threads", cast([]^any) ([]), "")
            (*data).callback()
            (Memory).drop(*data)
            (mem).free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        }
        data : ^Data = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        *data = new Data { thread = (Thread).create(cast(Fn(^Data)) (thread_func), data), callback = callback, compiler = ^*self }
    }
    
    wait_for_threads(self: &Compiler) {
        #anonymous {
            handles : ^^void = (mem).alloc_raw(cast (&threads.get_length()), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : &Array[Thread] = &threads
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &Thread = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                it : &Thread = it
                                it_index : i64 = it_index
                                {
                                    handles[it_index] = (*(*it).data).handle
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            WaitForMultipleObjects(cast (&threads.get_length()), handles, 1, INFINITE)
        }
        #anonymous {}
    }
    
    wait_until_done(self: &Compiler) {
        self.wait_for_threads()
        if (&waiting_fibers.count() > 0) {
            global_error_handler.report_error("[Compile] {} fibers were still waiting", cast([]^any) ([cast(^any) (&waiting_fibers.count())]), "", cast([](fmt: string, args: []^any)) ([]))
        } else {}
        g_logger.log("[Compiler] finished compilation with {} fibers", cast([]^any) ([cast(^any) (&fibers.get_length())]), "")
    }
    
    find_free_fiber(self: &Compiler) -> ^FiberContext {
        #macro {
            local arr : &Array[^FiberContext] = &fibers
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &^FiberContext = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            f : &^FiberContext = it
                            it_index : i64 = it_index
                            {
                                if ((cast(^void) ((**f).job) == null) and ((**f).thread == -1)) {
                                    it_index = (it_index + 1);
                                    return *f
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        {
            new_fiber : ^FiberContext = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            *new_fiber = new FiberContext { fiber = (Fiber).new(cast(Fn(^FiberContext)) (self.fiber_func), new_fiber, (1024 * 1024)), interp = (Interpreter).new(global_error_handler), job = null, thread = -1 }
            &fibers.add(new_fiber)
            return new_fiber
        }
    }
    
    fiber_func(self: &Compiler, fiber_context: ^FiberContext) {
        loop {
            if !true then break else {}
            loop {
                if !(cast(^void) ((*fiber_context).job) == null) then break else {}
                (Fiber).yield()
            }
            (*(*fiber_context).job).progressed = false
            self.run_job(fiber_context)
            (*(*fiber_context).job).done = true
            (*fiber_context).job = null
        }
    }
    
    thread_func(self: &Compiler) {
        (Fiber).init()
        thread_id : u64 = (*(Thread).current()).id
        current_fiber : ^FiberContext = null
        loop  #label main_loop{
            if !true then break else {}
            {
                self.lock()
                defer self.release()
                if (cast(^void) (current_fiber) != null) {
                    active_threads = (active_threads - 1)
                    (*current_fiber).thread = -1
                    if ((cast(^void) ((*current_fiber).job) == null) or (*(*current_fiber).job).progressed) {
                        any_progress = true
                        loop {
                            if !(&(*self).waiting_fibers.count() > 0) then break else {}
                            fiber : ^FiberContext = &(*self).waiting_fibers.pop()
                            &(*self).ready_fibers.push(fiber)
                        }
                        any_progress = false
                    } else {}
                    if (cast(^void) ((*current_fiber).job) != null) {
                        &(*self).waiting_fibers.push(current_fiber)
                    } else {}
                    current_fiber = null
                } else {}
                if (&(*self).ready_fibers.count() == 0) {
                    has_jobs : bool = false
                    #macro {
                        local arr : &Array[Rc[Workspace]] = &(*self).workspaces
                        
                        local reverse : bool : false
                        local by_ref : bool : true
                        {
                            it_index : i64 = 0
                            loop {
                                if !(it_index < arr.get_length()) then break else {}
                                defer it_index = (it_index + 1)
                                #anonymous {
                                    #anonymous {
                                        it : &Rc[Workspace] = access(&*arr, it_index)
                                    }
                                    #link #anonymous {
                                        workspace : &Rc[Workspace] = it
                                        it_index : i64 = it_index
                                        {
                                            if (&(*workspace.get()).jobs.count() > 0) {
                                                job : ^CompilationJob = &(*workspace.get()).jobs.pop()
                                                fiber : ^FiberContext = self.find_free_fiber()
                                                (*fiber).job = job
                                                &(*self).ready_fibers.push(fiber)
                                                has_jobs = true
                                                it_index = (it_index + 1);
                                                break
                                            } else {}
                                        }
                                    }
                                }
                                it_index = (it_index + 1)
                            }
                        }
                    }
                    if has_jobs {} else {
                        if ((*self).active_threads > 0) then self.release();
                        continue else {}
                        self.release();
                        break main_loop
                    }
                } else {}
                current_fiber = &(*self).ready_fibers.pop()
                (*current_fiber).thread = thread_id
                active_threads = (active_threads + 1)
                self.release()
            }
            &*(*current_fiber).fiber.resume()
        }
        self.lock()
        defer self.release()
        #macro {
            local que : &RingQueue[^FiberContext] = &waiting_fibers
            
            local reverse : bool : false
            local by_ref : bool : false
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < que.count()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : ^FiberContext = *at(&*que, it_index)
                        }
                        #link #anonymous {
                            fib : ^FiberContext = it
                            it_index : i64 = it_index
                            {
                                if (cast(^void) ((*fib).job) != null) {
                                    (*(*fib).job).cancelled = true
                                    &*(*fib).fiber.resume()
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        self.release()
    }
}

#file config.che
DEBUG_ENABLED : bool : true

DEBUG_INTERPRETER : bool = false

DEBUG_JOBS : bool = false

DEBUG_PARSER : bool = false

DEBUG_WAIT : bool = false

DUMP_AST : bool = false

PRINT_AST : bool = false

PRINT_TYPED_AST : bool = false

VALIDATE_AST : bool : true

#file error_handler.che
use import std.math

use import std.string

use import std.thread

fmt :  : import std.fmt

io :  : import std.io

mem :  : import std.mem.allocator

use import lexer

ErrorHandler :: trait {
    text_provider : ^TextProvider
    has_errors :: f.Accept(this)
    report_error :: f.Accept(this)
    report_error_at :: f.Accept(this)
}

TextProvider :: trait {
    get_text :: f.Accept(this)
}

PrefixErrorHandler :: struct type { // size: 72, alignment: 8
    text_provider : ^TextProvider
    base : &ErrorHandler
    prefix : String
}

impl PrefixErrorHandler {
    new(base: &ErrorHandler, prefix: String) -> ^PrefixErrorHandler {
        eh : ^PrefixErrorHandler = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        *eh = new PrefixErrorHandler { text_provider = (*base).text_provider, base = base, prefix = prefix }
        return eh
    }
}

impl ErrorHandler for PrefixErrorHandler {
    has_errors(self: &PrefixErrorHandler) -> bool {
        return base.has_errors()
    }
    
    report_error(self: &PrefixErrorHandler, message: string, args: []^any = cast([]^any) ([]), prefix: string = "", details: [](fmt: string, args: []^any) = cast([](fmt: string, args: []^any)) ([])) {
        pre : String = if strings_not_equal(prefix, "") {
            @tempvar_230((fmt).format("{}][{}", cast([]^any) ([cast(^any) ((*self).prefix), cast(^any) (prefix)])))
        } else {
            @tempvar_231(&(*self).prefix.clone())
        }
        base.report_error(message, args, &pre.slice(), details)
        @destruct(pre)
    }
    
    report_error_at(self: &PrefixErrorHandler, location: Location, message: string, args: []^any = cast([]^any) ([]), prefix: string = "", details: [](fmt: string, args: []^any) = cast([](fmt: string, args: []^any)) ([])) {
        pre : String = if strings_not_equal(prefix, "") {
            @tempvar_232((fmt).format("{}][{}", cast([]^any) ([cast(^any) ((*self).prefix), cast(^any) (prefix)])))
        } else {
            @tempvar_233(&(*self).prefix.clone())
        }
        base.report_error_at(location, message, args, &pre.slice(), details)
        @destruct(pre)
    }
}

ConsoleErrorHandler :: struct type { // size: 56, alignment: 8
    text_provider : ^TextProvider
    error_count : i64 = 0
    do_print_location : bool = true
    code_color_error : ConsoleColor = ConsoleColor.Red
    code_color_normal : ConsoleColor = ConsoleColor.Green
    mutex : Mutex = (Mutex).new()
}

impl ConsoleErrorHandler {
    new(text_provider: ^TextProvider) -> ConsoleErrorHandler {
        return new ConsoleErrorHandler {
            text_provider = text_provider
            error_count = 0
            do_print_location = true
            code_color_error = ConsoleColor.Red
            code_color_normal = ConsoleColor.Green
            mutex = (Mutex).new()
        }
    }
}

impl ErrorHandler for ConsoleErrorHandler {
    has_errors(self: &ConsoleErrorHandler) -> bool {
        return (error_count > 0)
    }
    
    report_error(self: &ConsoleErrorHandler, message: string, args: []^any = cast([]^any) ([]), prefix: string = "", details: [](fmt: string, args: []^any) = cast([](fmt: string, args: []^any)) ([])) {
        &mutex.lock()
        defer &mutex.release()
        error_count = (error_count + 1)
        if strings_not_equal(prefix, "") {
            (io).set_console_foreground_color(@bin_or(ConsoleColor.White, ConsoleColor.Bright))
            (io).format(cast(^any) ("[{}] "), cast([]^any) ([cast(^any) (prefix)]))
        } else {}
        (io).set_console_foreground_color(@bin_or(ConsoleColor.Red, ConsoleColor.Bright))
        (io).formatln(cast(^any) (message), args)
        (io).set_console_foreground_color(ConsoleColor.White)
        &mutex.release()
    }
    
    report_error_at(self: &ConsoleErrorHandler, location: Location, message: string, args: []^any = cast([]^any) ([]), prefix: string = "", details: [](fmt: string, args: []^any) = cast([](fmt: string, args: []^any)) ([])) {
        &mutex.lock()
        defer &mutex.release()
        error_count = (error_count + 1)
        (io).set_console_foreground_color(@bin_or(ConsoleColor.White, ConsoleColor.Bright))
        if strings_not_equal(prefix, "") {
            (io).format(cast(^any) ("[{}] "), cast([]^any) ([cast(^any) (prefix)]))
        } else {}
        (io).format(cast(^any) ("{}:{}:{}: "), cast([]^any) ([cast(^any) ((location).file), cast(^any) ((location).line), cast(^any) ((location).column)]))
        (io).set_console_foreground_color(@bin_or(ConsoleColor.Red, ConsoleColor.Bright))
        (io).formatln(cast(^any) (message), args)
        (io).set_console_foreground_color(ConsoleColor.White)
        if do_print_location then self.print_location(location) else {}
        if ((details).length > 0) {
            self.print_details(details)
        } else {}
        &mutex.release()
    }
    
    print_details(self: &ConsoleErrorHandler, details: [](fmt: string, args: []^any)) {
        (io).set_console_foreground_color(@bin_or(ConsoleColor.Red, ConsoleColor.Green, ConsoleColor.Bright))
        #macro {
            local arr : [](fmt: string, args: []^any) = details
            
            local reverse : bool : false
            local by_ref : bool : false
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : (fmt: string, args: []^any) = *get_index(arr, it_index)
                        #link #anonymous {
                            detail : (fmt: string, args: []^any) = it
                            it_index : i64 = it_index
                            {
                                (io).formatln(cast(^any) ((detail).fmt), (detail).args)
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        (io).set_console_foreground_color(ConsoleColor.White)
    }
    
    print_location(self: &ConsoleErrorHandler, location: Location) {
        text : string = text_provider.get_text((location).file)
        find_start_of_line :: find_start_of_line(text: string, byte_index: i64) -> i64 {
            bytes : []u8 = (text).bytes
            start : i64 = byte_index
            byte_index = (byte_index - 1)
            loop {
                if !((byte_index >= 0) and (*get_index(bytes, byte_index) != cast(u8) ('`n'))) then break else {}
                start = byte_index
                byte_index = (byte_index - 1)
            }
            return start
        }
        find_end_of_line :: find_end_of_line(text: string, byte_index: i64) -> i64 {
            bytes : []u8 = (text).bytes
            loop {
                if !((byte_index < ((text).bytes).length) and (*get_index(bytes, byte_index) != cast(u8) ('`n'))) then break else {}
                byte_index = (byte_index + 1)
            }
            return byte_index
        }
        get_line_range :: get_line_range(text: string, start_line: i64, byte_index: i64, byte_length: i64) -> RangeInclusive[i64] {
            bytes : []u8 = (text).bytes
            end_line : i64 = start_line
            end : i64 = (byte_index + byte_length)
            loop {
                if !(byte_index < end) then break else {}
                defer byte_index = (byte_index + 1)
                if (*get_index(bytes, byte_index) == cast(u8) ('`n')) {
                    end_line = (end_line + 1)
                } else {}
                byte_index = (byte_index + 1)
            }
            return new RangeInclusive[i64] { start = start_line, end = end_line }
        }
        print_line_number :: print_line_number(line: i64, max_line_digits: i64) {
            line_digits : i64 = count_digits(line, 10)
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = (max_line_digits - line_digits) }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_560) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_560))[0]
                    it_index : i64 = @var(@id((it, it_index)_560))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                (io).print(" ")
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            (io).print(line)
            (io).print("> ")
        }
        {
            total_range : Range[i64] = new Range[i64] { start = (location).byte_index, end = ((location).byte_index + (location).byte_length) }
            lines : RangeInclusive[i64] = get_line_range(text, (location).line, (location).byte_index, (location).byte_length)
            max_line_digits : i64 = count_digits((lines).end, 10)
            index : i64 = (location).byte_index
            #macro {
                local r : RangeInclusive[i64] = lines
                
                local reverse : bool : false
                @id((start, end, inc)_153) : (i64, i64, i64) = {
                    end : i64 = (r).end
                    ((r).start, end, 1)
                }
                start : i64 = @var(@id((start, end, inc)_153))[0]
                end : i64 = @var(@id((start, end, inc)_153))[1]
                inc : i64 = @var(@id((start, end, inc)_153))[2]
                
                {
                    @id((it, it_index)_154) : (i64, i64) = (start, 0)
                    it : i64 = @var(@id((it, it_index)_154))[0]
                    it_index : i64 = @var(@id((it, it_index)_154))[1]
                    loop {
                        if !(it <= end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            line : i64 = it
                            it_index : i64 = it_index
                            {
                                line_range : Range[i64] = new Range[i64] { start = find_start_of_line(text, index), end = find_end_of_line(text, index) }
                                error_range : Range[i64] = new Range[i64] { start = index, end = min((line_range).end, (total_range).end) }
                                sub1 : string = get_range(text, new Range[i64] { start = (line_range).start, end = (error_range).start })
                                sub2 : string = get_range(text, new Range[i64] { start = (error_range).start, end = (error_range).end })
                                sub3 : string = get_range(text, new Range[i64] { start = (error_range).end, end = (line_range).end })
                                sub1_bytes : []u8 = (sub1).bytes
                                sub2_bytes : []u8 = (sub2).bytes
                                sub3_bytes : []u8 = (sub3).bytes
                                print_stuff :: print_stuff(bytes: []u8) #macro {
                                    for b : bytes (io).printf("{:x} ", b)
                                }
                                print_line_number(line, max_line_digits)
                                (io).set_console_foreground_color(code_color_normal)
                                (io).print(sub1)
                                (io).set_console_foreground_color(@bin_or(code_color_error, ConsoleColor.Bright))
                                (io).print(sub2)
                                (io).set_console_foreground_color(code_color_normal)
                                (io).print(sub3)
                                (io).set_console_foreground_color(ConsoleColor.White)
                                (io).println("")
                                index = ((line_range).end + 1)
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
        }
    }
}

#file jobs.che
use import std.array

use import std.fiber

use import std.math

use import std.mem.std_heap_allocator

use import std.printable

use import std.string

C :  : import std.c

fmt :  : import std.fmt

fs :  : import std.io.fs

io :  : import std.io

mem :  : import std.mem.allocator

util :  : import std.util

use import logging.logger

use import ast

use import ast_cloner

use import ast_dumper

use import ast_pretty_printer

use import bytecode_generator

use import compiler

use import config

use import lexer

use import parser

use import scope

use import types

use import validator

use import value

CompilationJob :: trait {
    cancelled : bool = false
    progressed : bool = false
    done : bool = false
    compiler : ^Compiler = null
    workspace : ^Workspace = null
    get_name :: f.Accept(this)
    execute :: f.Accept(this)
}

LoadFileJob :: struct type { // size: 104, alignment: 8
    cancelled : bool = false
    progressed : bool = false
    done : bool = false
    compiler : ^Compiler = null
    workspace : ^Workspace = null
    name : String
    path : String
}

impl LoadFileJob {
    new(path: String) -> LoadFileJob {
        return new LoadFileJob {
            name = (fmt).format("LoadFileJob '{}'", cast([]^any) ([cast(^any) (path)]))
            path = path
            cancelled = false
            progressed = false
            done = false
            compiler = null
            workspace = null
        }
    }
}

RunCodeJob :: struct type { // size: 72, alignment: 8
    cancelled : bool = false
    progressed : bool = false
    done : bool = false
    compiler : ^Compiler = null
    workspace : ^Workspace = null
    name : String
    function : ^AstFunction
}

impl RunCodeJob {
    new(function: ^AstFunction) -> RunCodeJob {
        return new RunCodeJob {
            name = (fmt).format("RunCodeJob '{}'", cast([]^any) ([cast(^any) ((*function).name)]))
            function = function
            cancelled = false
            progressed = false
            done = false
            compiler = null
            workspace = null
        }
    }
}

CompileGlobalNodeJob :: struct type { // size: 88, alignment: 8
    cancelled : bool = false
    progressed : bool = false
    done : bool = false
    compiler : ^Compiler = null
    workspace : ^Workspace = null
    name : String
    node : ^AstNode
    function : ^AstFunction = null
}

impl CompileGlobalNodeJob {
    new(node: ^AstNode) -> CompileGlobalNodeJob {
        return new CompileGlobalNodeJob {
            name = (fmt).format("CompileGlobalNodeJob #{}", cast([]^any) ([cast(^any) ((*node).id)]))
            node = node
            cancelled = false
            progressed = false
            done = false
            compiler = null
            workspace = null
            function = null
        }
    }
}

CompileStructMemberJob :: struct type { // size: 88, alignment: 8
    cancelled : bool = false
    progressed : bool = false
    done : bool = false
    compiler : ^Compiler = null
    workspace : ^Workspace = null
    name : String
    structt : ^AstStruct
    node : ^AstNode
}

impl CompileStructMemberJob {
    new(structt: ^AstStruct, node: ^AstNode) -> CompileStructMemberJob {
        return new CompileStructMemberJob {
            name = (fmt).format("CompileStructMemberJob #{}", cast([]^any) ([cast(^any) ((*node).id)]))
            structt = structt
            node = node
            cancelled = false
            progressed = false
            done = false
            compiler = null
            workspace = null
        }
    }
}

impl CompilationJob for CompileStructMemberJob {
    get_name(self: &CompileStructMemberJob) -> string {
        return &name.slice()
    }
    
    debug_log(self: &CompileStructMemberJob, msg: string, args: []^any = cast([]^any) ([])) {
        #anonymous {
            if DEBUG_JOBS {
                str : String = (fmt).format(msg, args)
                g_logger.log("[Workspace {}] [CompileStructMemberJob #{}] {}", cast([]^any) ([cast(^any) ((*workspace).id), cast(^any) ((*node).id), cast(^any) (str)]), "")
                @destruct(str)
            } else {}
        }
    }
    
    execute(self: &CompileStructMemberJob) {
        self.debug_log("Begin compilation", cast([]^any) ([]))
        compile_node : CompileNode = new CompileNode {
            job = cast(^CompilationJob) (^*self)
            compiler = compiler
            workspace = workspace
            node = node
            function = null
        }
        match @tempvar_234(node) {
            AstDecl($decl) -> {
                &compile_node.compile_node(cast(&AstNode) (&*decl), new CNContext { expected = null })
                &(*structt).members.add(decl)
            }
            AstConstDecl($decl) -> {
                &compile_node.compile_node(cast(&AstNode) (&*decl), new CNContext { expected = null })
                &(*structt).constants.add(decl)
            }
            _ -> {
                node = ^*&compile_node.evaluate_node(&*node, new CNContext { expected = null })
                if ((*node).value == Value.Poison) {
                    poison(&*node)
                    return
                } else {}
                match @tempvar_237((*node).typ) {
                    TypeInfoString($ti) -> {
                        @assert(((*node).value == Value.String))
                        str : string = ((*node).value).String
                        lexer : Rc[Lexer] = &*workspace.add_string_source(str)
                        parser : Parser = (Parser).new(&lexer.get(), (*workspace).error_handler, (*workspace).ast_allocator, (*workspace).next_ast_id)
                        (@tempvar_239(*workspace)).next_ast_id = ((@tempvar_239(*workspace)).next_ast_id + 0xFFFFFFFF)
                        loop {
                            node : ^AstNode = &parser.parse_node()
                            if (cast(^void) (node) == null) then break else {}
                            #anonymous {
                                if DUMP_AST {
                                    dump : String = dump_ast(&*node, true)
                                    g_logger.log("[{}] {}", cast([]^any) ([cast(^any) ((*self).name), cast(^any) (dump)]), "")
                                    @destruct(dump)
                                } else {}
                            }
                            #anonymous {
                                if PRINT_AST {
                                    dump : String = pretty_print_ast(&*node)
                                    g_logger.log("[{}] {}", cast([]^any) ([cast(^any) ((*self).name), cast(^any) (dump)]), "")
                                    @destruct(dump)
                                } else {}
                            }
                            (*node).scope = (*(*self).node).scope
                            job : ^CompilationJob = &*workspace.create_job((CompileStructMemberJob).new(structt, node))
                            &*workspace.add_job(job)
                            #macro {
                                
                                
                                
                                
                                fiber_context : ^FiberContext = (Fiber).user_data()
                                if (*(*fiber_context).job).cancelled {
                                    #link #anonymous {}
                                    loop {
                                        (Fiber).yield()
                                    }
                                } else {}
                                (*(*fiber_context).job).progressed = true
                                loop {
                                    if (*job).done then break else {}
                                    if DEBUG_WAIT then g_logger.log("suspending on {}", cast([]^any) ([cast(^any) (@expr_to_string((*job).done))]), (*fiber_context).job.get_name()) else {}
                                    #link #anonymous {}
                                    (Fiber).yield()
                                    #link #anonymous {}
                                    if DEBUG_WAIT then g_logger.log("resuming on {}", cast([]^any) ([cast(^any) (@expr_to_string((*job).done))]), (*fiber_context).job.get_name()) else {}
                                    (*(*fiber_context).job).progressed = false
                                    if (*(*fiber_context).job).cancelled {
                                        #link #anonymous {}
                                        loop {
                                            (Fiber).yield()
                                        }
                                    } else {}
                                }
                                if DEBUG_WAIT then g_logger.log("done on {}", cast([]^any) ([cast(^any) (@expr_to_string((*job).done))]), (*fiber_context).job.get_name()) else {}
                                (*(*fiber_context).job).progressed = true
                            }
                        }
                        @destruct(lexer)
                    }
                }
            }
        }
        self.debug_log("Done", cast([]^any) ([]))
    }
}

impl CompilationJob for CompileGlobalNodeJob {
    get_name(self: &CompileGlobalNodeJob) -> string {
        return &name.slice()
    }
    
    debug_log(self: &CompileGlobalNodeJob, msg: string, args: []^any = cast([]^any) ([])) {
        #anonymous {
            if DEBUG_JOBS {
                str : String = (fmt).format(msg, args)
                g_logger.log("[Workspace {}] [CompileGlobalNodeJob #{}] {}", cast([]^any) ([cast(^any) ((*workspace).id), cast(^any) ((*node).id), cast(^any) (str)]), "")
                @destruct(str)
            } else {}
        }
    }
    
    execute(self: &CompileGlobalNodeJob) {
        self.debug_log("Begin compilation", cast([]^any) ([]))
        compile_node : CompileNode = new CompileNode {
            job = cast(^CompilationJob) (^*self)
            compiler = compiler
            workspace = workspace
            node = node
            function = null
        }
        &*node.set_flags(AstNodeFlags.AllowPubModifier)
        node = ^*&compile_node.compile_node(&*node, new CNContext { expected = null })
        if ((*node).value == Value.Poison) {
            self.debug_log("Failed. Got poison", cast([]^any) ([]))
            return
        } else {}
        #anonymous {
            self.debug_log("Validate node", cast([]^any) ([]))
            if !validate_node(&*node, (*workspace).error_handler) {
                self.debug_log("Validation failed", cast([]^any) ([]))
                return
            } else {}
        }
        #anonymous {
            if PRINT_TYPED_AST {
                dump : String = pretty_print_typed_ast(&*node)
                g_logger.log("[{}] {}", cast([]^any) ([cast(^any) ((*self).name), cast(^any) (dump)]), "")
                @destruct(dump)
            } else {}
        }
        self.debug_log("Done", cast([]^any) ([]))
    }
}

impl CompilationJob for RunCodeJob {
    get_name(self: &RunCodeJob) -> string {
        return &name.slice()
    }
    
    debug_log(self: &RunCodeJob, msg: string, args: []^any = cast([]^any) ([])) {
        #anonymous {
            if DEBUG_JOBS {
                str : String = (fmt).format(msg, args)
                g_logger.log("[Workspace {}] [RunCodeJob '{}'] {}", cast([]^any) ([cast(^any) ((*workspace).id), cast(^any) ((*function).name), cast(^any) (str)]), "")
                @destruct(str)
            } else {}
        }
    }
    
    execute(self: &RunCodeJob) {
        if (*workspace).error_handler.has_errors() {
            return
        } else {}
        self.debug_log("Begin execution", cast([]^any) ([]))
        context : ^FiberContext = (Fiber).user_data()
        &*(*context).interp.comp_call(&*function)
        match @tempvar_240(&(*compiler).code_runner.get().run(&*(*context).interp)) {
            InterpStepResult.Error($msg) -> {
                frame : ^StackFrame = &*(*context).interp.top_frame()
                location : Location = &(*(*frame).func).debug_info.get_location_for_ip((*frame).ip)
                (*workspace).error_handler.report_error_at(location, "{}", cast([]^any) ([cast(^any) (msg)]), "", cast([](fmt: string, args: []^any)) ([]))
            };
            @destruct(msg);
        }
        self.debug_log("Done", cast([]^any) ([]))
    }
}

impl CompilationJob for LoadFileJob {
    get_name(self: &LoadFileJob) -> string {
        return &name.slice()
    }
    
    debug_log(self: &LoadFileJob, msg: string, args: []^any = cast([]^any) ([])) {
        #anonymous {
            if DEBUG_JOBS {
                str : String = (fmt).format(msg, args)
                g_logger.log("[Workspace {}] [LoadFileJob '{}'] {}", cast([]^any) ([cast(^any) ((*workspace).id), cast(^any) (path), cast(^any) (str)]), "")
                @destruct(str)
            } else {}
        }
    }
    
    execute(self: &LoadFileJob) {
        self.debug_log("Begin loading", cast([]^any) ([]))
        full_path : string = match @tempvar_241((fs).get_full_path(&path.slice())) {
            Result[String, ()].Ok($p) -> &(*workspace).string_database.intern(&p.slice());
            @destruct(p);
            Result[String, ()].Err(_) -> &(*workspace).string_database.intern(&path.slice())
        }
        match @tempvar_242(&*workspace.load_file(full_path)) {
            Result[Option[^SourceFile], ()].Err(_) -> {
                (*workspace).error_handler.report_error("Failed to load file '{}'", cast([]^any) ([cast(^any) (full_path)]), "", cast([](fmt: string, args: []^any)) ([]))
                return
            }
            Result[Option[^SourceFile], ()].Ok($file) -> match @tempvar_243(file) {
                Option[^SourceFile].Some($file) -> {
                    lexer : Rc[Lexer] = (Lexer).from_string((*file).content, &(*workspace).string_database)
                    ((*&lexer.get()).location).file = full_path
                    parser : Parser = (Parser).new(&lexer.get(), (*workspace).error_handler, (*workspace).ast_allocator, (*workspace).next_ast_id)
                    (@tempvar_244(*workspace)).next_ast_id = ((@tempvar_244(*workspace)).next_ast_id + 0xFFFFFFFF)
                    loop {
                        node : ^AstNode = &parser.parse_node()
                        if (cast(^void) (node) == null) then break else {}
                        #anonymous {
                            if DUMP_AST {
                                dump : String = dump_ast(&*node, true)
                                g_logger.log("[{}] {}", cast([]^any) ([cast(^any) ((*self).name), cast(^any) (dump)]), "")
                                @destruct(dump)
                            } else {}
                        }
                        #anonymous {
                            if PRINT_AST {
                                dump : String = pretty_print_ast(&*node)
                                g_logger.log("[{}] {}", cast([]^any) ([cast(^any) ((*self).name), cast(^any) (dump)]), "")
                                @destruct(dump)
                            } else {}
                        }
                        (*node).scope = (*file).global_scope
                        &(*file).nodes.add(node)
                        match @tempvar_245(node) {
                            AstConstDecl($decl) -> {
                                self.define_const_decl(&*decl)
                                (AstNode).set_flags(cast(&AstNode) (&*decl), AstNodeFlags.IsDefinedInScope)
                            }
                            AstDecl($decl) -> {
                                self.define_decl(&*decl)
                                (AstNode).set_flags(cast(&AstNode) (&*decl), AstNodeFlags.IsDefinedInScope)
                            }
                        }
                    }
                    #macro {
                        local arr : &Array[^AstNode] = &(*file).nodes
                        
                        local reverse : bool : false
                        local by_ref : bool : true
                        {
                            it_index : i64 = 0
                            loop {
                                if !(it_index < arr.get_length()) then break else {}
                                defer it_index = (it_index + 1)
                                #anonymous {
                                    #anonymous {
                                        it : &^AstNode = access(&*arr, it_index)
                                    }
                                    #link #anonymous {
                                        node : &^AstNode = it
                                        it_index : i64 = it_index
                                        {
                                            &*workspace.add_job(&*workspace.create_job((CompileGlobalNodeJob).new(*node)))
                                        }
                                    }
                                }
                                it_index = (it_index + 1)
                            }
                        }
                    }
                    @destruct(lexer)
                }
            }
        }
        self.debug_log("Done", cast([]^any) ([]))
    }
    
    define_decl(self: &LoadFileJob, decl: &AstDecl) {
        (*decl).name = match @tempvar_248(&*(*decl).pattern) {
            AstIdentifier($id) -> (*id).name
            _ -> {
                (*workspace).error_handler.report_error_at((*decl).location, "Non-identifier patterns not implemented yet", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                return
            }
        }
        if strings_not_equal((*decl).name, "_") {
            match @tempvar_250(&*(*decl).scope.define_decl((*decl).name, decl)) {
                Result[(), ()].Err -> {
                    (*workspace).error_handler.report_error_at((*(*decl).pattern).location, "A symbol with this name already exists in this scope", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                }
            }
        } else {}
    }
    
    define_const_decl(self: &LoadFileJob, decl: &AstConstDecl) {
        (*(*decl).value_expr).scope = (*decl).scope
        name : string = match @tempvar_251((*decl).pattern) {
            AstIdentifier($id) -> (*id).name
            _ -> {
                (*workspace).error_handler.report_error_at((*decl).location, "Non-identifier patterns not implemented yet", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                return
            }
        }
        match @tempvar_253((*decl).value_expr) {
            AstFunction($func) -> {
                (*func).name = name
            }
            AstStruct($str) -> {
                (*str).name = name
            }
            AstEnum($en) -> {
                (*en).name = name
            }
            AstTrait($tr) -> {
                (*tr).name = name
            }
            AstPoly($poly) -> {
                (*poly).name = name
            }
        }
        if strings_not_equal(name, "_") {
            match @tempvar_259(&*(*decl).scope.define_const_decl(name, decl)) {
                Result[(), ()].Err -> {
                    (*workspace).error_handler.report_error_at((*(*decl).pattern).location, "A symbol with this name already exists in this scope", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                }
            }
        } else {}
    }
}

CompileNode :: struct { // size: 56, alignment: 8
    job : ^CompilationJob
    compiler : ^Compiler
    workspace : ^Workspace
    node : ^AstNode
    function : ^AstFunction
}

CNContext :: struct { // size: 16, alignment: 8
    expected : ^TypeInfo = null
}

impl CNContext {
    with_expected(self: CNContext, typ: ^TypeInfo) -> CNContext {
        expected = typ
        return self
    }
}

impl CompileNode {
    debug_log(self: &CompileNode, msg: string, args: []^any = cast([]^any) ([])) {
        #anonymous {
            if DEBUG_JOBS {
                str : String = (fmt).format(msg, args)
                g_logger.log("[Workspace {}] [{}] {}", cast([]^any) ([cast(^any) ((*workspace).id), cast(^any) (job.get_name()), cast(^any) (str)]), "")
                @destruct(str)
            } else {}
        }
    }
    
    evaluate_node(self: &CompileNode, node: &AstNode, ctx: CNContext) -> &AstNode {
        if (cast(^void) ((*node).typ) != null) {
            return node
        } else {}
        (*node).scope = &*workspace.new_scope((*node).scope, constant = true)
        node <- self.compile_node(node, ctx)
        #macro {
            local node : &AstNode = node
            
            if ((*node).value == Value.Poison) {
                (*node).typ = @type_info(void)
                (*node).value = Value.Poison
                return node
            } else {}
        }
        if ((*node).value == Value.None) {
            code_gen : Rc[ByteCodeGenerator] = (ByteCodeGenerator).new(&(*workspace).string_database, &*(*workspace).error_handler, (*workspace).bc_allocator)
            code : ^CBCFunction = &code_gen.get().generate_code_for_expression(node)
            context : ^FiberContext = (Fiber).user_data()
            &*(*context).interp.push_frame(code)
            defer &*(*context).interp.pop_frame()
            match @tempvar_260(&(*compiler).code_runner.get().run(&*(*context).interp)) {
                InterpStepResult.Error($msg) -> {
                    frame : ^StackFrame = &*(*context).interp.top_frame()
                    location : Location = &(*(*frame).func).debug_info.get_location_for_ip((*frame).ip)
                    (*workspace).error_handler.report_error_at(location, "{}", cast([]^any) ([cast(^any) (msg)]), "", cast([](fmt: string, args: []^any)) ([]))
                    poison(node)
                    @destruct(msg);
                    &*(*context).interp.pop_frame();
                    @destruct(code_gen);
                    return node
                };
                @destruct(msg);
            }
            frame : ^StackFrame = &*(*context).interp.top_frame()
            (*node).value = match @tempvar_261(&*(*node).typ) {
                TypeInfoInt(_) -> Value.Int(&*frame.get_local(0))
                TypeInfoFloat(_) -> Value.Float(&*frame.get_local(0))
                TypeInfoBool(_) -> Value.Bool(&*frame.get_local(0))
                TypeInfoString(_) -> Value.String(&*frame.get_local(0))
                _ -> Value.None
            }
            &*(*context).interp.pop_frame()
            @destruct(code_gen)
        } else {}
        return node
    }
    
    compile_node(self: &CompileNode, node: &AstNode, ctx: CNContext) -> &AstNode {
        if (cast(^void) ((*node).typ) != null) {
            return node
        } else {}
        {}
        return match @tempvar_266(node) {
            AstArgument($arg) -> self.compile_argument(arg, ctx)
            AstArray($arr) -> self.compile_array(arr, ctx)
            AstArrayType($arr) -> self.compile_array_type(arr, ctx)
            AstAssignment($ass) -> self.compile_assignment(ass, ctx)
            AstBinary($bin) -> self.compile_binary(bin, ctx)
            AstBlock($block) -> self.compile_block(block, ctx)
            AstBool($bol) -> self.compile_bool(bol, ctx)
            AstBreak($brake) -> self.compile_break(brake, ctx)
            AstCall($call) -> self.compile_call(call, ctx)
            AstCast($cst) -> self.compile_cast(cst, ctx)
            AstConstDecl($decl) -> self.compile_const_decl(decl, ctx)
            AstContinue($cont) -> self.compile_continue(cont, ctx)
            AstDecl($decl) -> self.compile_decl(decl, ctx)
            AstDefer($def) -> self.compile_defer(def, ctx)
            AstDot($dot) -> self.compile_dot(dot, ctx)
            AstFor($forr) -> self.compile_for(forr, ctx)
            AstFunction($func) -> self.compile_function(func, ctx)
            AstIdentifier($id) -> self.compile_identifier(id, ctx)
            AstIf($iff) -> self.compile_if(iff, ctx)
            AstImpl($imp) -> self.compile_impl(imp, ctx)
            AstImport($imp) -> self.compile_import(imp, ctx)
            AstIndex($index) -> self.compile_index(index, ctx)
            AstLoop($lop) -> self.compile_loop(lop, ctx)
            AstNumberLiteral($num) -> self.compile_number(num, ctx)
            AstPoly($poly) -> self.compile_poly(poly, ctx)
            AstReturn($ret) -> self.compile_return(ret, ctx)
            AstString($str) -> self.compile_string(str, ctx)
            AstStruct($str) -> self.compile_struct(str, ctx)
            AstUfc($ufc) -> self.compile_ufc(ufc, ctx)
            AstUnary($un) -> self.compile_unary(un, ctx)
            _ -> {
                dump : String = dump_ast(node, recurse = false)
                (*workspace).error_handler.report_error_at((*node).location, "compile_node: not implemented: {}", cast([]^any) ([cast(^any) (dump)]), "", cast([](fmt: string, args: []^any)) ([]))
                node
                @destruct(dump)
            }
        }
    }
    
    compile_dot(self: &CompileNode, dot: &AstDot, ctx: CNContext) -> &AstNode {
        if (cast(^void) ((*dot).sub) == null) {
            (*workspace).error_handler.report_error_at((*dot).location, "compile_dot: anonymous not implemented", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
            poison(cast(&AstNode) (dot))
            return cast(&AstNode) (dot)
        } else {}
        original_sub : ^AstNode = (*dot).sub
        (*(*dot).sub).scope = (*dot).scope
        (*dot).sub <- cast(^AstNode) (self.compile_node(&*(*dot).sub, ctx))
        #macro {
            local node : &AstNode = cast(&AstNode) (dot)
            
            if ((*(*dot).sub).value == Value.Poison) {
                (*node).typ = @type_info(void)
                (*node).value = Value.Poison
                return node
            } else {}
        }
        match @tempvar_297((*(*dot).sub).typ) {
            TypeInfoPointer($ti) -> {
                deref : ^AstUnary = &*workspace.new_ast(new AstUnary {
                    id = -1
                    location = (*(*dot).sub).location
                    scope = (*(*dot).sub).scope
                    sub = &*(*dot).sub
                    operator = UnOp.Deref
                    typ = null
                    value = Value.None
                    flags = 0
                })
                (*dot).sub <- cast(^AstNode) (self.compile_node(cast(&AstNode) (&*deref), ctx.with_expected((*ti).target)))
                #macro {
                    local node : &AstNode = cast(&AstNode) (dot)
                    
                    if ((*(*dot).sub).value == Value.Poison) {
                        (*node).typ = @type_info(void)
                        (*node).value = Value.Poison
                        return node
                    } else {}
                }
            }
        }
        name : string = (*(*dot).name).name
        match @tempvar_299((*(*dot).sub).typ) {
            TypeInfoArray($ti) -> {
                if (strings_equal(name, "length") or strings_equal(name, "count")) {
                    (*dot).typ = @type_info(int)
                    (*dot).value = Value.Int((*ti).count)
                } else if strings_equal(name, "data") {
                    (*workspace).error_handler.report_error_at((*dot).location, "TODO: array.data", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                    poison(cast(&AstNode) (dot))
                    return cast(&AstNode) (dot)
                } else {
                    (*workspace).error_handler.report_error_at((*(*dot).name).location, "Type '{}' has no subscript '{}'", cast([]^any) ([cast(^any) ((*(*dot).sub).typ), cast(^any) (name)]), "", cast([](fmt: string, args: []^any)) ([]))
                    poison(cast(&AstNode) (dot))
                    return cast(&AstNode) (dot)
                }
            }
            TypeInfoStruct($ti) -> {
                match @tempvar_302(&*workspace.get_struct_ast(ti)) {
                    Option[^AstStruct].Some($ast) -> #macro {
                        
                        
                        
                        
                        fiber_context : ^FiberContext = (Fiber).user_data()
                        if (*(*fiber_context).job).cancelled {
                            #link #anonymous {}
                            loop {
                                (Fiber).yield()
                            }
                        } else {}
                        (*(*fiber_context).job).progressed = true
                        loop {
                            if (*ast).members_done then break else {}
                            if DEBUG_WAIT then g_logger.log("suspending on {}", cast([]^any) ([cast(^any) (@expr_to_string((*ast).members_done))]), (*fiber_context).job.get_name()) else {}
                            #link #anonymous {}
                            (Fiber).yield()
                            #link #anonymous {}
                            if DEBUG_WAIT then g_logger.log("resuming on {}", cast([]^any) ([cast(^any) (@expr_to_string((*ast).members_done))]), (*fiber_context).job.get_name()) else {}
                            (*(*fiber_context).job).progressed = false
                            if (*(*fiber_context).job).cancelled {
                                #link #anonymous {}
                                loop {
                                    (Fiber).yield()
                                }
                            } else {}
                        }
                        if DEBUG_WAIT then g_logger.log("done on {}", cast([]^any) ([cast(^any) (@expr_to_string((*ast).members_done))]), (*fiber_context).job.get_name()) else {}
                        (*(*fiber_context).job).progressed = true
                    }
                }
                member : ^TypeInfoStructMember = null
                #macro {
                    local arr : []TypeInfoStructMember = (*ti).members
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &TypeInfoStructMember = get_index(arr, it_index)
                                #link #anonymous {
                                    mem : &TypeInfoStructMember = it
                                    it_index : i64 = it_index
                                    {
                                        if strings_equal((*mem).name, name) {
                                            member = cast(^TypeInfoStructMember) (mem)
                                            it_index = (it_index + 1);
                                            break
                                        } else {}
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                if (cast(^void) (member) != null) {
                    (*dot).typ = (*member).typ
                    (*dot).symbol = Symbol.StructMember(member)
                    if &*(*dot).sub.has_flags(AstNodeFlags.LValue) then (AstNode).set_flags(cast(&AstNode) (dot), AstNodeFlags.LValue) else {}
                    return cast(&AstNode) (dot)
                } else {}
                func : ^TypeInfoImplFunction = null
                #macro {
                    local arr : []TypeInfoImplFunction = (*ti).impl_funcs
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &TypeInfoImplFunction = get_index(arr, it_index)
                                #link #anonymous {
                                    it : &TypeInfoImplFunction = it
                                    it_index : i64 = it_index
                                    {
                                        if strings_equal((*it).name, name) {
                                            func = ^*it
                                            it_index = (it_index + 1);
                                            break
                                        } else {}
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                if (cast(^void) (func) != null) {
                    match @tempvar_303(&*workspace.get_native_function_wrapper(cast ((*func).typ))) {
                        Option[fn(fn(), ^Interpreter)].Some($wrapper) -> {
                            return self.compile_node(cast(&AstNode) (&*&*workspace.new_ast(new AstUfc {
                                id = -1
                                location = (*dot).location
                                scope = (*dot).scope
                                typ = (*func).typ
                                value_expr = &*original_sub
                                symbol = Symbol.NativeFunc2(wrapper)
                                value = Value.NativeFunc2((wrapper, (*func).pointer))
                                flags = 0
                            })), ctx)
                        }
                        Option[fn(fn(), ^Interpreter)].None -> {
                            (*workspace).error_handler.report_error_at((*(*dot).name).location, "Can't call native function '{}' because no wrapper is available for type '{}'", cast([]^any) ([cast(^any) (name), cast(^any) ((*func).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                            poison(cast(&AstNode) (dot))
                            return cast(&AstNode) (dot)
                        }
                    }
                } else {}
                (*workspace).error_handler.report_error_at((*(*dot).name).location, "Struct '{}' has no member or function '{}'", cast([]^any) ([cast(^any) ((*ti).name), cast(^any) (name)]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (dot))
                return cast(&AstNode) (dot)
            }
            TypeInfoType($ti) -> {
                typ : ^TypeInfo = &(*(*dot).sub).value.as_type()
                #macro {
                    local iter : ScopeImplIterator = &*(*dot).scope.get_impls(typ)
                    
                    scope : ^Scope = ^*(iter).scope
                    it_index : i64 = 0
                    loop  #label outer_loop{
                        if !(cast(^void) (scope) != null) then break else {}
                        match @tempvar_305(&(*scope).impls) {
                            Option[Map[TypeId, Array[^AstImpl]]].Some($map) -> {
                                @static_assert((&Map[TypeId, Array[^AstImpl]] == &Map[TypeId, Array[^AstImpl]]))
                                #macro {
                                    local r : &Map[TypeId, Array[^AstImpl]] = map
                                    
                                    it_index : i64 = 0
                                    #macro {
                                        local arr : []Entry[TypeId, Array[^AstImpl]] = r.get_entries()
                                        
                                        local reverse : bool : false
                                        local by_ref : bool : true
                                        {
                                            it_index : i64 = 0
                                            loop {
                                                if !(it_index < (arr).length) then break else {}
                                                defer it_index = (it_index + 1)
                                                #anonymous {
                                                    it : &Entry[TypeId, Array[^AstImpl]] = get_index(arr, it_index)
                                                    #link #anonymous {
                                                        e : &Entry[TypeId, Array[^AstImpl]] = it
                                                        _ : i64 = it_index
                                                        {
                                                            if !(*e).filled then it_index = (it_index + 1);
                                                            continue else {}
                                                            it : (key: &TypeId, value: &Array[^AstImpl]) = (&((*e).key).Some, &((*e).value).Some)
                                                            #link #anonymous {
                                                                kv : (key: &TypeId, value: &Array[^AstImpl]) = it
                                                                _ : i64 = it_index
                                                                {
                                                                    if (cast(^void) (*(kv).key.type_info()) == cast(^void) ((iter).typ)) {
                                                                        impls : &Array[^AstImpl] = (kv).value
                                                                        #macro {
                                                                            local arr : &Array[^AstImpl] = impls
                                                                            
                                                                            local reverse : bool : false
                                                                            local by_ref : bool : true
                                                                            {
                                                                                it_index : i64 = 0
                                                                                loop {
                                                                                    if !(it_index < arr.get_length()) then break else {}
                                                                                    defer it_index = (it_index + 1)
                                                                                    #anonymous {
                                                                                        #anonymous {
                                                                                            it : &^AstImpl = access(&*arr, it_index)
                                                                                        }
                                                                                        #link #anonymous {
                                                                                            imp : &^AstImpl = it
                                                                                            it_index : i64 = it_index
                                                                                            {
                                                                                                it : ^&^AstImpl = ^imp
                                                                                                #link #anonymous {
                                                                                                    imp : ^&^AstImpl = it
                                                                                                    it_index : i64 = it_index
                                                                                                    {
                                                                                                        g_logger.log("", cast([]^any) ([]), "")
                                                                                                    }
                                                                                                }
                                                                                                it_index = (it_index + 1)
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    it_index = (it_index + 1)
                                                                                }
                                                                            }
                                                                        }
                                                                    } else {}
                                                                }
                                                            }
                                                            it_index = (it_index + 1)
                                                        }
                                                    }
                                                }
                                                it_index = (it_index + 1)
                                            }
                                        }
                                    }
                                }
                            }
                            Option[Map[TypeId, Array[^AstImpl]]].None -> {}
                        }
                        scope = (*scope).parent
                    }
                }
                poison(cast(&AstNode) (dot))
                return cast(&AstNode) (dot)
            }
            TypeInfoModule(_) -> {
                file : ^SourceFile = &(*(*dot).sub).value.as_module()
                (*(*dot).name).scope = (*file).global_scope
                (AstNode).set_flags(cast(&AstNode) ((*dot).name), AstNodeFlags.OnlyPubDeclarations)
                self.compile_node(cast(&AstNode) ((*dot).name), ctx)
                (*dot).typ = (*(*dot).name).typ
                (*dot).value = (*(*dot).name).value
            }
            _ -> {
                (*workspace).error_handler.report_error_at((*(*dot).sub).location, "Invalid type on left side of '.': '{}'", cast([]^any) ([cast(^any) ((*(*dot).sub).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (dot))
                return cast(&AstNode) (dot)
            }
        }
        return cast(&AstNode) (dot)
    }
    
    compile_assignment(self: &CompileNode, ass: &AstAssignment, ctx: CNContext) -> &AstNode {
        (*(*ass).pattern).scope = (*ass).scope
        (*ass).pattern <- self.compile_node((*ass).pattern, ctx)
        #macro {
            local node : &AstNode = cast(&AstNode) (ass)
            
            if ((*(*ass).pattern).value == Value.Poison) {
                (*node).typ = @type_info(void)
                (*node).value = Value.Poison
                return node
            } else {}
        }
        (*(*ass).value_expr).scope = (*ass).scope
        (*ass).value_expr <- self.compile_node((*ass).value_expr, ctx.with_expected((*(*ass).pattern).typ))
        #macro {
            local node : &AstNode = cast(&AstNode) (ass)
            
            if ((*(*ass).value_expr).value == Value.Poison) {
                (*node).typ = @type_info(void)
                (*node).value = Value.Poison
                return node
            } else {}
        }
        if !(TypeInfo).same((*(*ass).value_expr).typ, (*(*ass).pattern).typ) {
            (*workspace).error_handler.report_error_at((*(*ass).value_expr).location, "Can't assign value of type '{}' to pattern of type '{}'", cast([]^any) ([cast(^any) ((*(*ass).value_expr).typ), cast(^any) ((*(*ass).pattern).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
            poison(cast(&AstNode) (ass))
            return cast(&AstNode) (ass)
        } else {}
        match @tempvar_307((*ass).pattern) {
            AstIdentifier($id) -> match @tempvar_309((*id).symbol) {
                Symbol.Decl($decl) -> {
                    if !(*decl).mutable {
                        (*workspace).error_handler.report_error_at((*(*ass).pattern).location, "Can't assign to '{}' because it is not mutable", cast([]^any) ([cast(^any) ((*id).name)]), "", cast([](fmt: string, args: []^any)) ([]))
                        poison(cast(&AstNode) (ass))
                        return cast(&AstNode) (ass)
                    } else {}
                }
                Symbol.ConstDecl($decl) -> {
                    (*workspace).error_handler.report_error_at((*(*ass).pattern).location, "Can't assign to constant '{}'", cast([]^any) ([cast(^any) ((*id).name)]), "", cast([](fmt: string, args: []^any)) ([]))
                    poison(cast(&AstNode) (ass))
                    return cast(&AstNode) (ass)
                }
                _ -> {
                    (*workspace).error_handler.report_error_at((*(*ass).pattern).location, "Invalid pattern on left side of '='", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                    poison(cast(&AstNode) (ass))
                    return cast(&AstNode) (ass)
                }
            }
            AstDot($dot) if ((*dot).symbol == Symbol.StructMember) -> {}
            AstDot($dot) -> {
                (*workspace).error_handler.report_error_at((*(*ass).pattern).location, "compile_assignment: not implemented: <expr>.<id>", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (ass))
                return cast(&AstNode) (ass)
            }
            AstIndex($node) -> {
                match @tempvar_313((*(*node).sub).typ) {
                    TypeInfoArray($ti) -> match @tempvar_315((*(*node).index).typ) {
                        TypeInfoInt(_) -> {}
                        _ -> {
                            (*workspace).error_handler.report_error_at((*(*ass).pattern).location, "Invalid pattern on left side of '='", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                            poison(cast(&AstNode) (node))
                            return cast(&AstNode) (node)
                        }
                    }
                    _ -> {
                        (*workspace).error_handler.report_error_at((*(*ass).pattern).location, "Invalid pattern on left side of '='", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                        poison(cast(&AstNode) (node))
                        return cast(&AstNode) (node)
                    }
                }
            }
            AstUnary($un) if ((*un).operator == UnOp.Deref) -> {
                match @tempvar_318((*(*un).sub).typ) {
                    TypeInfoPointer($ti) -> {
                        if !(*ti).is_mut {
                            (*workspace).error_handler.report_error_at((*(*ass).pattern).location, "Can't assign to immutable pointer", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                            poison(cast(&AstNode) (ass))
                            return cast(&AstNode) (ass)
                        } else {}
                    }
                    TypeInfoReference($ti) -> {
                        if !(*ti).is_mut {
                            (*workspace).error_handler.report_error_at((*(*ass).pattern).location, "Can't assign to immutable reference", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                            poison(cast(&AstNode) (ass))
                            return cast(&AstNode) (ass)
                        } else {}
                    }
                }
            }
            _ -> {
                (*workspace).error_handler.report_error_at((*(*ass).pattern).location, "Invalid pattern on left side of '='", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (ass))
                return cast(&AstNode) (ass)
            }
        }
        (*ass).typ = @type_info(void)
        return cast(&AstNode) (ass)
    }
    
    compile_array(self: &CompileNode, arr: &AstArray, ctx: CNContext) -> &AstNode {
        (*arr).typ = @type_info(void)
        expected : ^TypeInfo = null
        if (cast(^void) ((ctx).expected) != null) then match @tempvar_321(&*(ctx).expected) {
            TypeInfoArray($arr_type) -> {
                expected = (*arr_type).target
            }
        } else {}
        #macro {
            local arr : &Array[^AstNode] = &(*arr).values
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &^AstNode = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            val : &^AstNode = it
                            it_index : i64 = it_index
                            {
                                (**val).scope = (*arr).scope
                                *val = ^*self.compile_node(&**val, ctx.with_expected(expected))
                                if ((**val).value == Value.Poison) {
                                    poison(cast(&AstNode) (arr))
                                    it_index = (it_index + 1);
                                    return cast(&AstNode) (arr)
                                } else {}
                                if (cast(^void) (expected) == null) {
                                    expected = (**val).typ
                                } else {}
                                if !(TypeInfo).same((**val).typ, expected) {
                                    (*workspace).error_handler.report_error_at((**val).location, "Type of value ({}) does not match expected type {}", cast([]^any) ([cast(^any) ((**val).typ), cast(^any) (expected)]), "", cast([](fmt: string, args: []^any)) ([]))
                                    poison(cast(&AstNode) (arr))
                                    it_index = (it_index + 1);
                                    return cast(&AstNode) (arr)
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        if (cast(^void) (expected) == null) {
            (*workspace).error_handler.report_error_at((*arr).location, "Failed to infer type of array expression", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
            poison(cast(&AstNode) (arr))
            return cast(&AstNode) (arr)
        } else {}
        (*arr).typ = cast(^TypeInfo) (&*workspace.new_type(new TypeInfoArray {
            size = (&(*arr).values.count() * (*expected).size)
            alignment = (*expected).alignment
            traits = cast([]TypeInfoTraitImpl) ([])
            impl_funcs = cast([]TypeInfoImplFunction) ([])
            count = &(*arr).values.count()
            target = expected
        }))
        return cast(&AstNode) (arr)
    }
    
    compile_array_type(self: &CompileNode, arr: &AstArrayType, ctx: CNContext) -> &AstNode {
        (*arr).typ = @type_info(type)
        count : Option[i64] = if (cast(^void) ((*arr).count) == null) {
            Option[i64].None
        } else {
            (*(*arr).count).scope = (*arr).scope
            (*arr).count = ^*self.evaluate_node(&*(*arr).count, ctx.with_expected(@type_info(int)))
            #macro {
                local node : &AstNode = cast(&AstNode) (arr)
                
                if ((*(*arr).count).value == Value.Poison) {
                    (*node).typ = @type_info(void)
                    (*node).value = Value.Poison
                    return node
                } else {}
            }
            if !(TypeInfo).same((*(*arr).count).typ, @type_info(int)) {
                (*workspace).error_handler.report_error_at((*(*arr).count).location, "Expected int, got '{}'", cast([]^any) ([cast(^any) ((*(*arr).count).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (arr))
                return cast(&AstNode) (arr)
            } else {}
            @assert(((*(*arr).count).value == Value.Int))
            count : i64 = ((*(*arr).count).value).Int
            Option[i64].Some(count)
        }
        (*(*arr).target).scope = (*arr).scope
        @tempvar_324((*arr).target) = self.evaluate_node((*arr).target, ctx.with_expected(@type_info(type)))
        if (((*(*arr).target).value == Value.Poison) or (cast(^void) ((*(*arr).target).typ) != cast(^void) (@type_info(type)))) {
            poison(cast(&AstNode) (arr))
            return cast(&AstNode) (arr)
        } else {}
        @assert(((*(*arr).target).value == Value.Type))
        target : ^TypeInfo = ((*(*arr).target).value).Type
        (*arr).value = match @tempvar_323(count) {
            Option[i64].Some($count) -> Value.Type(cast(^TypeInfo) (&*workspace.new_type(new TypeInfoArray {
                size = (count * (*target).size)
                alignment = (*target).alignment
                traits = cast([]TypeInfoTraitImpl) ([])
                impl_funcs = cast([]TypeInfoImplFunction) ([])
                count = count
                target = target
            })))
            Option[i64].None -> Value.Type(cast(^TypeInfo) (&*workspace.new_type(new TypeInfoSlice {
                size = (2 * @sizeof(^void))
                alignment = (*target).alignment
                traits = cast([]TypeInfoTraitImpl) ([])
                impl_funcs = cast([]TypeInfoImplFunction) ([])
                target = target
            })))
        }
        return cast(&AstNode) (arr)
    }
    
    compile_ufc(self: &CompileNode, ufc: &AstUfc, ctx: CNContext) -> &AstNode {
        return cast(&AstNode) (ufc)
    }
    
    compile_unary(self: &CompileNode, un: &AstUnary, ctx: CNContext) -> &AstNode {
        (*(*un).sub).scope = (*un).scope
        return match @tempvar_325((*un).operator) {
            UnOp.Neg -> self.compile_unary_neg(un, ctx)
            UnOp.Not -> self.compile_unary_not(un, ctx)
            UnOp.Ref -> self.compile_unary_ptr_or_ref(un, ctx)
            UnOp.RefMut -> self.compile_unary_ptr_or_ref(un, ctx)
            UnOp.Ptr -> self.compile_unary_ptr_or_ref(un, ctx)
            UnOp.PtrMut -> self.compile_unary_ptr_or_ref(un, ctx)
            UnOp.Deref -> self.compile_unary_deref(un, ctx)
        }
    }
    
    compile_unary_neg(self: &CompileNode, un: &AstUnary, ctx: CNContext) -> &AstNode {
        (*(*un).sub).scope = (*un).scope
        (*un).sub <- self.compile_node((*un).sub, ctx)
        if (cast(^void) ((*(*un).sub).typ) == null) {
            return cast(&AstNode) (un)
        } else {}
        match @tempvar_326(&*(*(*un).sub).typ) {
            TypeInfoInt(_) -> {}
            TypeInfoFloat(_) -> {}
            $ti -> {
                (*workspace).error_handler.report_error_at((*(*un).sub).location, "Expected type bool, got {}", cast([]^any) ([cast(^any) ((*(*un).sub).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                return cast(&AstNode) (un)
            }
        }
        (*un).typ = (*(*un).sub).typ
        match @tempvar_329((*un).value) {
            Value.Int($b) -> {
                (*un).value = Value.Int(-b)
            }
            Value.Float($b) -> {
                (*un).value = Value.Float(-b)
            }
        }
        return cast(&AstNode) (un)
    }
    
    compile_unary_not(self: &CompileNode, un: &AstUnary, ctx: CNContext) -> &AstNode {
        (*(*un).sub).scope = (*un).scope
        (*un).sub <- self.compile_node((*un).sub, ctx.with_expected(@type_info(bool)))
        if (cast(^void) ((*(*un).sub).typ) == null) {
            return cast(&AstNode) (un)
        } else {}
        if (cast(^void) ((*(*un).sub).typ) != cast(^void) (@type_info(bool))) {
            (*workspace).error_handler.report_error_at((*(*un).sub).location, "Expected type bool, got {}", cast([]^any) ([cast(^any) ((*(*un).sub).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
            return cast(&AstNode) (un)
        } else {}
        (*un).typ = @type_info(bool)
        match @tempvar_330((*un).value) {
            Value.Bool($b) -> {
                (*un).value = Value.Bool(!b)
            }
        }
        return cast(&AstNode) (un)
    }
    
    compile_unary_ptr_or_ref(self: &CompileNode, un: &AstUnary, ctx: CNContext) -> &AstNode {
        @id((mutable, reference, str)_163) : (bool, bool, string) = match @tempvar_331((*un).operator) {
            UnOp.Ref -> (false, true, "reference")
            UnOp.RefMut -> (true, true, "reference")
            UnOp.Ptr -> (false, false, "pointer")
            UnOp.PtrMut -> (true, false, "pointer")
        }
        mutable : bool = @var(@id((mutable, reference, str)_163))[0]
        reference : bool = @var(@id((mutable, reference, str)_163))[1]
        str : string = @var(@id((mutable, reference, str)_163))[2]
        (*(*un).sub).scope = (*un).scope
        (*un).sub <- self.compile_node((*un).sub, ctx)
        #macro {
            local node : &AstNode = cast(&AstNode) (un)
            
            if ((*(*un).sub).value == Value.Poison) {
                (*node).typ = @type_info(void)
                (*node).value = Value.Poison
                return node
            } else {}
        }
        if (cast(^void) ((*(*un).sub).typ) == cast(^void) (@type_info(type))) {
            @assert(((*(*un).sub).value == Value.Type))
            (*un).typ = (*(*un).sub).typ
            if reference {
                (*un).value = Value.Type(&*workspace.reference_type(((*(*un).sub).value).Type, mutable))
            } else {
                (*un).value = Value.Type(&*workspace.pointer_type(((*(*un).sub).value).Type, mutable))
            }
        } else {
            if !(*un).sub.has_flags(AstNodeFlags.LValue) {
                (*workspace).error_handler.report_error_at((*un).location, "Can't create {} to non l-value", cast([]^any) ([cast(^any) (str)]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (un))
                return cast(&AstNode) (un)
            } else {}
            match @tempvar_332((*un).sub) {
                AstIdentifier($id) -> match @tempvar_334((*id).symbol) {
                    Symbol.Decl($decl) -> {
                        if (mutable and !(*decl).mutable) {
                            (*workspace).error_handler.report_error_at((*un).location, "Can't create mutable {} to immutable variabe", cast([]^any) ([cast(^any) (str)]), "", cast([](fmt: string, args: []^any)) ([]))
                            poison(cast(&AstNode) (un))
                            return cast(&AstNode) (un)
                        } else {}
                    }
                }
                AstDot($dot) -> {
                    if mutable {
                        node : ^AstNode = (*dot).sub
                        loop {
                            match @tempvar_336(node) {
                                AstDot($dot) -> {
                                    node = (*dot).sub
                                }
                                AstIdentifier($id) -> match @tempvar_339((*id).symbol) {
                                    Symbol.Decl($decl) -> {
                                        if !(*decl).mutable {
                                            (*workspace).error_handler.report_error_at((*un).location, "Can't create mutable {} to immutable variabe", cast([]^any) ([cast(^any) (str)]), "", cast([](fmt: string, args: []^any)) ([]))
                                            poison(cast(&AstNode) (un))
                                            return cast(&AstNode) (un)
                                        } else {}
                                        break
                                    }
                                    _ -> break
                                }
                                _ -> break
                            }
                        }
                    } else {}
                }
            }
            if reference {
                (*un).typ = &*workspace.reference_type((*(*un).sub).typ, mutable)
            } else {
                (*un).typ = &*workspace.pointer_type((*(*un).sub).typ, mutable)
            }
        }
        return cast(&AstNode) (un)
    }
    
    compile_unary_deref(self: &CompileNode, un: &AstUnary, ctx: CNContext) -> &AstNode {
        (*(*un).sub).scope = (*un).scope
        (*un).sub <- self.compile_node((*un).sub, ctx)
        #macro {
            local node : &AstNode = cast(&AstNode) (un)
            
            if ((*(*un).sub).value == Value.Poison) {
                (*node).typ = @type_info(void)
                (*node).value = Value.Poison
                return node
            } else {}
        }
        if !(*un).sub.has_flags(AstNodeFlags.LValue) {
            (*workspace).error_handler.report_error_at((*un).location, "Can't dereference non l-value", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
            poison(cast(&AstNode) (un))
            return cast(&AstNode) (un)
        } else {}
        match @tempvar_340((*(*un).sub).typ) {
            TypeInfoPointer($ti) -> {
                (*un).typ = (*ti).target
            }
            TypeInfoReference($ti) -> {
                (*un).typ = (*ti).target
            }
            _ -> {
                (*workspace).error_handler.report_error_at((*un).location, "Can't dereference value of type '{}'", cast([]^any) ([cast(^any) ((*(*un).sub).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (un))
            }
        }
        return cast(&AstNode) (un)
    }
    
    compile_binary(self: &CompileNode, bin: &AstBinary, ctx: CNContext) -> &AstNode {
        (*(*bin).left).scope = (*bin).scope
        (*(*bin).right).scope = (*bin).scope
        (*bin).left <- self.compile_node((*bin).left, ctx)
        (*bin).right <- self.compile_node((*bin).right, ctx)
        #macro {
            local node : &AstNode = cast(&AstNode) (bin)
            
            if ((*(*bin).left).value == Value.Poison) {
                (*node).typ = @type_info(void)
                (*node).value = Value.Poison
                return node
            } else {}
        }
        #macro {
            local node : &AstNode = cast(&AstNode) (bin)
            
            if ((*(*bin).right).value == Value.Poison) {
                (*node).typ = @type_info(void)
                (*node).value = Value.Poison
                return node
            } else {}
        }
        match @tempvar_343((*bin).operator) {
            BinOp.Add -> {
                if !(TypeInfo).same((*(*bin).left).typ, (*(*bin).right).typ) {
                    (*workspace).error_handler.report_error_at((*bin).location, "Types of left and right sub expressions don't match. Left: {}, Right: {}", cast([]^any) ([cast(^any) ((*(*bin).left).typ), cast(^any) ((*(*bin).right).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                } else {}
                (*bin).typ = (*(*bin).left).typ
            }
            BinOp.Sub -> {
                if !(TypeInfo).same((*(*bin).left).typ, (*(*bin).right).typ) {
                    (*workspace).error_handler.report_error_at((*bin).location, "Types of left and right sub expressions don't match. Left: {}, Right: {}", cast([]^any) ([cast(^any) ((*(*bin).left).typ), cast(^any) ((*(*bin).right).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                } else {}
                (*bin).typ = (*(*bin).left).typ
            }
            BinOp.Mul -> {
                if !(TypeInfo).same((*(*bin).left).typ, (*(*bin).right).typ) {
                    (*workspace).error_handler.report_error_at((*bin).location, "Types of left and right sub expressions don't match. Left: {}, Right: {}", cast([]^any) ([cast(^any) ((*(*bin).left).typ), cast(^any) ((*(*bin).right).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                } else {}
                (*bin).typ = (*(*bin).left).typ
            }
            BinOp.Div -> {
                if !(TypeInfo).same((*(*bin).left).typ, (*(*bin).right).typ) {
                    (*workspace).error_handler.report_error_at((*bin).location, "Types of left and right sub expressions don't match. Left: {}, Right: {}", cast([]^any) ([cast(^any) ((*(*bin).left).typ), cast(^any) ((*(*bin).right).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                } else {}
                (*bin).typ = (*(*bin).left).typ
            }
            BinOp.Mod -> {
                if !(TypeInfo).same((*(*bin).left).typ, (*(*bin).right).typ) {
                    (*workspace).error_handler.report_error_at((*bin).location, "Types of left and right sub expressions don't match. Left: {}, Right: {}", cast([]^any) ([cast(^any) ((*(*bin).left).typ), cast(^any) ((*(*bin).right).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                } else {}
                (*bin).typ = (*(*bin).left).typ
            }
            BinOp.Equal -> {
                (*bin).typ = @type_info(bool)
            }
            BinOp.NotEqual -> {
                (*bin).typ = @type_info(bool)
            }
            BinOp.Less -> {
                (*bin).typ = @type_info(bool)
            }
            BinOp.LessEq -> {
                (*bin).typ = @type_info(bool)
            }
            BinOp.Greater -> {
                (*bin).typ = @type_info(bool)
            }
            BinOp.GreaterEq -> {
                (*bin).typ = @type_info(bool)
            }
            BinOp.And -> {
                (*bin).typ = @type_info(bool)
            }
            BinOp.Or -> {
                (*bin).typ = @type_info(bool)
            }
            BinOp.Move -> {
                (*bin).typ = (*(*bin).left).typ
            }
            BinOp.Pipe -> {
                (*workspace).error_handler.report_error_at((*bin).location, "Binary operator {} implemented", cast([]^any) ([cast(^any) ((*bin).operator)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
            BinOp.Range -> {
                (*workspace).error_handler.report_error_at((*bin).location, "Binary operator {} implemented", cast([]^any) ([cast(^any) ((*bin).operator)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
            BinOp.RangeIncl -> {
                (*workspace).error_handler.report_error_at((*bin).location, "Binary operator {} implemented", cast([]^any) ([cast(^any) ((*bin).operator)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
        }
        return cast(&AstNode) (bin)
    }
    
    compile_if(self: &CompileNode, iff: &AstIf, ctx: CNContext) -> &AstNode {
        (*(*iff).condition).scope = (*iff).scope
        self.compile_node((*iff).condition, ctx.with_expected(@type_info(bool)))
        if (cast(^void) ((*(*iff).condition).typ) == null) {
            return cast(&AstNode) (iff)
        } else {}
        match @tempvar_344(&*(*(*iff).condition).typ) {
            TypeInfoBool(_) -> {}
            TypeInfoPointer(_) -> {}
            _ -> {
                (*workspace).error_handler.report_error_at((*(*iff).condition).location, "Type of condition must be bool or pointer, but is {}", cast([]^any) ([cast(^any) ((*(*iff).condition).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
        }
        (*(*iff).true_case).scope = (*iff).scope
        self.compile_node((*iff).true_case, ctx)
        if (cast(^void) ((*iff).false_case) != null) {
            (*(*iff).false_case).scope = (*iff).scope
            self.compile_node(&*(*iff).false_case, ctx)
            if (cast(^void) ((*(*iff).true_case).typ) == cast(^void) ((*(*iff).false_case).typ)) {
                (*iff).typ = (*(*iff).true_case).typ
            } else {
                (*iff).typ = @type_info(void)
            }
        } else {
            (*iff).typ = @type_info(void)
        }
        return cast(&AstNode) (iff)
    }
    
    compile_impl(self: &CompileNode, node: &AstImpl, ctx: CNContext) -> &AstNode {
        (*(*node).target_expr).scope = (*node).scope
        self.compile_node((*node).target_expr, ctx.with_expected(@type_info(type)))
        #macro {
            local node : &AstNode = cast(&AstNode) (node)
            
            if ((*(*node).target_expr).value == Value.Poison) {
                (*node).typ = @type_info(void)
                (*node).value = Value.Poison
                return node
            } else {}
        }
        if (cast(^void) ((*(*node).target_expr).typ) != cast(^void) (@type_info(type))) {
            (*workspace).error_handler.report_error_at((*(*node).target_expr).location, "Target of impl block must be a type, found {}", cast([]^any) ([cast(^any) ((*(*node).target_expr).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
            poison(cast(&AstNode) (node))
            return cast(&AstNode) (node)
        } else {}
        if (cast(^void) ((*node).trait_expr) != null) {
            (*(*node).trait_expr).scope = (*node).scope
            self.compile_node(&*(*node).trait_expr, ctx.with_expected(@type_info(type)))
            #macro {
                local node : &AstNode = cast(&AstNode) (node)
                
                if ((*(*node).trait_expr).value == Value.Poison) {
                    (*node).typ = @type_info(void)
                    (*node).value = Value.Poison
                    return node
                } else {}
            }
        } else {}
        &*(*node).scope.add_impl(^*node)
        return cast(&AstNode) (node)
    }
    
    compile_import(self: &CompileNode, node: &AstImport, ctx: CNContext) -> &AstNode {
        match @tempvar_347((*node).path) {
            AstString($str) -> {
                (*str).typ = @type_info(void)
                search_paths : Array[string] = (Array[string]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                &search_paths.add(((fs).Path).get_containing_directory(((*node).location).file))
                &search_paths.add((*compiler).module_path)
                #macro {
                    local arr : &Array[string] = &search_paths
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &string = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    search_path : &string = it
                                    it_index : i64 = it_index
                                    {
                                        import_path : String = ((fs).Path).concat(*search_path, (*str).string_value)
                                        import_path_n : String = ((fs).Path).normalize(&import_path.slice())
                                        match @tempvar_349(&*compiler.get_source(&import_path_n.slice())) {
                                            Result[string, ()].Err(_) -> @destruct(import_path_n);
                                            @destruct(import_path);
                                            it_index = (it_index + 1);
                                            continue
                                        }
                                        match @tempvar_350(&*workspace.get_file(&import_path_n.slice())) {
                                            Option[^SourceFile].Some($file) -> {
                                                (*node).typ = &*workspace.new_module_type()
                                                (*node).value = Value.Module(file)
                                                @destruct(import_path_n);
                                                @destruct(import_path);
                                                it_index = (it_index + 1);
                                                @destruct(search_paths);
                                                return cast(&AstNode) (node)
                                            }
                                        }
                                        job : ^LoadFileJob = cast(^LoadFileJob) (&*workspace.create_and_add_job((LoadFileJob).new(&import_path_n.clone())))
                                        #macro {
                                            
                                            
                                            
                                            
                                            fiber_context : ^FiberContext = (Fiber).user_data()
                                            if (*(*fiber_context).job).cancelled {
                                                #link #anonymous {}
                                                loop {
                                                    (Fiber).yield()
                                                }
                                            } else {}
                                            (*(*fiber_context).job).progressed = true
                                            loop {
                                                if (*job).done then break else {}
                                                if DEBUG_WAIT then g_logger.log("suspending on {}", cast([]^any) ([cast(^any) (@expr_to_string((*job).done))]), (*fiber_context).job.get_name()) else {}
                                                #link #anonymous {}
                                                (Fiber).yield()
                                                #link #anonymous {}
                                                if DEBUG_WAIT then g_logger.log("resuming on {}", cast([]^any) ([cast(^any) (@expr_to_string((*job).done))]), (*fiber_context).job.get_name()) else {}
                                                (*(*fiber_context).job).progressed = false
                                                if (*(*fiber_context).job).cancelled {
                                                    #link #anonymous {}
                                                    loop {
                                                        (Fiber).yield()
                                                    }
                                                } else {}
                                            }
                                            if DEBUG_WAIT then g_logger.log("done on {}", cast([]^any) ([cast(^any) (@expr_to_string((*job).done))]), (*fiber_context).job.get_name()) else {}
                                            (*(*fiber_context).job).progressed = true
                                        }
                                        match @tempvar_351(&*workspace.get_file(&import_path_n.slice())) {
                                            Option[^SourceFile].Some($file) -> {
                                                (*node).typ = &*workspace.new_module_type()
                                                (*node).value = Value.Module(file)
                                                @destruct(import_path_n);
                                                @destruct(import_path);
                                                it_index = (it_index + 1);
                                                @destruct(search_paths);
                                                return cast(&AstNode) (node)
                                            }
                                        }
                                        @destruct(import_path_n)
                                        @destruct(import_path)
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                (*workspace).error_handler.report_error_at((*(*node).path).location, "Can't find file '{}'", cast([]^any) ([cast(^any) ((*str).string_value)]), "", details = cast([](fmt: string, args: []^any)) ([("Searched in '{}'", cast([]^any) ([cast(^any) (&search_paths.slice())]))]))
                poison(cast(&AstNode) (node))
                @destruct(search_paths);
                return cast(&AstNode) (node)
            }
            _ -> {
                (*workspace).error_handler.report_error_at((*(*node).path).location, "Invalid import path", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (node))
                return cast(&AstNode) (node)
            }
        }
        return cast(&AstNode) (node)
    }
    
    compile_index(self: &CompileNode, node: &AstIndex, ctx: CNContext) -> &AstNode {
        (*(*node).sub).scope = (*node).scope
        (*node).sub <- self.compile_node((*node).sub, ctx)
        #macro {
            local node : &AstNode = cast(&AstNode) (node)
            
            if ((*(*node).sub).value == Value.Poison) {
                (*node).typ = @type_info(void)
                (*node).value = Value.Poison
                return node
            } else {}
        }
        match @tempvar_352((*(*node).sub).value) {
            Value.Poly($poly) -> {
                if (&(*node).arguments.count() != ((*poly).params).length) {
                    (*workspace).error_handler.report_error_at((*node).location, "Wrong number of arguments. Expected {}", cast([]^any) ([cast(^any) (((*poly).params).length)]), "", cast([](fmt: string, args: []^any)) ([]))
                    poison(cast(&AstNode) (node))
                    return cast(&AstNode) (node)
                } else {
                    #macro {
                        local arr : &Array[^AstArgument] = &(*node).arguments
                        
                        local reverse : bool : false
                        local by_ref : bool : true
                        {
                            it_index : i64 = 0
                            loop {
                                if !(it_index < arr.get_length()) then break else {}
                                defer it_index = (it_index + 1)
                                #anonymous {
                                    #anonymous {
                                        it : &^AstArgument = access(&*arr, it_index)
                                    }
                                    #link #anonymous {
                                        arg : &^AstArgument = it
                                        it_index : i64 = it_index
                                        {
                                            param : &^AstDecl = access(&(*poly).params, it_index)
                                            (**arg).scope = (*node).scope
                                            self.evaluate_node(cast(&AstNode) (&**arg), ctx.with_expected((**param).var_type))
                                            if ((**arg).value == Value.Poison) {
                                                poison(cast(&AstNode) (node))
                                                it_index = (it_index + 1);
                                                return cast(&AstNode) (node)
                                            } else {}
                                            if !(TypeInfo).same((**arg).typ, (**param).var_type) {
                                                (*workspace).error_handler.report_error_at((**arg).location, "Type of argument ({}) does not match type of parameter '{}' ({}).", cast([]^any) ([cast(^any) ((**arg).typ), cast(^any) ((**param).name), cast(^any) ((**param).var_type)]), "", cast([](fmt: string, args: []^any)) ([]))
                                            } else {}
                                        }
                                    }
                                }
                                it_index = (it_index + 1)
                            }
                        }
                    }
                }
                cloner : AstCloner = new AstCloner { _next_id = (*workspace).next_ast_id, allocator = (*workspace).ast_allocator }
                clone : ^AstNode = &cloner.clone(^*(*poly).value_expr)
                if (cast(^void) (clone) == null) {
                    poison(cast(&AstNode) (node))
                    return cast(&AstNode) (node)
                } else {}
                scope : ^Scope = &*workspace.new_scope((*poly).scope, false)
                #macro {
                    local arr : &Array[^AstArgument] = &(*node).arguments
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstArgument = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    arg : &^AstArgument = it
                                    it_index : i64 = it_index
                                    {
                                        param : &^AstDecl = access(&(*poly).params, it_index)
                                        &*scope.define_value((**param).name, (**arg).typ, (**arg).value)
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                (*clone).scope = scope
                result : &AstNode = self.evaluate_node(&*clone, ctx)
                (*node).typ = (*result).typ
                (*node).value = (*result).value
                return cast(&AstNode) (node)
            }
        }
        match @tempvar_353((*(*node).sub).typ) {
            TypeInfoArray($ti) -> {
                #macro {
                    local arr : &Array[^AstArgument] = &(*node).arguments
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstArgument = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    arg : &^AstArgument = it
                                    it_index : i64 = it_index
                                    {
                                        (**arg).scope = (*node).scope
                                        self.compile_node(cast(&AstNode) (&**arg), ctx)
                                        #macro {
                                            local node : &AstNode = cast(&AstNode) (node)
                                            
                                            if ((**arg).value == Value.Poison) {
                                                (*node).typ = @type_info(void)
                                                (*node).value = Value.Poison
                                                it_index = (it_index + 1);
                                                return node
                                            } else {}
                                        }
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                (*node).index = cast(^AstNode) (*access(&(*node).arguments, 0))
                if (&(*node).arguments.count() != 1) {
                    (*workspace).error_handler.report_error_at((*node).location, "Wrong number of arguments. Expected 1", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                    poison(cast(&AstNode) (node))
                    return cast(&AstNode) (node)
                } else {}
                match @tempvar_355((*(*node).index).typ) {
                    TypeInfoInt(_) -> {
                        (*node).typ = (*ti).target
                    }
                    _ -> {
                        (*workspace).error_handler.report_error_at((*(*node).index).location, "Type '{}' can't be used as index for type '{}'", cast([]^any) ([cast(^any) ((*(*node).index).typ), cast(^any) ((*(*node).sub).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                        poison(cast(&AstNode) (node))
                        return cast(&AstNode) (node)
                    }
                }
            }
            _ -> {
                (*workspace).error_handler.report_error_at((*(*node).sub).location, "Type '{}' has not operator '[]'", cast([]^any) ([cast(^any) ((*(*node).sub).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (node))
                return cast(&AstNode) (node)
            }
        }
        return cast(&AstNode) (node)
    }
    
    compile_loop(self: &CompileNode, lop: &AstLoop, ctx: CNContext) -> &AstNode {
        (*lop).typ = @type_info(void)
        (*(*lop).body).scope = (*lop).scope
        self.compile_node((*lop).body, ctx)
        return cast(&AstNode) (lop)
    }
    
    compile_for(self: &CompileNode, forr: &AstFor, ctx: CNContext) -> &AstNode {
        (*forr).typ = @type_info(void)
        (*(*forr).collection).scope = (*forr).scope
        self.compile_node((*forr).collection, ctx.with_expected(null))
        (*(*forr).body).scope = (*forr).scope
        self.compile_node((*forr).body, ctx)
        return cast(&AstNode) (forr)
    }
    
    compile_break(self: &CompileNode, brake: &AstBreak, ctx: CNContext) -> &AstNode {
        (*brake).typ = @type_info(void)
        if (cast(^void) ((*brake).value_expr) != null) {
            (*(*brake).value_expr).scope = (*brake).scope
            self.compile_node(&*(*brake).value_expr, ctx)
        } else {}
        return cast(&AstNode) (brake)
    }
    
    compile_continue(self: &CompileNode, cont: &AstContinue, ctx: CNContext) -> &AstNode {
        (*cont).typ = @type_info(void)
        return cast(&AstNode) (cont)
    }
    
    compile_return(self: &CompileNode, ret: &AstReturn, ctx: CNContext) -> &AstNode {
        if (cast(^void) ((*self).function) == null) {
            (*workspace).error_handler.report_error_at((*ret).location, "Can't use return outside of a function", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
            return cast(&AstNode) (ret)
        } else {}
        (*ret).typ = @type_info(void)
        if (cast(^void) ((*ret).value_expr) != null) {
            (*(*ret).value_expr).scope = (*ret).scope
            self.compile_node(&*(*ret).value_expr, ctx.with_expected((*(*self).function).return_type))
            if !(TypeInfo).same((*(*ret).value_expr).typ, (*(*self).function).return_type) {
                (*workspace).error_handler.report_error_at((*(*ret).value_expr).location, "Type of return value ({}) does not match return type of containing function ({}).", cast([]^any) ([cast(^any) ((*(*ret).value_expr).typ), cast(^any) ((*(*self).function).return_type)]), "", cast([](fmt: string, args: []^any)) ([]))
            } else {}
        } else {}
        return cast(&AstNode) (ret)
    }
    
    compile_defer(self: &CompileNode, def: &AstDefer, ctx: CNContext) -> &AstNode {
        (*def).typ = @type_info(void)
        (*(*def).sub).scope = (*def).scope
        self.compile_node((*def).sub, ctx.with_expected(null))
        return cast(&AstNode) (def)
    }
    
    compile_string(self: &CompileNode, str: &AstString, ctx: CNContext) -> &AstNode {
        (*str).typ = @type_info(string)
        (*str).value = Value.String((*str).string_value)
        return cast(&AstNode) (str)
    }
    
    compile_struct(self: &CompileNode, str: &AstStruct, ctx: CNContext) -> &AstNode {
        (*str).typ = @type_info(type)
        (*str).sub_scope = &*workspace.new_scope((*str).scope, false)
        jobs : Array[^CompileStructMemberJob] = (Array[^CompileStructMemberJob]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        #macro {
            local arr : &Array[^AstNode] = &(*str).children
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &^AstNode = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            child : &^AstNode = it
                            it_index : i64 = it_index
                            {
                                (**child).scope = (*str).sub_scope
                                &**child.set_flags(AstNodeFlags.AllowPubModifier)
                                job : ^CompilationJob = &*workspace.create_job((CompileStructMemberJob).new(^*str, *child))
                                &jobs.add(cast (job))
                                &*workspace.add_job(job)
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        #macro {
            local arr : &Array[^CompileStructMemberJob] = &jobs
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &^CompileStructMemberJob = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            job : &^CompileStructMemberJob = it
                            it_index : i64 = it_index
                            {
                                #macro {
                                    
                                    
                                    
                                    
                                    fiber_context : ^FiberContext = (Fiber).user_data()
                                    if (*(*fiber_context).job).cancelled {
                                        #link #anonymous {}
                                        loop {
                                            (Fiber).yield()
                                        }
                                    } else {}
                                    (*(*fiber_context).job).progressed = true
                                    loop {
                                        if (**job).done then break else {}
                                        if DEBUG_WAIT then g_logger.log("suspending on {}", cast([]^any) ([cast(^any) (@expr_to_string((**job).done))]), (*fiber_context).job.get_name()) else {}
                                        #link #anonymous {}
                                        (Fiber).yield()
                                        #link #anonymous {}
                                        if DEBUG_WAIT then g_logger.log("resuming on {}", cast([]^any) ([cast(^any) (@expr_to_string((**job).done))]), (*fiber_context).job.get_name()) else {}
                                        (*(*fiber_context).job).progressed = false
                                        if (*(*fiber_context).job).cancelled {
                                            #link #anonymous {}
                                            loop {
                                                (Fiber).yield()
                                            }
                                        } else {}
                                    }
                                    if DEBUG_WAIT then g_logger.log("done on {}", cast([]^any) ([cast(^any) (@expr_to_string((**job).done))]), (*fiber_context).job.get_name()) else {}
                                    (*(*fiber_context).job).progressed = true
                                }
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        (*str).members_done = true
        member_type_infos : []TypeInfoStructMember = &*workspace.new_type_data_array(&(*str).members.count())
        #macro {
            local arr : &Array[^AstDecl] = &(*str).members
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &^AstDecl = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            mem : &^AstDecl = it
                            it_index : i64 = it_index
                            {
                                (*get_index(member_type_infos, it_index)).index = it_index
                                (*get_index(member_type_infos, it_index)).name = (**mem).name
                                (*get_index(member_type_infos, it_index)).typ = (**mem).var_type
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        (*str).struct_type = cast(^TypeInfo) (&*workspace.new_type(new TypeInfoStruct {
            size = -1
            alignment = -1
            traits = cast([]TypeInfoTraitImpl) ([])
            impl_funcs = cast([]TypeInfoImplFunction) ([])
            name = (*str).name
            members = member_type_infos
        }))
        &*workspace.register_struct(cast ((*str).struct_type), ^*str)
        {
            alignment : i64 = 1
            size : i64 = 0
            #macro {
                local arr : &Array[^AstDecl] = &(*str).members
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstDecl = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                mem : &^AstDecl = it
                                it_index : i64 = it_index
                                {
                                    #macro {
                                        
                                        
                                        
                                        
                                        fiber_context : ^FiberContext = (Fiber).user_data()
                                        if (*(*fiber_context).job).cancelled {
                                            #link #anonymous {
                                                (*workspace).error_handler.report_error_at((*str).location, "Failed to compute size and alignment of struct type. Size of member '{}' unknown", cast([]^any) ([cast(^any) ((**mem).name)]), "", cast([](fmt: string, args: []^any)) ([]))
                                            }
                                            loop {
                                                (Fiber).yield()
                                            }
                                        } else {}
                                        (*(*fiber_context).job).progressed = true
                                        loop {
                                            if (((*(**mem).var_type).size >= 0) and ((*(**mem).var_type).alignment >= 0)) then break else {}
                                            if DEBUG_WAIT then g_logger.log("suspending on {}", cast([]^any) ([cast(^any) (@expr_to_string((((*(**mem).var_type).size >= 0) and ((*(**mem).var_type).alignment >= 0))))]), (*fiber_context).job.get_name()) else {}
                                            #link #anonymous {}
                                            (Fiber).yield()
                                            #link #anonymous {}
                                            if DEBUG_WAIT then g_logger.log("resuming on {}", cast([]^any) ([cast(^any) (@expr_to_string((((*(**mem).var_type).size >= 0) and ((*(**mem).var_type).alignment >= 0))))]), (*fiber_context).job.get_name()) else {}
                                            (*(*fiber_context).job).progressed = false
                                            if (*(*fiber_context).job).cancelled {
                                                #link #anonymous {
                                                    (*workspace).error_handler.report_error_at((*str).location, "Failed to compute size and alignment of struct type. Size of member '{}' unknown", cast([]^any) ([cast(^any) ((**mem).name)]), "", cast([](fmt: string, args: []^any)) ([]))
                                                }
                                                loop {
                                                    (Fiber).yield()
                                                }
                                            } else {}
                                        }
                                        if DEBUG_WAIT then g_logger.log("done on {}", cast([]^any) ([cast(^any) (@expr_to_string((((*(**mem).var_type).size >= 0) and ((*(**mem).var_type).alignment >= 0))))]), (*fiber_context).job.get_name()) else {}
                                        (*(*fiber_context).job).progressed = true
                                    }
                                    (*get_index(member_type_infos, it_index)).offset = (util).next_aligned_num(size, (*(**mem).var_type).alignment)
                                    alignment = max(alignment, (*(**mem).var_type).alignment)
                                    size = (size + (*(**mem).var_type).size)
                                    size = (util).next_aligned_num(size, (*(**mem).var_type).alignment)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            size = (util).next_aligned_num(size, alignment)
            (*(*str).struct_type).size = size
            (*(*str).struct_type).alignment = alignment
        }
        (*str).value = Value.Type((*str).struct_type)
        @destruct(jobs);
        return cast(&AstNode) (str)
    }
    
    compile_bool(self: &CompileNode, bol: &AstBool, ctx: CNContext) -> &AstNode {
        (*bol).typ = @type_info(bool)
        (*bol).value = Value.Bool((*bol).bool_value)
        return cast(&AstNode) (bol)
    }
    
    compile_number(self: &CompileNode, num: &AstNumberLiteral, ctx: CNContext) -> &AstNode {
        (*num).typ = match @tempvar_357((*num).value) {
            Value.Int(_) -> @type_info(int)
            Value.Float(_) -> @type_info(f64)
            _ -> @assert(false)
        }
        return cast(&AstNode) (num)
    }
    
    compile_poly(self: &CompileNode, poly: &AstPoly, ctx: CNContext) -> &AstNode {
        (*poly).param_scope = &*workspace.new_scope((*poly).scope, false)
        (*(*poly).value_expr).scope = (*poly).param_scope
        match @tempvar_358((*poly).value_expr) {
            AstFunction($func) -> {
                (*func).name = (*poly).name
            }
            AstStruct($str) -> {
                (*str).name = (*poly).name
            }
            AstEnum($en) -> {
                (*en).name = (*poly).name
            }
            AstTrait($tr) -> {
                (*tr).name = (*poly).name
            }
            AstPoly($poly) -> {
                (*poly).name = (*poly).name
            }
        }
        #macro {
            local arr : &Array[^AstDecl] = &(*poly).params
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &^AstDecl = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            param : &^AstDecl = it
                            it_index : i64 = it_index
                            {
                                (**param).scope = (*poly).scope
                                self.compile_node(cast(&AstNode) (&**param), ctx.with_expected(null))
                                #macro {
                                    local node : &AstNode = cast(&AstNode) (poly)
                                    
                                    if ((**param).value == Value.Poison) {
                                        (*node).typ = @type_info(void)
                                        (*node).value = Value.Poison
                                        it_index = (it_index + 1);
                                        return node
                                    } else {}
                                }
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        (*poly).typ = @type_info(void)
        (*poly).value = Value.Poly(^*poly)
        return cast(&AstNode) (poly)
    }
    
    compile_identifier(self: &CompileNode, id: &AstIdentifier, ctx: CNContext) -> &AstNode {
        (*id).symbol = &*(*id).scope.get_symbol((*id).name, (AstNode).has_flags(cast(&AstNode) (id), AstNodeFlags.OnlyPubDeclarations))
        match @tempvar_364((*id).symbol) {
            Symbol.Val($value) -> {
                (*id).typ = (value).typ
                (*id).value = (value).value
            }
            Symbol.ConstDecl($decl) -> {
                #macro {
                    
                    
                    
                    
                    fiber_context : ^FiberContext = (Fiber).user_data()
                    if (*(*fiber_context).job).cancelled {
                        #link #anonymous {
                            (*workspace).error_handler.report_error_at((*id).location, "Failed to get value and type of constant declaration", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                        }
                        loop {
                            (Fiber).yield()
                        }
                    } else {}
                    (*(*fiber_context).job).progressed = true
                    loop {
                        if (((*(*decl).value_expr).value != Value.None) and (cast(^void) ((*(*decl).value_expr).typ) != null)) then break else {}
                        if DEBUG_WAIT then g_logger.log("suspending on {}", cast([]^any) ([cast(^any) (@expr_to_string((((*(*decl).value_expr).value != Value.None) and (cast(^void) ((*(*decl).value_expr).typ) != null))))]), (*fiber_context).job.get_name()) else {}
                        #link #anonymous {}
                        (Fiber).yield()
                        #link #anonymous {}
                        if DEBUG_WAIT then g_logger.log("resuming on {}", cast([]^any) ([cast(^any) (@expr_to_string((((*(*decl).value_expr).value != Value.None) and (cast(^void) ((*(*decl).value_expr).typ) != null))))]), (*fiber_context).job.get_name()) else {}
                        (*(*fiber_context).job).progressed = false
                        if (*(*fiber_context).job).cancelled {
                            #link #anonymous {
                                (*workspace).error_handler.report_error_at((*id).location, "Failed to get value and type of constant declaration", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                            }
                            loop {
                                (Fiber).yield()
                            }
                        } else {}
                    }
                    if DEBUG_WAIT then g_logger.log("done on {}", cast([]^any) ([cast(^any) (@expr_to_string((((*(*decl).value_expr).value != Value.None) and (cast(^void) ((*(*decl).value_expr).typ) != null))))]), (*fiber_context).job.get_name()) else {}
                    (*(*fiber_context).job).progressed = true
                }
                (*id).typ = (*(*decl).value_expr).typ
                (*id).value = (*(*decl).value_expr).value
            }
            Symbol.Decl($decl) -> {
                #macro {
                    
                    
                    
                    
                    fiber_context : ^FiberContext = (Fiber).user_data()
                    if (*(*fiber_context).job).cancelled {
                        #link #anonymous {
                            (*workspace).error_handler.report_error_at((*id).location, "Failed to get type of declaration", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                        }
                        loop {
                            (Fiber).yield()
                        }
                    } else {}
                    (*(*fiber_context).job).progressed = true
                    loop {
                        if (cast(^void) ((*decl).var_type) != null) then break else {}
                        if DEBUG_WAIT then g_logger.log("suspending on {}", cast([]^any) ([cast(^any) (@expr_to_string((cast(^void) ((*decl).var_type) != null)))]), (*fiber_context).job.get_name()) else {}
                        #link #anonymous {}
                        (Fiber).yield()
                        #link #anonymous {}
                        if DEBUG_WAIT then g_logger.log("resuming on {}", cast([]^any) ([cast(^any) (@expr_to_string((cast(^void) ((*decl).var_type) != null)))]), (*fiber_context).job.get_name()) else {}
                        (*(*fiber_context).job).progressed = false
                        if (*(*fiber_context).job).cancelled {
                            #link #anonymous {
                                (*workspace).error_handler.report_error_at((*id).location, "Failed to get type of declaration", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                            }
                            loop {
                                (Fiber).yield()
                            }
                        } else {}
                    }
                    if DEBUG_WAIT then g_logger.log("done on {}", cast([]^any) ([cast(^any) (@expr_to_string((cast(^void) ((*decl).var_type) != null)))]), (*fiber_context).job.get_name()) else {}
                    (*(*fiber_context).job).progressed = true
                }
                (AstNode).set_flags(cast(&AstNode) (id), AstNodeFlags.LValue)
                (*id).typ = (*decl).var_type
            }
            Symbol.NativeFunc($func) -> {
                (*id).typ = cast ((*func).function_type)
                (*id).value = Value.NativeFunc(func)
            }
            Symbol.NotFound -> {
                (*workspace).error_handler.report_error_at((*id).location, "Unknown symbol '{}'", cast([]^any) ([cast(^any) ((*id).name)]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (id))
                loop {
                    (Fiber).yield()
                }
                return cast(&AstNode) (id)
            }
            Symbol.Private($node) -> {
                (*workspace).error_handler.report_error_at((*id).location, "Can't access '{}' from here because it's not public", cast([]^any) ([cast(^any) ((*id).name)]), "", details = cast([](fmt: string, args: []^any)) ([("'{}' defined here: {}", cast([]^any) ([cast(^any) ((*id).name), cast(^any) ((*node).location)]))]))
                poison(cast(&AstNode) (id))
                return cast(&AstNode) (id)
            }
            Symbol.Poison -> {
                (*workspace).error_handler.report_error_at((*id).location, "Can't use variable '{}' in constant context", cast([]^any) ([cast(^any) ((*id).name)]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (id))
                return cast(&AstNode) (id)
            }
            $sym -> {
                (*workspace).error_handler.report_error_at((*id).location, "[compile_identifier] not implemented: {}", cast([]^any) ([cast(^any) (sym)]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (id))
                return cast(&AstNode) (id)
            }
        }
        return cast(&AstNode) (id)
    }
    
    compile_argument(self: &CompileNode, arg: &AstArgument, ctx: CNContext) -> &AstNode {
        (*(*arg).value_expr).scope = (*arg).scope
        (*arg).value_expr <- self.compile_node((*arg).value_expr, ctx)
        (*arg).typ = (*(*arg).value_expr).typ
        (*arg).value = (*(*arg).value_expr).value
        return cast(&AstNode) (arg)
    }
    
    compile_cast(self: &CompileNode, cst: &AstCast, ctx: CNContext) -> &AstNode {
        if (cast(^void) ((*cst).type_expr) == null) {
            (*workspace).error_handler.report_error_at((*cst).location, "Auto cast not implemented yet.", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
            poison(cast(&AstNode) (cst))
            return cast(&AstNode) (cst)
        } else {}
        (*(*cst).type_expr).scope = (*cst).scope
        (*cst).type_expr = ^*self.evaluate_node(&*(*cst).type_expr, ctx.with_expected(@type_info(type)))
        if ((*(*cst).type_expr).value == Value.Poison) {
            poison(cast(&AstNode) (cst))
            return cast(&AstNode) (cst)
        } else {}
        if (cast(^void) ((*(*cst).type_expr).typ) != cast(^void) (@type_info(type))) {
            (*workspace).error_handler.report_error_at((*cst).location, "Expected type, got ({})", cast([]^any) ([cast(^any) ((*(*cst).type_expr).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
            poison(cast(&AstNode) (cst))
            return cast(&AstNode) (cst)
        } else {}
        @assert(((*(*cst).type_expr).value == Value.Type))
        (*cst).typ = ((*(*cst).type_expr).value).Type
        (*(*cst).value_expr).scope = (*cst).scope
        (*cst).value_expr <- self.compile_node((*cst).value_expr, ctx.with_expected((*cst).typ))
        if ((*(*cst).value_expr).value == Value.Poison) {
            poison(cast(&AstNode) (cst))
            return cast(&AstNode) (cst)
        } else {}
        if (cast(^void) ((*(*cst).value_expr).typ) == cast(^void) ((*cst).typ)) {
            return (*cst).value_expr
        } else {}
        return cast(&AstNode) (cst)
    }
    
    compile_call(self: &CompileNode, call: &AstCall, ctx: CNContext) -> &AstNode {
        (*(*call).function).scope = (*call).scope
        (*call).function <- self.compile_node((*call).function, ctx.with_expected(null))
        if ((*(*call).function).value == Value.Poison) {
            poison(cast(&AstNode) (call))
            return cast(&AstNode) (call)
        } else {}
        match @tempvar_365((*call).function) {
            AstUfc($ufc) -> {
                new_args : Array[^AstArgument] = (Array[^AstArgument]).create((&(*call).arguments.count() + 1), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                &new_args.add(&*workspace.new_ast(new AstArgument {
                    location = (*ufc).location
                    scope = (*ufc).scope
                    name = null
                    value_expr = (*ufc).value_expr
                    id = -1
                    typ = null
                    value = Value.None
                    flags = 0
                }))
                #macro {
                    local arr : &Array[^AstArgument] = &(*call).arguments
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstArgument = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    arg : &^AstArgument = it
                                    it_index : i64 = it_index
                                    {
                                        &new_args.add(*arg)
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                @destruct((*call).arguments);
                (*call).arguments = new_args
            }
        }
        {}
        match @tempvar_367((*(*call).function).value) {
            Value.Type($typ) -> {
                if (&(*call).arguments.count() != 1) {
                    #anonymous {
                        (*workspace).error_handler.report_error_at((*call).location, "Cast requires exactly one argument", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                        poison(cast(&AstNode) (call))
                    }
                    return cast(&AstNode) (call)
                } else {}
                cast_ast : ^AstCast = &*workspace.new_ast(new AstCast {
                    id = -1
                    location = (*call).location
                    scope = (*call).scope
                    type_expr = ^*(*call).function
                    value_expr = cast(&AstNode) (&**access(&(*call).arguments, 0))
                    typ = null
                    value = Value.None
                    flags = 0
                })
                return self.compile_node(cast(&AstNode) (&*cast_ast), ctx)
            }
            Value.Function($func) -> {
                (*call).ast_function = func
                if (&(*call).arguments.count() != ((*func).params).length) {
                    (*workspace).error_handler.report_error_at((*call).location, "Wrong number of arguments in function call", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                } else {
                    #macro {
                        local arr : &Array[^AstArgument] = &(*call).arguments
                        
                        local reverse : bool : false
                        local by_ref : bool : true
                        {
                            it_index : i64 = 0
                            loop {
                                if !(it_index < arr.get_length()) then break else {}
                                defer it_index = (it_index + 1)
                                #anonymous {
                                    #anonymous {
                                        it : &^AstArgument = access(&*arr, it_index)
                                    }
                                    #link #anonymous {
                                        arg : &^AstArgument = it
                                        it_index : i64 = it_index
                                        {
                                            param : &^AstDecl = access(&(*func).params, it_index)
                                            (**arg).scope = (*call).scope
                                            *arg = cast (^*self.compile_node(cast(&AstNode) (&**arg), ctx.with_expected((**param).var_type)))
                                            if ((**arg).value == Value.Poison) {
                                                poison(cast(&AstNode) (call))
                                                it_index = (it_index + 1);
                                                return cast(&AstNode) (call)
                                            } else {}
                                            if !(TypeInfo).same((**arg).typ, (**param).var_type) {
                                                (*workspace).error_handler.report_error_at((**arg).location, "Type of argument ({}) does not match type of parameter '{}' ({}).", cast([]^any) ([cast(^any) ((**arg).typ), cast(^any) ((**param).name), cast(^any) ((**param).var_type)]), "", cast([](fmt: string, args: []^any)) ([]))
                                            } else {}
                                        }
                                    }
                                }
                                it_index = (it_index + 1)
                            }
                        }
                    }
                }
                (*call).typ = (*func).return_type
            }
            Value.NativeFunc($func) -> {
                func_type : ^TypeInfoFunction = cast(^TypeInfoFunction) ((*(*call).function).typ)
                (*call).typ = (*func_type).return_type
                if (&(*call).arguments.count() != ((*func_type).param_types).length) {
                    (*workspace).error_handler.report_error_at((*call).location, "Wrong number of arguments ({}) in function call. Expected {}", cast([]^any) ([cast(^any) (&(*call).arguments.count()), cast(^any) (((*func_type).param_types).length)]), "", cast([](fmt: string, args: []^any)) ([]))
                } else {
                    #macro {
                        local arr : &Array[^AstArgument] = &(*call).arguments
                        
                        local reverse : bool : false
                        local by_ref : bool : true
                        {
                            it_index : i64 = 0
                            loop {
                                if !(it_index < arr.get_length()) then break else {}
                                defer it_index = (it_index + 1)
                                #anonymous {
                                    #anonymous {
                                        it : &^AstArgument = access(&*arr, it_index)
                                    }
                                    #link #anonymous {
                                        arg : &^AstArgument = it
                                        it_index : i64 = it_index
                                        {
                                            param_type : ^TypeInfo = *get_index((*func_type).param_types, it_index)
                                            (**arg).scope = (*call).scope
                                            *arg = cast (^*self.compile_node(cast(&AstNode) (&**arg), ctx.with_expected(param_type)))
                                            if ((**arg).value == Value.Poison) {
                                                poison(cast(&AstNode) (call))
                                                it_index = (it_index + 1);
                                                return cast(&AstNode) (call)
                                            } else {}
                                            if !(TypeInfo).same((**arg).typ, param_type) {
                                                (*workspace).error_handler.report_error_at((**arg).location, "Type of argument ({}) does not match type of parameter ({}).", cast([]^any) ([cast(^any) ((**arg).typ), cast(^any) (param_type)]), "", cast([](fmt: string, args: []^any)) ([]))
                                            } else {}
                                        }
                                    }
                                }
                                it_index = (it_index + 1)
                            }
                        }
                    }
                }
            }
            Value.NativeFunc2($func) -> {
                func_type : ^TypeInfoFunction = cast(^TypeInfoFunction) ((*(*call).function).typ)
                (*call).typ = (*func_type).return_type
                if (&(*call).arguments.count() != ((*func_type).param_types).length) {
                    (*workspace).error_handler.report_error_at((*call).location, "Wrong number of arguments ({}) in function call. Expected {}", cast([]^any) ([cast(^any) (&(*call).arguments.count()), cast(^any) (((*func_type).param_types).length)]), "", cast([](fmt: string, args: []^any)) ([]))
                } else {
                    #macro {
                        local arr : &Array[^AstArgument] = &(*call).arguments
                        
                        local reverse : bool : false
                        local by_ref : bool : true
                        {
                            it_index : i64 = 0
                            loop {
                                if !(it_index < arr.get_length()) then break else {}
                                defer it_index = (it_index + 1)
                                #anonymous {
                                    #anonymous {
                                        it : &^AstArgument = access(&*arr, it_index)
                                    }
                                    #link #anonymous {
                                        arg : &^AstArgument = it
                                        it_index : i64 = it_index
                                        {
                                            param_type : ^TypeInfo = *get_index((*func_type).param_types, it_index)
                                            (**arg).scope = (*call).scope
                                            *arg = cast (^*self.compile_node(cast(&AstNode) (&**arg), ctx.with_expected(param_type)))
                                            if ((**arg).value == Value.Poison) {
                                                poison(cast(&AstNode) (call))
                                                it_index = (it_index + 1);
                                                return cast(&AstNode) (call)
                                            } else {}
                                            if !(TypeInfo).same((**arg).typ, param_type) {
                                                (*workspace).error_handler.report_error_at((**arg).location, "Type of argument ({}) does not match type of parameter ({}).", cast([]^any) ([cast(^any) ((**arg).typ), cast(^any) (param_type)]), "", cast([](fmt: string, args: []^any)) ([]))
                                            } else {}
                                        }
                                    }
                                }
                                it_index = (it_index + 1)
                            }
                        }
                    }
                }
            }
            $val -> {
                (*workspace).error_handler.report_error_at((*(*call).function).location, "[compile_call] not implemented: {}", cast([]^any) ([cast(^any) (val)]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (call))
                return cast(&AstNode) (call)
            }
        }
        return cast(&AstNode) (call)
    }
    
    compile_block(self: &CompileNode, block: &AstBlock, ctx: CNContext) -> &AstNode {
        (*block).sub_scope = &*workspace.new_scope((*block).scope, false)
        #macro {
            local arr : &Array[^AstNode] = &(*block).children
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &^AstNode = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            child : &^AstNode = it
                            it_index : i64 = it_index
                            {
                                (**child).scope = (*block).sub_scope
                                expected : ^TypeInfo = if (it_index == (&(*block).children.count() - 1)) then (ctx).expected else null
                                *child = ^*self.compile_node(&**child, ctx.with_expected(expected))
                                if ((**child).value == Value.Poison) {
                                    poison(cast(&AstNode) (block))
                                    it_index = (it_index + 1);
                                    return cast(&AstNode) (block)
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        if (&(*block).children.count() > 0) {
            (*block).typ = (**&(*block).children.peek_last()).typ
        } else {
            (*block).typ = @type_info(void)
        }
        return cast(&AstNode) (block)
    }
    
    compile_function(self: &CompileNode, func: &AstFunction, ctx: CNContext) -> &AstNode {
        _prev_func : ^AstFunction = (*self).function
        (*self).function = ^*func
        defer (*self).function = _prev_func
        self.debug_log("compile_function '{}': Begin", cast([]^any) ([cast(^any) ((*func).name)]))
        (*func).param_scope = &*workspace.new_scope((*func).scope, false)
        (*(*func).body).scope = (*func).param_scope
        (*func).value = Value.Function(^*func)
        param_types : []^TypeInfo = (mem).alloc_n(cast (&(*func).params.count()), (*workspace).type_allocator)
        #macro {
            local arr : &Array[^AstDecl] = &(*func).params
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &^AstDecl = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            param : &^AstDecl = it
                            it_index : i64 = it_index
                            {
                                (**param).scope = (*func).param_scope
                                (**param).name = match @tempvar_368((**param).pattern) {
                                    AstIdentifier($id) -> (*id).name
                                    _ if (cast(^void) ((**param).pattern) == null) -> "_"
                                    _ -> {
                                        (*workspace).error_handler.report_error_at((**param).location, "Non-identifier patterns not implemented yet", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                                        it_index = (it_index + 1);
                                        (*self).function = _prev_func;
                                        return cast(&AstNode) (func)
                                    }
                                }
                                if (cast(^void) ((**param).type_expr) != null) {
                                    (*(**param).type_expr).scope = (**param).scope
                                    (**param).type_expr = ^*self.compile_node(&*(**param).type_expr, ctx.with_expected(@type_info(type)))
                                    if (cast(^void) ((*(**param).type_expr).typ) != cast(^void) (@type_info(type))) {
                                        (*workspace).error_handler.report_error_at((*(**param).type_expr).location, "Expected type, got {}", cast([]^any) ([cast(^any) ((*(**param).type_expr).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                                        it_index = (it_index + 1);
                                        (*self).function = _prev_func;
                                        return cast(&AstNode) (func)
                                    } else {
                                        @assert(((*(**param).type_expr).value == Value.Type))
                                        (**param).var_type = ((*(**param).type_expr).value).Type
                                    }
                                } else {}
                                if (cast(^void) ((**param).value_expr) != null) {
                                    (**param).value_expr = ^*self.compile_node(&*(**param).value_expr, ctx.with_expected((**param).var_type))
                                    if (cast(^void) ((*(**param).value_expr).typ) == null) {
                                        it_index = (it_index + 1);
                                        (*self).function = _prev_func;
                                        return cast(&AstNode) (func)
                                    } else {}
                                    (**param).value = (*(**param).value_expr).value
                                    if (cast(^void) ((**param).var_type) == null) {
                                        (**param).var_type = (*(**param).value_expr).typ
                                    } else {}
                                } else {}
                                if strings_not_equal((**param).name, "_") {
                                    match @tempvar_370(&*(**param).scope.define_decl((**param).name, &**param)) {
                                        Result[(), ()].Err -> {
                                            (*workspace).error_handler.report_error_at((*(**param).pattern).location, "A parameter with this name already exists", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                                        }
                                    }
                                } else {}
                                *get_index(param_types, it_index) = (**param).var_type
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        (*func).return_type = @type_info(void)
        if (cast(^void) ((*func).return_type_expr) != null) {
            (*(*func).return_type_expr).scope = (*func).param_scope
            (*func).return_type_expr = ^*self.compile_node(&*(*func).return_type_expr, ctx.with_expected(@type_info(type)))
            if ((*(*func).return_type_expr).value == Value.Poison) {
                poison(cast(&AstNode) (func))
                (*self).function = _prev_func;
                return cast(&AstNode) (func)
            } else if (cast(^void) ((*(*func).return_type_expr).typ) != cast(^void) (@type_info(type))) {
                (*workspace).error_handler.report_error_at((*(*func).return_type_expr).location, "Expected type, got {}", cast([]^any) ([cast(^any) ((*(*func).return_type_expr).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                poison(cast(&AstNode) (func))
                (*self).function = _prev_func;
                return cast(&AstNode) (func)
            } else {
                @assert(((*(*func).return_type_expr).value == Value.Type))
                (*func).return_type = ((*(*func).return_type_expr).value).Type
            }
        } else {}
        (*func).typ = cast(^TypeInfo) (&*workspace.new_type(new TypeInfoFunction {
            size = 8
            alignment = 8
            traits = cast([]TypeInfoTraitImpl) ([])
            impl_funcs = cast([]TypeInfoImplFunction) ([])
            param_types = param_types
            return_type = (*func).return_type
        }))
        self.debug_log("compile_function '{}': Compile Body", cast([]^any) ([cast(^any) ((*func).name)]))
        (*func).body = ^*self.compile_node(&*(*func).body, ctx.with_expected(null))
        if ((*(*func).body).value == Value.Poison) {
            poison(cast(&AstNode) (func))
            (*self).function = _prev_func;
            return cast(&AstNode) (func)
        } else {}
        self.debug_log("compile_function '{}': Generate Bytecode", cast([]^any) ([cast(^any) ((*func).name)]))
        code_gen : Rc[ByteCodeGenerator] = (ByteCodeGenerator).new(&(*workspace).string_database, &*(*workspace).error_handler, (*workspace).bc_allocator)
        &code_gen.get().generate_code_for_function(^*func)
        self.debug_log("compile_function '{}': End", cast([]^any) ([cast(^any) ((*func).name)]))
        @destruct(code_gen);
        (*self).function = _prev_func;
        return cast(&AstNode) (func)
    }
    
    compile_decl(self: &CompileNode, decl: &AstDecl, ctx: CNContext) -> &AstNode {
        (*decl).typ = @type_info(void)
        if !(AstNode).has_flags(cast(&AstNode) (decl), AstNodeFlags.IsDefinedInScope) {
            (*decl).name = match @tempvar_371(&*(*decl).pattern) {
                AstIdentifier($id) -> (*id).name
                _ -> {
                    (*workspace).error_handler.report_error_at((*decl).location, "Non-identifier patterns not implemented yet", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                    return cast(&AstNode) (decl)
                }
            }
            if strings_not_equal((*decl).name, "_") {
                match @tempvar_373(&*(*decl).scope.define_decl((*decl).name, decl)) {
                    Result[(), ()].Err -> {
                        (*workspace).error_handler.report_error_at((*(*decl).pattern).location, "A symbol with this name already exists in this scope", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                    }
                }
            } else {}
        } else {}
        if ((*decl).public and !(AstNode).has_flags(cast(&AstNode) (decl), AstNodeFlags.AllowPubModifier)) {
            (*workspace).error_handler.report_error_at((*(*decl).pattern).location, "Modifier 'pub' is not allowed here", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
        } else {}
        if (cast(^void) ((*decl).type_expr) != null) {
            (*(*decl).type_expr).scope = (*decl).scope
            (*decl).type_expr = ^*self.compile_node(&*(*decl).type_expr, ctx.with_expected(@type_info(type)))
            if ((*(*decl).type_expr).value == Value.Poison) {
                (*decl).var_type = @type_info(void)
                poison(cast(&AstNode) (decl))
                return cast(&AstNode) (decl)
            } else if (cast(^void) ((*(*decl).type_expr).typ) != cast(^void) (@type_info(type))) {
                (*workspace).error_handler.report_error_at((*(*decl).type_expr).location, "Expected type, got {}", cast([]^any) ([cast(^any) ((*(*decl).type_expr).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                (*decl).var_type = @type_info(void)
                poison(cast(&AstNode) (decl))
                return cast(&AstNode) (decl)
            } else {
                @assert(((*(*decl).type_expr).value == Value.Type))
                (*decl).var_type = ((*(*decl).type_expr).value).Type
            }
        } else {}
        if (cast(^void) ((*decl).value_expr) != null) {
            (*(*decl).value_expr).scope = (*decl).scope
            (*decl).value_expr = ^*self.compile_node(&*(*decl).value_expr, ctx.with_expected((*decl).var_type))
            if (cast(^void) ((*(*decl).value_expr).typ) == null) {
                return cast(&AstNode) (decl)
            } else {}
            (*decl).value = (*(*decl).value_expr).value
            if ((*(*decl).value_expr).value == Value.Poison) {
                (*decl).var_type = @type_info(void)
                poison(cast(&AstNode) (decl))
                return cast(&AstNode) (decl)
            } else {}
            if (cast(^void) ((*decl).var_type) == null) {
                (*decl).var_type = (*(*decl).value_expr).typ
            } else {}
            if !(TypeInfo).same((*(*decl).value_expr).typ, (*decl).var_type) {
                (*workspace).error_handler.report_error_at((*(*decl).value_expr).location, "Value type ({}) does not match expected type ({})", cast([]^any) ([cast(^any) ((*(*decl).value_expr).typ), cast(^any) ((*decl).var_type)]), "", cast([](fmt: string, args: []^any)) ([]))
                (*decl).var_type = @type_info(void)
                poison(cast(&AstNode) (decl))
                return cast(&AstNode) (decl)
            } else {}
        } else {}
        if !self.validate_variable_type((*decl).var_type, (*(*decl).pattern).location) {
            return cast(&AstNode) (decl)
        } else {}
        return cast(&AstNode) (decl)
    }
    
    validate_variable_type(self: &CompileNode, typ: ^TypeInfo, location: Location) -> bool {
        @assert((cast(^void) (typ) != null))
        if (cast(^void) (typ) == cast(^void) (@type_info(void))) {
            (*workspace).error_handler.report_error_at(location, "Variable can't have type {}", cast([]^any) ([cast(^any) (typ)]), "", cast([](fmt: string, args: []^any)) ([]))
            return false
        } else {}
        return true
    }
    
    compile_const_decl(self: &CompileNode, decl: &AstConstDecl, ctx: CNContext) -> &AstNode {
        self.debug_log("compile_const_decl", cast([]^any) ([]))
        (*decl).typ = @type_info(void)
        if !(AstNode).has_flags(cast(&AstNode) (decl), AstNodeFlags.IsDefinedInScope) {
            (*(*decl).value_expr).scope = (*decl).scope
            name : string = match @tempvar_374((*decl).pattern) {
                AstIdentifier($id) -> (*id).name
                _ -> {
                    (*workspace).error_handler.report_error_at((*decl).location, "Non-identifier patterns not implemented yet", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                    return cast(&AstNode) (decl)
                }
            }
            match @tempvar_376((*decl).value_expr) {
                AstFunction($func) -> {
                    (*func).name = name
                }
                AstStruct($str) -> {
                    (*str).name = name
                }
                AstEnum($en) -> {
                    (*en).name = name
                }
                AstTrait($tr) -> {
                    (*tr).name = name
                }
                AstPoly($poly) -> {
                    (*poly).name = name
                }
            }
            if strings_not_equal(name, "_") {
                match @tempvar_382(&*(*decl).scope.define_const_decl(name, decl)) {
                    Result[(), ()].Err -> {
                        (*workspace).error_handler.report_error_at((*(*decl).pattern).location, "A symbol with this name already exists in this scope", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                    }
                }
            } else {}
        } else {}
        if ((*decl).public and !(AstNode).has_flags(cast(&AstNode) (decl), AstNodeFlags.AllowPubModifier)) {
            (*workspace).error_handler.report_error_at((*(*decl).pattern).location, "Modifier 'pub' is not allowed here", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
        } else {}
        if (cast(^void) ((*decl).type_expr) != null) {
            (*(*decl).type_expr).scope = (*decl).scope
            (*decl).type_expr = ^*self.compile_node(&*(*decl).type_expr, ctx.with_expected(@type_info(type)))
            if (cast(^void) ((*(*decl).type_expr).typ) != cast(^void) (@type_info(type))) {
                (*workspace).error_handler.report_error_at((*(*decl).type_expr).location, "Expected type, got {}", cast([]^any) ([cast(^any) ((*(*decl).type_expr).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
            } else {
                @assert(((*(*decl).type_expr).value == Value.Type))
                (*decl).var_type = ((*(*decl).type_expr).value).Type
            }
        } else {}
        self.debug_log("compile_const_decl 1", cast([]^any) ([]))
        (*decl).value_expr <- self.evaluate_node((*decl).value_expr, ctx.with_expected((*decl).var_type))
        self.debug_log("compile_const_decl 2", cast([]^any) ([]))
        (*decl).value = (*(*decl).value_expr).value
        if ((*decl).value == Value.Poison) {
            poison(cast(&AstNode) (decl))
            return cast(&AstNode) (decl)
        } else {}
        self.debug_log("compile_const_decl 3", cast([]^any) ([]))
        if ((cast(^void) ((*(*decl).value_expr).typ) != cast(^void) (@type_info(void))) and ((*decl).value == Value.None)) {
            (*workspace).error_handler.report_error_at((*(*decl).value_expr).location, "Value is not constant", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
            poison(cast(&AstNode) (decl))
            return cast(&AstNode) (decl)
        } else {}
        if (cast(^void) ((*decl).var_type) == null) {
            (*decl).var_type = (*(*decl).value_expr).typ
        } else {}
        return cast(&AstNode) (decl)
    }
}

handle_poison :: handle_poison(node: &AstNode, possible_poison: Code) #macro {
    if ((@insert(possible_poison)).value == ().Poison) {
        (node).typ = @type_info(void)
        (node).value = ().Poison
        return node
    }
}

poison :: poison(node: &AstNode) {
    (*node).typ = @type_info(void)
    (*node).value = Value.Poison
}

impl TypeInfo {
    same(a: ^TypeInfo, b: ^TypeInfo) -> bool {
        if (cast(^void) (a) == cast(^void) (b)) {
            return true
        } else {}
        return match @tempvar_383((a, b)) {
            (TypeInfoArray($a), TypeInfoArray($b)) -> (((*a).count == (*b).count) and same((*a).target, (*b).target))
            (TypeInfoPointer($a), TypeInfoPointer($b)) -> same((*a).target, (*b).target)
            (TypeInfoReference($a), TypeInfoReference($b)) -> same((*a).target, (*b).target)
            (TypeInfoPointer($a), TypeInfoReference($b)) -> same((*a).target, (*b).target)
            (TypeInfoReference($a), TypeInfoPointer($b)) -> same((*a).target, (*b).target)
            (TypeInfoFunction($a), TypeInfoFunction($b)) -> {
                if (((*a).param_types).length != ((*b).param_types).length) {
                    return false
                } else {}
                if !same((*a).return_type, (*b).return_type) {
                    return false
                } else {}
                #macro {
                    local r : Range[i64] = new Range[i64] { start = 0, end = ((*a).param_types).length }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_180) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_180))[0]
                        it_index : i64 = @var(@id((it, it_index)_180))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                it : i64 = it
                                it_index : i64 = it_index
                                {
                                    if !same(*get_index((*a).param_types, it), *get_index((*b).param_types, it)) {
                                        #anonymous {
                                            it_index = (it_index + 1)
                                            it = (it + inc)
                                        };
                                        return false
                                    } else {}
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
                return true
            }
            _ -> false
        }
    }
}

#file lexer.che
use import string_database

use import error_handler

use import std.string

use import std.unicode

use import std.printable

use import std.io.fs

use import std.rc

C :  : import std.c

io :  : import std.io

Lexer :: struct { // size: 752, alignment: 8
    text : string
    location : Location
    peek : Option[Token]
    offset : i64
    string_db : &StringDatabase
    KwLambda : string
    KwReturn : string
    Kwfn : string
    KwFn : string
    KwStruct : string
    KwEnum : string
    KwImpl : string
    KwIf : string
    KwElse : string
    KwFor : string
    KwWhile : string
    KwLoop : string
    KwAnd : string
    KwOr : string
    KwTrue : string
    KwFalse : string
    KwNull : string
    KwUse : string
    KwDefer : string
    KwMatch : string
    KwBreak : string
    KwContinue : string
    KwTrait : string
    KwCast : string
    KwConst : string
    KwDefault : string
    KwPub : string
    KwThen : string
    KwDo : string
    KwMut : string
    KwImport : string
    KwIn : string
    KwIs : string
}

impl TextProvider for Lexer {
    get_text(self: &Lexer, filename: string) -> string {
        return text
    }
}

impl Lexer {
    from_string(content: string, string_db: &StringDatabase) -> Rc[Lexer] #nostacktrace {
        return (Rc[Lexer]).new(new Lexer {
            text = content
            location = new Location {
                file = "string"
                byte_index = 0
                byte_length = 1
                line = 1
                column = 1
                end_column = default
                end_line = default
            }
            offset = 0
            peek = Option[Token].None
            string_db = string_db
            KwLambda = string_db.intern("lambda")
            KwReturn = string_db.intern("return")
            Kwfn = string_db.intern("fn")
            KwFn = string_db.intern("fn")
            KwStruct = string_db.intern("struct")
            KwEnum = string_db.intern("enum")
            KwImpl = string_db.intern("impl")
            KwIf = string_db.intern("if")
            KwElse = string_db.intern("else")
            KwFor = string_db.intern("for")
            KwWhile = string_db.intern("while")
            KwLoop = string_db.intern("loop")
            KwAnd = string_db.intern("and")
            KwOr = string_db.intern("or")
            KwTrue = string_db.intern("true")
            KwFalse = string_db.intern("false")
            KwNull = string_db.intern("null")
            KwUse = string_db.intern("use")
            KwDefer = string_db.intern("defer")
            KwMatch = string_db.intern("match")
            KwBreak = string_db.intern("break")
            KwContinue = string_db.intern("continue")
            KwTrait = string_db.intern("trait")
            KwCast = string_db.intern("cast")
            KwConst = string_db.intern("const")
            KwDefault = string_db.intern("default")
            KwPub = string_db.intern("pub")
            KwThen = string_db.intern("then")
            KwDo = string_db.intern("do")
            KwMut = string_db.intern("mut")
            KwImport = string_db.intern("import")
            KwIn = string_db.intern("in")
            KwIs = string_db.intern("is")
        })
    }
    
    from_file(filename: string, string_db: &StringDatabase) -> Result[Rc[Lexer], ()] {
        content : string = {
            content : String = #macro {
                
                
                @tempvar_397(match @tempvar_396(read_file(filename)) {
                    Result[String, FsError].Ok($val) -> val
                    Result[String, FsError].Err($err) -> #link #anonymous {
                        return Result[Rc[Lexer], ()].Err(())
                    }
                })
            }
            string_db.intern(&content.slice())
            @destruct(content)
        }
        l : Rc[Lexer] = (Lexer).from_string(content.slice(0, -1), string_db)
        ((*&l.get()).location).file = filename
        return Result[Rc[Lexer], ()].Ok(l)
    }
    
    current_location(self: &Lexer) -> Location {
        return match @tempvar_398(&peek) {
            Option[Token].Some($tok) -> (*tok).location
            Option[Token].None -> location
        }
    }
    
    expect_token(self: &Lexer, typ: TokenType) -> (bool, Token) {
        token : Token = self.next_token()
        if (cast(i64) ((token).typ) == cast(i64) (typ)) {
            return (true, token)
        } else {
            return (false, token)
        }
    }
    
    peek_token(self: &Lexer) -> &Token {
        return match @tempvar_399(&peek) {
            Option[Token].Some($tok) -> tok
            Option[Token].None -> {
                tok : Token = self.next_token()
                peek = Option[Token].Some(tok)
                &(peek).Some
            }
        }
    }
    
    next_token(self: &Lexer) -> Token {
        match @tempvar_400(peek) {
            Option[Token].Some($t) -> {
                peek = Option[Token].None
                return t
            }
        }
        match @tempvar_401(self.skip_newlines_and_comments()) {
            Option[Location].Some($loc) -> {
                t : Token = new Token { typ = TokenType.NewLine, location = loc, suffix = Option[string].None, data = TokenData.None }
                return t
            }
        }
        t : Token = self.read_token()
        return t
    }
    
    skip_whitespace(self: &Lexer) {
        loop {
            if !true then break else {}
            tok : &Token = self.peek_token()
            match @tempvar_402((*tok).typ) {
                TokenType.NewLine -> {
                    self.next_token()
                }
                $_ -> {
                    break
                }
            }
        }
    }
    
    skip_line(self: &Lexer) {
        loop {
            if !true then break else {}
            tok : Token = self.next_token()
            match @tempvar_403((tok).typ) {
                TokenType.EOF -> {
                    return
                }
                TokenType.NewLine -> {
                    return
                }
            }
        }
    }
    
    read_token(self: &Lexer) -> Token {
        token : Token = new Token { typ = TokenType.EOF, data = TokenData.None, location = location, suffix = Option[string].None }
        ((token).location).byte_length = 0
        if (((location).byte_index - offset) >= ((text).bytes).length) {
            return token
        } else {}
        @id((curr, curr_len)_182) : (char32, i64) = {
            x : (char32, i32) = self.peek_char(0)
            (x[0], cast(i64) (x[1]))
        }
        curr : char32 = @var(@id((curr, curr_len)_182))[0]
        curr_len : i64 = @var(@id((curr, curr_len)_182))[1]
        @id((next, next_len)_183) : (char32, i64) = {
            x : (char32, i32) = self.peek_char(1)
            (x[0], cast(i64) (x[1]))
        }
        next : char32 = @var(@id((next, next_len)_183))[0]
        next_len : i64 = @var(@id((next, next_len)_183))[1]
        @id((next2, next_len2)_184) : (char32, i64) = {
            x : (char32, i32) = self.peek_char(2)
            (x[0], cast(i64) (x[1]))
        }
        next2 : char32 = @var(@id((next2, next_len2)_184))[0]
        next_len2 : i64 = @var(@id((next2, next_len2)_184))[1]
        match @tempvar_404((curr, next)) {
            ('<', '-') -> self.simple_token(&token, TokenType.ReverseArrow, (curr_len + next_len), 2)
            ('-', '>') -> self.simple_token(&token, TokenType.Arrow, (curr_len + next_len), 2)
            ('=', '>') -> self.simple_token(&token, TokenType.DoubleArrow, (curr_len + next_len), 2)
            ('=', '=') -> self.simple_token(&token, TokenType.DoubleEqual, (curr_len + next_len), 2)
            ('!', '=') -> self.simple_token(&token, TokenType.NotEqual, (curr_len + next_len), 2)
            ('<', '=') -> self.simple_token(&token, TokenType.LessEqual, (curr_len + next_len), 2)
            ('<', '<') -> self.simple_token(&token, TokenType.LessLess, (curr_len + next_len), 2)
            ('>', '=') -> self.simple_token(&token, TokenType.GreaterEqual, (curr_len + next_len), 2)
            ('+', '=') -> self.simple_token(&token, TokenType.AddEq, (curr_len + next_len), 2)
            ('-', '=') -> self.simple_token(&token, TokenType.SubEq, (curr_len + next_len), 2)
            ('*', '=') -> self.simple_token(&token, TokenType.MulEq, (curr_len + next_len), 2)
            ('/', '=') -> self.simple_token(&token, TokenType.DivEq, (curr_len + next_len), 2)
            ('%', '=') -> self.simple_token(&token, TokenType.ModEq, (curr_len + next_len), 2)
            ('.', '.') if (next2 == '=') -> self.simple_token(&token, TokenType.PeriodPeriodEq, ((curr_len + next_len) + next_len2), 3)
            ('.', '.') -> self.simple_token(&token, TokenType.PeriodPeriod, (curr_len + next_len), 2)
            (':', _) -> self.simple_token(&token, TokenType.Colon, curr_len, 1)
            (';', _) -> self.simple_token(&token, TokenType.Semicolon, curr_len, 1)
            ('.', _) -> self.simple_token(&token, TokenType.Period, curr_len, 1)
            ('=', _) -> self.simple_token(&token, TokenType.Equal, curr_len, 1)
            ('(', _) -> self.simple_token(&token, TokenType.OpenParen, curr_len, 1)
            (')', _) -> self.simple_token(&token, TokenType.ClosingParen, curr_len, 1)
            ('{', _) -> self.simple_token(&token, TokenType.OpenBrace, curr_len, 1)
            ('}', _) -> self.simple_token(&token, TokenType.ClosingBrace, curr_len, 1)
            ('[', _) -> self.simple_token(&token, TokenType.OpenBracket, curr_len, 1)
            (']', _) -> self.simple_token(&token, TokenType.ClosingBracket, curr_len, 1)
            (',', _) -> self.simple_token(&token, TokenType.Comma, curr_len, 1)
            ('&', _) -> self.simple_token(&token, TokenType.Ampersand, curr_len, 1)
            ('^', _) -> self.simple_token(&token, TokenType.Hat, curr_len, 1)
            ('*', _) -> self.simple_token(&token, TokenType.Asterisk, curr_len, 1)
            ('/', _) -> self.simple_token(&token, TokenType.ForwardSlash, curr_len, 1)
            ('+', _) -> self.simple_token(&token, TokenType.Plus, curr_len, 1)
            ('%', _) -> self.simple_token(&token, TokenType.Percent, curr_len, 1)
            ('-', _) -> self.simple_token(&token, TokenType.Minus, curr_len, 1)
            ('<', _) -> self.simple_token(&token, TokenType.Less, curr_len, 1)
            ('>', _) -> self.simple_token(&token, TokenType.Greater, curr_len, 1)
            ('!', _) -> self.simple_token(&token, TokenType.Bang, curr_len, 1)
            ('|', _) -> self.simple_token(&token, TokenType.Pipe, curr_len, 1)
            ('"', _) -> {
                self.parse_string_literal(&token, TokenType.StringLiteral, '"')
                self.parse_suffix(&token)
            }
            ('`'', _) -> {
                self.parse_string_literal(&token, TokenType.CharLiteral, '`'')
                self.parse_suffix(&token)
            }
            ('$', _) -> {
                (@tempvar_405(location)).byte_index = ((@tempvar_405(location)).byte_index + curr_len)
                (@tempvar_406(location)).column = ((@tempvar_406(location)).column + 1)
                self.parse_identifier(&token, TokenType.DollarIdentifier)
            }
            ('#', _) -> {
                (@tempvar_407(location)).byte_index = ((@tempvar_407(location)).byte_index + curr_len)
                (@tempvar_408(location)).column = ((@tempvar_408(location)).column + 1)
                self.parse_identifier(&token, TokenType.HashIdentifier)
            }
            ('@', _) -> {
                (@tempvar_409(location)).byte_index = ((@tempvar_409(location)).byte_index + curr_len)
                (@tempvar_410(location)).column = ((@tempvar_410(location)).column + 1)
                self.parse_identifier(&token, TokenType.AtSignIdentifier)
            }
            ($x, _) if is_ident_begin(x) -> {
                self.parse_identifier(&token, TokenType.Identifier)
                self.check_keywords(&token)
            }
            ($x, _) if is_digit(x) -> {
                self.parse_number_literal(&token)
                self.parse_suffix(&token)
            }
            (_, _) -> {
                (token).typ = TokenType.Unknown
                (@tempvar_411(location)).byte_index = ((@tempvar_411(location)).byte_index + curr_len)
            }
        }
        ((token).location).byte_length = ((location).byte_index - ((token).location).byte_index)
        ((token).location).end_column = (location).column
        ((token).location).end_line = (location).line
        return token
    }
    
    parse_number_literal(self: &Lexer, token: &Token) {
        (*token).typ = TokenType.NumberLiteral
        base : i64 = 10
        str : String = {
            raw : []u8 = @alloca(u8, 128)
            str : String = (String).from_raw_ptr((raw).data, (raw).length)
            @tempvar_428(str)
            @destruct(str)
        }
        is_float : bool = false
        LexerNumberState :: enum<i64> { // size: 0, alignment: 1
            Error = 0
            Init = 1
            Done = 2
            Z = 3
            X = 4
            B = 5
            DecDigit = 6
            Dec_ = 7
            BinDigit = 8
            Bin_ = 9
            HexDigit = 10
            Hex_ = 11
            FloatPoint = 12
            FloatDigit = 13
            Float_ = 14
        }
        use LexerNumberState
        state : LexerNumberState = LexerNumberState.Init
        loop {
            if !(((location).byte_index - offset) < ((text).bytes).length) then break else {}
            @id((c, c_len)_185) : (char32, i32) = self.peek_char(0)
            c : char32 = @var(@id((c, c_len)_185))[0]
            c_len : i32 = @var(@id((c, c_len)_185))[1]
            @id((next, _)_186) : (char32, i32) = self.peek_char(1)
            next : char32 = @var(@id((next, _)_186))[0]
            _ : i32 = @var(@id((next, _)_186))[1]
            match @tempvar_412(state) {
                LexerNumberState.Error -> break
                LexerNumberState.Done -> break
                LexerNumberState.Init -> {
                    if (c == '0') {
                        append_char(&str, c)
                        state = LexerNumberState.Z
                    } else if is_digit(c) {
                        append_char(&str, c)
                        state = LexerNumberState.DecDigit
                    } else {}
                }
                LexerNumberState.Z -> match @tempvar_413(c) {
                    'x' -> {
                        base = 16
                        &str.resize(0)
                        state = LexerNumberState.X
                    }
                    'b' -> {
                        base = 2
                        &str.resize(0)
                        state = LexerNumberState.B
                    }
                    '.' if (next != '.') -> {
                        append_char(&str, c)
                        state = LexerNumberState.FloatPoint
                    }
                    $x if is_digit(x) -> {
                        append_char(&str, x)
                        state = LexerNumberState.DecDigit
                    }
                    '_' -> {
                        state = LexerNumberState.Dec_
                    }
                    _ -> {
                        state = LexerNumberState.Done
                    }
                }
                LexerNumberState.DecDigit -> match @tempvar_414(c) {
                    '.' if (next != '.') -> {
                        append_char(&str, c)
                        state = LexerNumberState.FloatPoint
                    }
                    '_' -> {
                        state = LexerNumberState.Dec_
                    }
                    $x if is_digit(x) -> {
                        append_char(&str, c)
                    }
                    _ -> {
                        state = LexerNumberState.Done
                    }
                }
                LexerNumberState.Dec_ -> match @tempvar_415(c) {
                    $x if is_digit(x) -> {
                        append_char(&str, c)
                        state = LexerNumberState.DecDigit
                    }
                    _ -> {
                        state = LexerNumberState.Error
                    }
                }
                LexerNumberState.FloatPoint -> {
                    is_float = true
                    if is_digit(c) {
                        append_char(&str, c)
                        state = LexerNumberState.FloatDigit
                    } else {
                        state = LexerNumberState.Error
                    }
                }
                LexerNumberState.FloatDigit -> match @tempvar_416(c) {
                    $c if is_digit(c) -> {
                        append_char(&str, c)
                    }
                    '_' -> {
                        state = LexerNumberState.Float_
                    }
                    $_ -> {
                        state = LexerNumberState.Done
                    }
                }
                LexerNumberState.Float_ -> match @tempvar_417(c) {
                    $x if is_digit(x) -> {
                        append_char(&str, c)
                        state = LexerNumberState.FloatDigit
                    }
                    _ -> {
                        state = LexerNumberState.Error
                    }
                }
                LexerNumberState.X -> match @tempvar_418(c) {
                    $c if is_hex_digit(c) -> {
                        append_char(&str, c)
                        state = LexerNumberState.HexDigit
                    }
                    $_ -> {
                        state = LexerNumberState.Error
                    }
                }
                LexerNumberState.HexDigit -> match @tempvar_419(c) {
                    $c if is_hex_digit(c) -> {
                        append_char(&str, c)
                    }
                    '_' -> {
                        state = LexerNumberState.Hex_
                    }
                    $_ -> {
                        state = LexerNumberState.Done
                    }
                }
                LexerNumberState.Hex_ -> match @tempvar_420(c) {
                    $x if is_hex_digit(x) -> {
                        append_char(&str, c)
                        state = LexerNumberState.HexDigit
                    }
                    _ -> {
                        state = LexerNumberState.Error
                    }
                }
                LexerNumberState.B -> match @tempvar_421(c) {
                    $c if is_binary_digit(c) -> {
                        append_char(&str, c)
                        state = LexerNumberState.BinDigit
                    }
                    $_ -> {
                        state = LexerNumberState.Error
                    }
                }
                LexerNumberState.BinDigit -> match @tempvar_422(c) {
                    $c if is_binary_digit(c) -> {
                        append_char(&str, c)
                    }
                    '_' -> {
                        state = LexerNumberState.Bin_
                    }
                    $_ -> {
                        state = LexerNumberState.Done
                    }
                }
                LexerNumberState.Bin_ -> match @tempvar_423(c) {
                    $x if is_binary_digit(x) -> {
                        append_char(&str, c)
                        state = LexerNumberState.BinDigit
                    }
                    _ -> {
                        state = LexerNumberState.Error
                    }
                }
            }
            match @tempvar_424(state) {
                LexerNumberState.Done -> break
                LexerNumberState.Error -> break
                $_ -> {
                    (@tempvar_425(location)).byte_index = ((@tempvar_425(location)).byte_index + cast(i64) (c_len))
                    (@tempvar_426(location)).column = ((@tempvar_426(location)).column + 1)
                }
            }
        }
        match @tempvar_427(state) {
            LexerNumberState.Error -> {
                (*token).typ = TokenType.Error
                (*token).data = TokenData.String("Invalid number literal")
                @destruct(str);
                return
            }
        }
        append_char(&str, '`0')
        if is_float {
            d : f64 = (C).strtod(cast (&str.get_raw()), null)
            (*token).data = TokenData.Double(d)
        } else {
            i : i64 = (C).strtol(cast (&str.get_raw()), null, cast (base))
            (*token).data = TokenData.Integer(i)
        }
        @destruct(str)
    }
    
    parse_suffix(self: &Lexer, token: &Token) {
        if is_ident_begin(self.peek_char(0)[0]) {
            start : i64 = ((location).byte_index - offset)
            loop {
                if !(((location).byte_index - offset) < ((text).bytes).length) then break else {}
                @id((c, c_len)_187) : (char32, i32) = self.peek_char(0)
                c : char32 = @var(@id((c, c_len)_187))[0]
                c_len : i32 = @var(@id((c, c_len)_187))[1]
                if !is_ident_char(c) then break else {}
                (@tempvar_429(location)).byte_index = ((@tempvar_429(location)).byte_index + cast(i64) (c_len))
                (@tempvar_430(location)).column = ((@tempvar_430(location)).column + 1)
            }
            (*token).suffix = Option[string].Some(get_range(text, new Range[i64] { start = start, end = ((location).byte_index - offset) }))
        } else {}
    }
    
    simple_token(self: &Lexer, token: &Token, typ: TokenType, len: i64, chars: i64) {
        (*token).typ = typ
        (@tempvar_431(location)).byte_index = ((@tempvar_431(location)).byte_index + len)
        (@tempvar_432(location)).column = ((@tempvar_432(location)).column + chars)
    }
    
    parse_identifier(self: &Lexer, token: &Token, typ: TokenType) {
        (*token).typ = typ
        start : i64 = ((location).byte_index - offset)
        loop {
            if !(((location).byte_index - offset) < ((text).bytes).length) then break else {}
            @id((c, c_len)_188) : (char32, i32) = self.peek_char(0)
            c : char32 = @var(@id((c, c_len)_188))[0]
            c_len : i32 = @var(@id((c, c_len)_188))[1]
            if !is_ident_char(c) then break else {}
            (@tempvar_433(location)).byte_index = ((@tempvar_433(location)).byte_index + cast(i64) (c_len))
            (@tempvar_434(location)).column = ((@tempvar_434(location)).column + 1)
        }
        str : string = get_range(text, new Range[i64] { start = start, end = ((location).byte_index - offset) })
        (*token).data = TokenData.String(string_db.intern(str))
    }
    
    parse_string_literal(self: &Lexer, token: &Token, typ: TokenType, end: char32) {
        (*token).typ = typ
        (@tempvar_435(location)).byte_index = ((@tempvar_435(location)).byte_index + 1)
        (@tempvar_436(location)).column = ((@tempvar_436(location)).column + 1)
        start : i64 = ((location).byte_index - offset)
        foundEnd : bool = false
        loop {
            if !(((location).byte_index - offset) < ((text).bytes).length) then break else {}
            @id((c, c_len)_189) : (char32, i32) = self.peek_char(0)
            c : char32 = @var(@id((c, c_len)_189))[0]
            c_len : i32 = @var(@id((c, c_len)_189))[1]
            (@tempvar_437(location)).byte_index = ((@tempvar_437(location)).byte_index + cast(i64) (c_len))
            (@tempvar_438(location)).column = ((@tempvar_438(location)).column + 1)
            if (c == end) {
                foundEnd = true
                break
            } else if (c == '``') {
                if (((location).byte_index - offset) >= ((text).bytes).length) {
                    break
                } else {}
                (@tempvar_439(location)).byte_index = ((@tempvar_439(location)).byte_index + cast(i64) (c_len))
                (@tempvar_440(location)).column = ((@tempvar_440(location)).column + 1)
            } else {}
            if (c == '`n') {
                (location).column = 1
                (@tempvar_441(location)).line = ((@tempvar_441(location)).line + 1)
            } else {}
        }
        if !foundEnd {} else {}
        str : string = get_range(text, new Range[i64] { start = start, end = (((location).byte_index - offset) - 1) })
        (*token).data = TokenData.String(string_db.intern(str))
    }
    
    skip_newlines_and_comments(self: &Lexer) -> loc: Option[Location] {
        loc = Option[Location].None
        loop {
            if !(((location).byte_index - offset) < ((text).bytes).length) then break else {}
            @id((curr, curr_len)_190) : (char32, i32) = self.peek_char(0)
            curr : char32 = @var(@id((curr, curr_len)_190))[0]
            curr_len : i32 = @var(@id((curr, curr_len)_190))[1]
            @id((next, next_len)_191) : (char32, i32) = self.peek_char(1)
            next : char32 = @var(@id((next, next_len)_191))[0]
            next_len : i32 = @var(@id((next, next_len)_191))[1]
            if ((curr == '/') and (next == '*')) {
                self.parse_multi_line_comment()
            } else if ((curr == '/') and (next == '/')) {
                self.parse_single_line_comment()
            } else if ((curr == ' ') or (curr == '`t')) {
                (@tempvar_442(location)).byte_index = ((@tempvar_442(location)).byte_index + cast(i64) (curr_len))
                (@tempvar_443(location)).column = ((@tempvar_443(location)).column + 1)
            } else if (curr == '`r') {
                (@tempvar_444(location)).byte_index = ((@tempvar_444(location)).byte_index + cast(i64) (curr_len))
                (@tempvar_445(location)).column = ((@tempvar_445(location)).column + 1)
            } else if (curr == '`n') {
                match @tempvar_446(loc) {
                    Option[Location].None -> {
                        loc = Option[Location].Some(location)
                    }
                }
                (@tempvar_447(location)).line = ((@tempvar_447(location)).line + 1)
                (@tempvar_448(location)).byte_index = ((@tempvar_448(location)).byte_index + cast(i64) (curr_len))
                (location).column = 1
            } else {
                break
            }
        }
        return
    }
    
    peek_char(self: &Lexer, offset: i64) -> (char32, i32) {
        index : i64 = ((location).byte_index - (*self).offset)
        loop {
            if !(offset > 0) then break else {}
            defer offset = (offset - 1)
            @id((_, len)_193) : (char32, i32) = (Utf8).decode(get_range((text.slice(0, -1)).bytes, new Range[i64] { start = index, end = ((text).bytes).length }))
            _ : char32 = @var(@id((_, len)_193))[0]
            len : i32 = @var(@id((_, len)_193))[1]
            index = (index + cast(i64) (len))
            offset = (offset - 1)
        }
        if (index >= ((text).bytes).length) {
            return (cast(char32) (0), 0)
        } else {}
        return (Utf8).decode(get_range((text).bytes, new Range[i64] { start = index, end = ((text).bytes).length }))
    }
    
    parse_multi_line_comment(self: &Lexer) {
        level : i64 = 0
        loop {
            if !(((location).byte_index - offset) < ((text).bytes).length) then break else {}
            @id((curr, curr_len)_194) : (char32, i32) = self.peek_char(0)
            curr : char32 = @var(@id((curr, curr_len)_194))[0]
            curr_len : i32 = @var(@id((curr, curr_len)_194))[1]
            @id((next, next_len)_195) : (char32, i32) = self.peek_char(1)
            next : char32 = @var(@id((next, next_len)_195))[0]
            next_len : i32 = @var(@id((next, next_len)_195))[1]
            if ((curr == '/') and (next == '*')) {
                (@tempvar_449(location)).byte_index = ((@tempvar_449(location)).byte_index + cast(i64) (next_len))
                (@tempvar_450(location)).column = ((@tempvar_450(location)).column + 1)
                level = (level + 1)
            } else if ((curr == '*') and (next == '/')) {
                (@tempvar_451(location)).byte_index = ((@tempvar_451(location)).byte_index + cast(i64) (next_len))
                (@tempvar_452(location)).column = ((@tempvar_452(location)).column + 1)
                level = (level - 1)
                if (level == 0) {
                    break
                } else {}
            } else if (curr == '\') {
                (@tempvar_453(location)).line = ((@tempvar_453(location)).line + 1)
                (location).column = 1
            } else {}
            (@tempvar_454(location)).byte_index = ((@tempvar_454(location)).byte_index + cast(i64) (curr_len))
            (@tempvar_455(location)).column = ((@tempvar_455(location)).column + 1)
        }
    }
    
    parse_single_line_comment(self: &Lexer) {
        loop {
            if !(((location).byte_index - offset) < ((text).bytes).length) then break else {}
            @id((next, len)_196) : (char32, i32) = self.peek_char(0)
            next : char32 = @var(@id((next, len)_196))[0]
            len : i32 = @var(@id((next, len)_196))[1]
            if (next == '`n') {
                break
            } else {}
            (@tempvar_456(location)).byte_index = ((@tempvar_456(location)).byte_index + cast(i64) (len))
            (@tempvar_457(location)).column = ((@tempvar_457(location)).column + 1)
        }
    }
    
    check_keywords(self: &Lexer, token: &Token) {
        match @tempvar_458((*token).data) {
            TokenData.String($str) -> {
                (*token).typ = if (string).same(str, KwLambda) then TokenType.KwLambda else if (string).same(str, KwReturn) then TokenType.KwReturn else if (string).same(str, Kwfn) then TokenType.Kwfn else if (string).same(str, KwFn) then TokenType.KwFn else if (string).same(str, KwStruct) then TokenType.KwStruct else if (string).same(str, KwEnum) then TokenType.KwEnum else if (string).same(str, KwImpl) then TokenType.KwImpl else if (string).same(str, KwIf) then TokenType.KwIf else if (string).same(str, KwElse) then TokenType.KwElse else if (string).same(str, KwFor) then TokenType.KwFor else if (string).same(str, KwWhile) then TokenType.KwWhile else if (string).same(str, KwLoop) then TokenType.KwLoop else if (string).same(str, KwAnd) then TokenType.KwAnd else if (string).same(str, KwOr) then TokenType.KwOr else if (string).same(str, KwTrue) then TokenType.KwTrue else if (string).same(str, KwFalse) then TokenType.KwFalse else if (string).same(str, KwNull) then TokenType.KwNull else if (string).same(str, KwUse) then TokenType.KwUse else if (string).same(str, KwDefer) then TokenType.KwDefer else if (string).same(str, KwMatch) then TokenType.KwMatch else if (string).same(str, KwBreak) then TokenType.KwBreak else if (string).same(str, KwContinue) then TokenType.KwContinue else if (string).same(str, KwTrait) then TokenType.KwTrait else if (string).same(str, KwCast) then TokenType.KwCast else if (string).same(str, KwConst) then TokenType.KwConst else if (string).same(str, KwDefault) then TokenType.KwDefault else if (string).same(str, KwPub) then TokenType.KwPub else if (string).same(str, KwThen) then TokenType.KwThen else if (string).same(str, KwDo) then TokenType.KwDo else if (string).same(str, KwMut) then TokenType.KwMut else if (string).same(str, KwImport) then TokenType.KwImport else if (string).same(str, KwIn) then TokenType.KwIn else if (string).same(str, KwIs) then TokenType.KwIs else (*token).typ
            }
        }
    }
}

Location :: struct { // size: 64, alignment: 8
    file : string = default
    byte_index : i64 = default
    byte_length : i64 = default
    line : i64 = default
    column : i64 = default
    end_column : i64 = default
    end_line : i64 = default
}

impl Location {
    to(self: Location, end: Location) -> Location {
        return new Location {
            file = file
            byte_index = byte_index
            byte_length = (((end).byte_index + (end).byte_length) - byte_index)
            line = line
            column = column
            end_column = (end).end_column
            end_line = (end).end_line
        }
    }
    
    end(self: Location) -> Location {
        return new Location {
            file = file
            byte_index = (byte_index + byte_length)
            byte_length = 0
            line = end_line
            column = end_column
            end_column = end_column
            end_line = end_line
        }
    }
}

Token :: struct { // size: 120, alignment: 8
    typ : TokenType
    location : Location
    suffix : Option[string]
    data : TokenData
}

TokenData :: enum<i64> { // size: 0, alignment: 1
    None = 0
    String : string = 1
    Integer : i64 = 2
    Double : f64 = 3
}

impl Printable for Location {
    print(self: &Location, str: &String, format: string) {
        str.appendf("{}:{}:{}", (file, line, column, end_line))
    }
}

impl Printable for Token {
    print(self: &Token, str: &String, format: string) {
        str.appendf("{} ({})", (typ, location))
        match @tempvar_459(data) {
            TokenData.String($s) -> str.appendf(" String({})", s)
            TokenData.Integer($s) -> str.appendf(" Int({})", s)
            TokenData.Double($s) -> str.appendf(" Double({})", s)
        }
        match @tempvar_460(suffix) {
            Option[string].Some($s) -> str.appendf(" Suffix(`"{}`")", s)
        }
    }
}

impl Printable for TokenType {
    print(self: &TokenType, str: &String, format: string) {
        use TokenType
        append_string(str, match @tempvar_461(self) {
            TokenType.Error -> "Error"
            TokenType.Unknown -> "Unknown"
            TokenType.NewLine -> "NewLine"
            TokenType.EOF -> "EOF"
            TokenType.StringLiteral -> "StringLiteral"
            TokenType.CharLiteral -> "CharLiteral"
            TokenType.NumberLiteral -> "NumberLiteral"
            TokenType.Identifier -> "Identifier"
            TokenType.DollarIdentifier -> "DollarIdentifier"
            TokenType.HashIdentifier -> "HashIdentifier"
            TokenType.AtSignIdentifier -> "AtSignIdentifier"
            TokenType.ReplaceIdentifier -> "ReplaceIdentifier"
            TokenType.Semicolon -> "Semicolon"
            TokenType.Colon -> "Colon"
            TokenType.Comma -> "Comma"
            TokenType.Period -> "Period"
            TokenType.PeriodPeriod -> "PeriodPeriod"
            TokenType.PeriodPeriodEq -> "PeriodPeriodEq"
            TokenType.Equal -> "Equal"
            TokenType.Ampersand -> "Ampersand"
            TokenType.Hat -> "Hat"
            TokenType.Bang -> "Bang"
            TokenType.Plus -> "Plus"
            TokenType.Minus -> "Minus"
            TokenType.Asterisk -> "Asterisk"
            TokenType.ForwardSlash -> "ForwardSlash"
            TokenType.Percent -> "Percent"
            TokenType.AddEq -> "AddEq"
            TokenType.SubEq -> "SubEq"
            TokenType.MulEq -> "MulEq"
            TokenType.DivEq -> "DivEq"
            TokenType.ModEq -> "ModEq"
            TokenType.Less -> "Less"
            TokenType.LessEqual -> "LessEqual"
            TokenType.Greater -> "Greater"
            TokenType.GreaterEqual -> "GreaterEqual"
            TokenType.DoubleEqual -> "DoubleEqual"
            TokenType.NotEqual -> "NotEqual"
            TokenType.ReverseArrow -> "ReverseArrow"
            TokenType.Arrow -> "Arrow"
            TokenType.DoubleArrow -> "DoubleArrow"
            TokenType.LessLess -> "LessLess"
            TokenType.OpenParen -> "OpenParen"
            TokenType.ClosingParen -> "ClosingParen"
            TokenType.OpenBrace -> "OpenBrace"
            TokenType.ClosingBrace -> "ClosingBrace"
            TokenType.OpenBracket -> "OpenBracket"
            TokenType.ClosingBracket -> "ClosingBracket"
            TokenType.Pipe -> "Pipe"
            TokenType.KwLambda -> "KwLambda"
            TokenType.KwReturn -> "KwReturn"
            TokenType.Kwfn -> "Kwfn"
            TokenType.KwFn -> "KwFn"
            TokenType.KwStruct -> "KwStruct"
            TokenType.KwEnum -> "KwEnum"
            TokenType.KwImpl -> "KwImpl"
            TokenType.KwIf -> "KwIf"
            TokenType.KwElse -> "KwElse"
            TokenType.KwFor -> "KwFor"
            TokenType.KwWhile -> "KwWhile"
            TokenType.KwLoop -> "KwLoop"
            TokenType.KwAnd -> "KwAnd"
            TokenType.KwOr -> "KwOr"
            TokenType.KwTrue -> "KwTrue"
            TokenType.KwFalse -> "KwFalse"
            TokenType.KwNull -> "KwNull"
            TokenType.KwUse -> "KwUse"
            TokenType.KwDefer -> "KwDefer"
            TokenType.KwMatch -> "KwMatch"
            TokenType.KwBreak -> "KwBreak"
            TokenType.KwContinue -> "KwContinue"
            TokenType.KwTrait -> "KwTrait"
            TokenType.KwCast -> "KwCast"
            TokenType.KwConst -> "KwConst"
            TokenType.KwDefault -> "KwDefault"
            TokenType.KwPub -> "KwPub"
            TokenType.KwThen -> "KwThen"
            TokenType.KwDo -> "KwDo"
            TokenType.KwMut -> "KwMut"
            TokenType.KwImport -> "KwImport"
            TokenType.KwIn -> "KwIn"
            TokenType.KwIs -> "KwIs"
        })
    }
}

TokenType :: enum<i64> { // size: 0, alignment: 1
    Error = 0
    Unknown = 1
    NewLine = 2
    EOF = 3
    StringLiteral = 4
    CharLiteral = 5
    NumberLiteral = 6
    Identifier = 7
    DollarIdentifier = 8
    HashIdentifier = 9
    AtSignIdentifier = 10
    ReplaceIdentifier = 11
    Semicolon = 12
    Colon = 13
    Comma = 14
    Period = 15
    PeriodPeriod = 16
    PeriodPeriodEq = 17
    Equal = 18
    Ampersand = 19
    Hat = 20
    Bang = 21
    Plus = 22
    Minus = 23
    Asterisk = 24
    ForwardSlash = 25
    Percent = 26
    AddEq = 27
    SubEq = 28
    MulEq = 29
    DivEq = 30
    ModEq = 31
    Less = 32
    LessEqual = 33
    Greater = 34
    GreaterEqual = 35
    DoubleEqual = 36
    NotEqual = 37
    ReverseArrow = 38
    Arrow = 39
    DoubleArrow = 40
    LessLess = 41
    OpenParen = 42
    ClosingParen = 43
    OpenBrace = 44
    ClosingBrace = 45
    OpenBracket = 46
    ClosingBracket = 47
    Pipe = 48
    KwLambda = 49
    KwReturn = 50
    Kwfn = 51
    KwFn = 52
    KwStruct = 53
    KwEnum = 54
    KwImpl = 55
    KwIf = 56
    KwElse = 57
    KwFor = 58
    KwWhile = 59
    KwLoop = 60
    KwAnd = 61
    KwOr = 62
    KwTrue = 63
    KwFalse = 64
    KwNull = 65
    KwUse = 66
    KwDefer = 67
    KwMatch = 68
    KwBreak = 69
    KwContinue = 70
    KwTrait = 71
    KwCast = 72
    KwConst = 73
    KwDefault = 74
    KwPub = 75
    KwThen = 76
    KwDo = 77
    KwMut = 78
    KwImport = 79
    KwIn = 80
    KwIs = 81
}

is_ident_begin :: is_ident_begin(c: char32) -> bool {
    return (((((c >= 'a') and (c <= 'z')) or ((c >= 'A') and (c <= 'Z'))) or (c == '_')) or (cast(u32) (c) > 127))
}

is_ident_char :: is_ident_char(c: char32) -> bool {
    return (is_ident_begin(c) or ((c >= '0') and (c <= '9')))
}

is_digit :: is_digit(c: char32) -> bool {
    return ((c >= '0') and (c <= '9'))
}

is_hex_digit :: is_hex_digit(c: char32) -> bool {
    return ((((c >= '0') and (c <= '9')) or ((c >= 'a') and (c <= 'f'))) or ((c >= 'A') and (c <= 'F')))
}

is_binary_digit :: is_binary_digit(c: char32) -> bool {
    return ((c >= '0') and (c <= '1'))
}

#file parser.che
use import std.array

use import std.fiber

mem :  : import std.mem.allocator

io :  : import std.io

fmt :  : import std.fmt

use import logging.logger

use import ast

use import compiler

use import config

use import error_handler

use import lexer

use import value

Parser :: struct { // size: 48, alignment: 8
    lexer : &Lexer
    error_handler : ^ErrorHandler
    allocator : ^Allocator
    _next_id : i64 = 1
}

impl Parser {
    debug_log(self: &Parser, msg: string, args: []^any = cast([]^any) ([])) {
        #anonymous {
            if DEBUG_PARSER {
                str : String = (fmt).format(msg, args)
                location : Location = lexer.current_location()
                g_logger.log("[{}] [Parser] {}:{}:{}: {}", cast([]^any) ([cast(^any) ((*(Fiber).user_data()).thread), cast(^any) ((location).file), cast(^any) ((location).line), cast(^any) ((location).column), cast(^any) (str)]), "")
                @destruct(str)
            } else {}
        }
    }
    
    new(lexer: &Lexer, error_handler: ^ErrorHandler, allocator: ^Allocator, first_id: i64) -> Parser {
        return new Parser { lexer = lexer, error_handler = error_handler, allocator = allocator, _next_id = first_id }
    }
    
    next_id(self: &Parser) -> i64 {
        return _next_id <- (_next_id + 1)
    }
    
    allocate(&Parser, value: $T) -> ^T {
        result :  = (mem).alloc(T, allocator)
        *result = value
        return result
    }
    // Polymorphic instances for allocate(&Parser, value: $T) -> ^T
        /* T = (type, AstAssignment) */
        /*  */
        allocate(self: &Parser, value: AstAssignment) -> ^AstAssignment {
            result : ^AstAssignment = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstConstDecl) */
        /*  */
        allocate(self: &Parser, value: AstConstDecl) -> ^AstConstDecl {
            result : ^AstConstDecl = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstDecl) */
        /*  */
        allocate(self: &Parser, value: AstDecl) -> ^AstDecl {
            result : ^AstDecl = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstTuple) */
        /*  */
        allocate(self: &Parser, value: AstTuple) -> ^AstTuple {
            result : ^AstTuple = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstBinary) */
        /*  */
        allocate(self: &Parser, value: AstBinary) -> ^AstBinary {
            result : ^AstBinary = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstUnary) */
        /*  */
        allocate(self: &Parser, value: AstUnary) -> ^AstUnary {
            result : ^AstUnary = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstCall) */
        /*  */
        allocate(self: &Parser, value: AstCall) -> ^AstCall {
            result : ^AstCall = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstIndex) */
        /*  */
        allocate(self: &Parser, value: AstIndex) -> ^AstIndex {
            result : ^AstIndex = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstDot) */
        /*  */
        allocate(self: &Parser, value: AstDot) -> ^AstDot {
            result : ^AstDot = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstArrayType) */
        /*  */
        allocate(self: &Parser, value: AstArrayType) -> ^AstArrayType {
            result : ^AstArrayType = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstArray) */
        /*  */
        allocate(self: &Parser, value: AstArray) -> ^AstArray {
            result : ^AstArray = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstBlock) */
        /*  */
        allocate(self: &Parser, value: AstBlock) -> ^AstBlock {
            result : ^AstBlock = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstMatchCase) */
        /*  */
        allocate(self: &Parser, value: AstMatchCase) -> ^AstMatchCase {
            result : ^AstMatchCase = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstMatch) */
        /*  */
        allocate(self: &Parser, value: AstMatch) -> ^AstMatch {
            result : ^AstMatch = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstIf) */
        /*  */
        allocate(self: &Parser, value: AstIf) -> ^AstIf {
            result : ^AstIf = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstLoop) */
        /*  */
        allocate(self: &Parser, value: AstLoop) -> ^AstLoop {
            result : ^AstLoop = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstFor) */
        /*  */
        allocate(self: &Parser, value: AstFor) -> ^AstFor {
            result : ^AstFor = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstBreak) */
        /*  */
        allocate(self: &Parser, value: AstBreak) -> ^AstBreak {
            result : ^AstBreak = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstContinue) */
        /*  */
        allocate(self: &Parser, value: AstContinue) -> ^AstContinue {
            result : ^AstContinue = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstDefer) */
        /*  */
        allocate(self: &Parser, value: AstDefer) -> ^AstDefer {
            result : ^AstDefer = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstReturn) */
        /*  */
        allocate(self: &Parser, value: AstReturn) -> ^AstReturn {
            result : ^AstReturn = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstPoly) */
        /*  */
        allocate(self: &Parser, value: AstPoly) -> ^AstPoly {
            result : ^AstPoly = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstFunction) */
        /*  */
        allocate(self: &Parser, value: AstFunction) -> ^AstFunction {
            result : ^AstFunction = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstStruct) */
        /*  */
        allocate(self: &Parser, value: AstStruct) -> ^AstStruct {
            result : ^AstStruct = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstEnum) */
        /*  */
        allocate(self: &Parser, value: AstEnum) -> ^AstEnum {
            result : ^AstEnum = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstTrait) */
        /*  */
        allocate(self: &Parser, value: AstTrait) -> ^AstTrait {
            result : ^AstTrait = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstImpl) */
        /*  */
        allocate(self: &Parser, value: AstImpl) -> ^AstImpl {
            result : ^AstImpl = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstUse) */
        /*  */
        allocate(self: &Parser, value: AstUse) -> ^AstUse {
            result : ^AstUse = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstImport) */
        /*  */
        allocate(self: &Parser, value: AstImport) -> ^AstImport {
            result : ^AstImport = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstString) */
        /*  */
        allocate(self: &Parser, value: AstString) -> ^AstString {
            result : ^AstString = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstBool) */
        /*  */
        allocate(self: &Parser, value: AstBool) -> ^AstBool {
            result : ^AstBool = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstIdentifier) */
        /*  */
        allocate(self: &Parser, value: AstIdentifier) -> ^AstIdentifier {
            result : ^AstIdentifier = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstNumberLiteral) */
        /*  */
        allocate(self: &Parser, value: AstNumberLiteral) -> ^AstNumberLiteral {
            result : ^AstNumberLiteral = (mem).alloc(allocator)
            *result = value
            return result
        }
        /* T = (type, AstArgument) */
        /*  */
        allocate(self: &Parser, value: AstArgument) -> ^AstArgument {
            result : ^AstArgument = (mem).alloc(allocator)
            *result = value
            return result
        }
    
    
    try(code: Code) #macro {
        value :  = @insert(code)
        if (value == null) {
            return null
        }
        value
    }
    
    parse_node(self: &Parser) -> ^AstNode {
        lexer.skip_whitespace()
        if self.check_token(TokenType.EOF) {
            return null
        } else {}
        expr : ^AstNode = self.parse_expression(true, true)
        self.consume(TokenType.NewLine)
        return expr
    }
    
    parse_expression(self: &Parser, allow_comma: bool, allow_function: bool) -> ^AstNode {
        if self.check_token(TokenType.KwPub) {
            lexer.next_token()
            mutable : bool = if self.check_token(TokenType.KwMut) {
                lexer.next_token()
                true
            } else false
            return self.parse_declaration(public = true, mutable = mutable, allow_comma = allow_comma, allow_function = allow_function)
        } else if self.check_token(TokenType.KwMut) {
            lexer.next_token()
            return self.parse_declaration(public = false, mutable = true, allow_comma = allow_comma, allow_function = allow_function)
        } else {}
        expr : ^AstNode = self.parse_comma_expression(allow_comma, allow_function)
        if self.check_token(TokenType.Equal) {
            lexer.next_token()
            lexer.skip_whitespace()
            value_expr : ^AstNode = self.parse_comma_expression(allow_comma, allow_function)
            return cast(^AstNode) (self.allocate(new AstAssignment {
                id = self.next_id()
                location = (*expr).location.to((*value_expr).location)
                pattern = &*expr
                value_expr = &*value_expr
                scope = null
                typ = null
                value = Value.None
                flags = 0
            }))
        } else if self.check_token(TokenType.Colon) {
            lexer.next_token()
            lexer.skip_whitespace()
            type_expr : ^AstNode = if (self.check_token(TokenType.Equal) or self.check_token(TokenType.Colon)) {
                null
            } else {
                self.parse_comma_expression(allow_comma, allow_function)
            }
            if self.check_token(TokenType.Colon) {
                lexer.next_token()
                lexer.skip_whitespace()
                value_expr : ^AstNode = self.parse_comma_expression(allow_comma, allow_function)
                return cast(^AstNode) (self.allocate(new AstConstDecl {
                    id = self.next_id()
                    location = (*expr).location.to((*value_expr).location)
                    pattern = &*expr
                    type_expr = type_expr
                    value_expr = &*value_expr
                    scope = null
                    typ = null
                    value = Value.None
                    flags = 0
                    public = false
                    var_type = null
                }))
            } else if self.check_token(TokenType.Equal) {
                lexer.next_token()
                lexer.skip_whitespace()
                value_expr : ^AstNode = self.parse_comma_expression(allow_comma, allow_function)
                return cast(^AstNode) (self.allocate(new AstDecl {
                    id = self.next_id()
                    location = (*expr).location.to((*value_expr).location)
                    pattern = expr
                    type_expr = type_expr
                    value_expr = value_expr
                    mutable = false
                    scope = null
                    typ = null
                    value = Value.None
                    flags = 0
                    public = false
                    name = "_"
                    var_type = null
                }))
            } else {
                return cast(^AstNode) (self.allocate(new AstDecl {
                    id = self.next_id()
                    location = (*expr).location.to((*type_expr).location)
                    pattern = expr
                    type_expr = type_expr
                    value_expr = null
                    mutable = false
                    scope = null
                    typ = null
                    value = Value.None
                    flags = 0
                    public = false
                    name = "_"
                    var_type = null
                }))
            }
        } else {}
        return expr
    }
    
    parse_declaration(self: &Parser, public: bool, mutable: bool, allow_comma: bool, allow_function: bool) -> ^AstNode {
        pattern : ^AstNode = #macro {
            
            value : ^AstNode = self.parse_comma_expression(allow_comma, allow_function)
            if (cast(^void) (value) == null) {
                return null
            } else {}
            value
        }
        self.consume(TokenType.Colon)
        lexer.skip_whitespace()
        type_expr : ^AstNode = if (self.check_token(TokenType.Equal) or self.check_token(TokenType.Colon)) {
            null
        } else {
            #macro {
                
                value : ^AstNode = self.parse_comma_expression(allow_comma, allow_function)
                if (cast(^void) (value) == null) {
                    return null
                } else {}
                value
            }
        }
        if self.check_token(TokenType.Equal) {
            lexer.next_token()
            lexer.skip_whitespace()
            value_expr : ^AstNode = #macro {
                
                value : ^AstNode = self.parse_comma_expression(allow_comma, allow_function)
                if (cast(^void) (value) == null) {
                    return null
                } else {}
                value
            }
            return cast(^AstNode) (self.allocate(new AstDecl {
                id = self.next_id()
                location = (*pattern).location.to((*value_expr).location)
                pattern = pattern
                type_expr = type_expr
                value_expr = value_expr
                public = public
                mutable = mutable
                scope = null
                typ = null
                value = Value.None
                flags = 0
                name = "_"
                var_type = null
            }))
        } else if self.check_token(TokenType.Colon) {
            lexer.next_token()
            lexer.skip_whitespace()
            value_expr : ^AstNode = #macro {
                
                value : ^AstNode = self.parse_comma_expression(allow_comma, allow_function)
                if (cast(^void) (value) == null) {
                    return null
                } else {}
                value
            }
            if mutable {
                error_handler.report_error_at((*pattern).location, "Constant declaration can't be mutable", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
            } else {}
            return cast(^AstNode) (self.allocate(new AstConstDecl {
                id = self.next_id()
                location = (*pattern).location.to((*value_expr).location)
                pattern = &*pattern
                type_expr = type_expr
                value_expr = &*value_expr
                public = public
                scope = null
                typ = null
                value = Value.None
                flags = 0
                var_type = null
            }))
        } else {
            return cast(^AstNode) (self.allocate(new AstDecl {
                id = self.next_id()
                location = (*pattern).location.to((*type_expr).location)
                pattern = pattern
                type_expr = type_expr
                value_expr = null
                public = public
                mutable = mutable
                scope = null
                typ = null
                value = Value.None
                flags = 0
                name = "_"
                var_type = null
            }))
        }
        return pattern
    }
    
    parse_comma_expression(self: &Parser, allow_comma: bool, allow_function: bool) -> ^AstNode {
        expr : ^AstNode = self.parse_binary(allow_comma, allow_function, (int).min, true)
        if (allow_comma and self.check_token(TokenType.Comma)) {
            values : Array[^AstNode] = (Array[^AstNode]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            &values.add(expr)
            location : Location = (*expr).location
            loop {
                if !self.check_token(TokenType.Comma) then break else {}
                lexer.next_token()
                lexer.skip_whitespace()
                &values.add(self.parse_binary(true, allow_function, (int).min, true))
                location = location.to((**&values.peek_last()).location)
            }
            id : i64 = self.next_id()
            expr = cast(^AstNode) (self.allocate(new AstTuple {
                id = id
                location = location
                values = values
                scope = null
                typ = null
                value = Value.None
                flags = 0
            }))
        } else {}
        return expr
    }
    
    parse_binary(self: &Parser, allow_comma: bool, allow_function: bool, precedence: i64 = (int).min, left_associative: bool = true) -> ^AstNode {
        expr : ^AstNode = self.parse_unary(allow_comma, allow_function)
        loop {
            next : &Token = lexer.peek_token()
            @id((op, pre, left_asso)_197) : (BinOp, i64, bool) = match @tempvar_462((*next).typ) {
                TokenType.ReverseArrow -> (BinOp.Move, 3, false)
                TokenType.Pipe -> (BinOp.Pipe, 3, true)
                TokenType.KwAnd -> (BinOp.And, 4, true)
                TokenType.KwOr -> (BinOp.Or, 4, true)
                TokenType.Less -> (BinOp.Less, 5, true)
                TokenType.LessEqual -> (BinOp.LessEq, 5, true)
                TokenType.Greater -> (BinOp.Greater, 5, true)
                TokenType.GreaterEqual -> (BinOp.GreaterEq, 5, true)
                TokenType.DoubleEqual -> (BinOp.Equal, 5, true)
                TokenType.NotEqual -> (BinOp.NotEqual, 5, true)
                TokenType.PeriodPeriod -> (BinOp.Range, 6, true)
                TokenType.PeriodPeriodEq -> (BinOp.RangeIncl, 6, true)
                TokenType.Plus -> (BinOp.Add, 7, true)
                TokenType.Minus -> (BinOp.Sub, 7, true)
                TokenType.Asterisk -> (BinOp.Mul, 8, true)
                TokenType.ForwardSlash -> (BinOp.Div, 8, true)
                TokenType.Percent -> (BinOp.Mod, 8, true)
                _ -> {
                    return expr
                }
            }
            op : BinOp = @var(@id((op, pre, left_asso)_197))[0]
            pre : i64 = @var(@id((op, pre, left_asso)_197))[1]
            left_asso : bool = @var(@id((op, pre, left_asso)_197))[2]
            if ((pre == precedence) and (left_asso != left_associative)) {
                error_handler.report_error_at((*next).location, "Ambigious operator precedence. Use parenthesis to disambiguate", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                return expr
            } else {}
            if ((left_asso and (pre <= precedence)) or (!left_asso and (pre < precedence))) {
                return expr
            } else {}
            lexer.next_token()
            lexer.skip_whitespace()
            id : i64 = self.next_id()
            right : ^AstNode = self.parse_binary(allow_comma, allow_function, pre, left_asso)
            location : Location = (*expr).location.to((*right).location)
            expr = cast(^AstNode) (self.allocate(new AstBinary {
                id = id
                location = location
                operator = op
                left = &*expr
                right = &*right
                scope = null
                typ = null
                value = Value.None
                flags = 0
            }))
        }
        @assert(false)
        return null
    }
    
    parse_unary(self: &Parser, allow_comma: bool, allow_function: bool) -> ^AstNode {
        next : &Token = lexer.peek_token()
        match @tempvar_463((*next).typ) {
            TokenType.Minus -> {
                beg : Location = (lexer.next_token()).location
                sub : ^AstNode = self.parse_unary(allow_comma, allow_function)
                return cast(^AstNode) (self.allocate(new AstUnary {
                    id = self.next_id()
                    location = beg.to((*sub).location)
                    operator = UnOp.Neg
                    sub = &*sub
                    scope = null
                    typ = null
                    value = Value.None
                    flags = 0
                }))
            }
            TokenType.Bang -> {
                self.debug_log("unary bang {}", cast([]^any) ([cast(^any) ((*lexer.peek_token()).typ)]))
                beg : Location = (lexer.next_token()).location
                sub : ^AstNode = self.parse_unary(allow_comma, allow_function)
                return cast(^AstNode) (self.allocate(new AstUnary {
                    id = self.next_id()
                    location = beg.to((*sub).location)
                    operator = UnOp.Not
                    sub = &*sub
                    scope = null
                    typ = null
                    value = Value.None
                    flags = 0
                }))
            }
            TokenType.Ampersand -> {
                beg : Location = (lexer.next_token()).location
                mutable : bool = if self.check_token(TokenType.KwMut) {
                    lexer.next_token()
                    true
                } else {
                    false
                }
                sub : ^AstNode = self.parse_unary(allow_comma, allow_function)
                return cast(^AstNode) (self.allocate(new AstUnary {
                    id = self.next_id()
                    location = beg.to((*sub).location)
                    operator = if mutable then UnOp.RefMut else UnOp.Ref
                    sub = &*sub
                    scope = null
                    typ = null
                    value = Value.None
                    flags = 0
                }))
            }
            TokenType.Hat -> {
                beg : Location = (lexer.next_token()).location
                mutable : bool = if self.check_token(TokenType.KwMut) {
                    lexer.next_token()
                    true
                } else {
                    false
                }
                sub : ^AstNode = self.parse_unary(allow_comma, allow_function)
                return cast(^AstNode) (self.allocate(new AstUnary {
                    id = self.next_id()
                    location = beg.to((*sub).location)
                    operator = if mutable then UnOp.PtrMut else UnOp.Ptr
                    sub = &*sub
                    scope = null
                    typ = null
                    value = Value.None
                    flags = 0
                }))
            }
            TokenType.Asterisk -> {
                beg : Location = (lexer.next_token()).location
                sub : ^AstNode = self.parse_unary(allow_comma, allow_function)
                return cast(^AstNode) (self.allocate(new AstUnary {
                    id = self.next_id()
                    location = beg.to((*sub).location)
                    operator = UnOp.Deref
                    sub = &*sub
                    scope = null
                    typ = null
                    value = Value.None
                    flags = 0
                }))
            }
        }
        return self.parse_post_unary(allow_comma, allow_function)
    }
    
    parse_post_unary(self: &Parser, allow_comma: bool, allow_function: bool) -> ^AstNode {
        self.debug_log("parse_post_unary", cast([]^any) ([]))
        expr : ^AstNode = #macro {
            
            value : ^AstNode = self.parse_atomic_expression(allow_comma, allow_function)
            if (cast(^void) (value) == null) {
                return null
            } else {}
            value
        }
        loop {
            match @tempvar_464((*lexer.peek_token()).typ) {
                TokenType.OpenParen -> {
                    @id((args, beg, end)_198) : (Array[^AstArgument], Location, Location) = self.parse_argument_list(TokenType.OpenParen, TokenType.ClosingParen)
                    args : Array[^AstArgument] = @var(@id((args, beg, end)_198))[0]
                    beg : Location = @var(@id((args, beg, end)_198))[1]
                    end : Location = @var(@id((args, beg, end)_198))[2]
                    expr = cast(^AstNode) (self.allocate(new AstCall {
                        id = self.next_id()
                        location = (*expr).location.to(end)
                        function = &*expr
                        arguments = args
                        scope = null
                        typ = null
                        value = Value.None
                        flags = 0
                        ast_function = null
                    }))
                    @destruct(@id((args, beg, end)_198))
                }
                TokenType.OpenBracket -> {
                    @id((args, beg, end)_199) : (Array[^AstArgument], Location, Location) = self.parse_argument_list(TokenType.OpenBracket, TokenType.ClosingBracket)
                    args : Array[^AstArgument] = @var(@id((args, beg, end)_199))[0]
                    beg : Location = @var(@id((args, beg, end)_199))[1]
                    end : Location = @var(@id((args, beg, end)_199))[2]
                    if (&args.count() == 0) {
                        error_handler.report_error_at(beg, "Missing argument", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                        @destruct(args);
                        @destruct(@id((args, beg, end)_199));
                        return null
                    } else {}
                    index : ^AstArgument = *access(&args, 0)
                    expr = cast(^AstNode) (self.allocate(new AstIndex {
                        id = self.next_id()
                        location = (*expr).location.to(end)
                        sub = &*expr
                        arguments = args
                        index = cast(^AstNode) (index)
                        scope = null
                        typ = null
                        value = Value.None
                        flags = 0
                    }))
                    @destruct(@id((args, beg, end)_199))
                }
                TokenType.Period -> {
                    lexer.next_token()
                    name : ^AstIdentifier = #macro {
                        
                        value : ^AstIdentifier = self.parse_identifier()
                        if (cast(^void) (value) == null) {
                            return null
                        } else {}
                        value
                    }
                    expr = cast(^AstNode) (self.allocate(new AstDot {
                        id = self.next_id()
                        location = (*expr).location.to((*name).location)
                        sub = expr
                        name = &*name
                        scope = null
                        typ = null
                        value = Value.None
                        flags = 0
                        symbol = Symbol.NotFound
                    }))
                }
                _ -> {
                    self.debug_log("return expr", cast([]^any) ([]))
                    return expr
                }
            }
        }
        @assert(false)
        return null
    }
    
    parse_bracketed(self: &Parser) -> ^AstNode {
        beg : Location = (self.consume(TokenType.OpenBracket)).location
        values : Array[^AstNode] = (Array[^AstNode]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        loop {
            next : Token = *lexer.peek_token()
            if (((next).typ == TokenType.ClosingBracket) or ((next).typ == TokenType.EOF)) {
                break
            } else {}
            expr : ^AstNode = self.parse_expression(false, true)
            if (cast(^void) (expr) != null) {
                &values.add(expr)
            } else {}
            next = *lexer.peek_token()
            if (((next).typ == TokenType.ClosingBracket) or ((next).typ == TokenType.EOF)) {
                break
            } else {}
            self.consume(TokenType.Comma)
            lexer.skip_whitespace()
        }
        end : Location = (self.consume(TokenType.ClosingBracket)).location
        if self.is_expr_token() {
            if (&values.count() > 1) {
                error_handler.report_error_at(beg.to(end), "Too many values in array type expression", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
            } else {}
            target : ^AstNode = #macro {
                
                value : ^AstNode = self.parse_unary(false, false)
                if (cast(^void) (value) == null) {
                    @destruct(values);
                    return null
                } else {}
                value
            }
            count : ^AstNode = null
            if (&values.count() > 0) {
                count = *access(&values, 0)
            } else {}
            @destruct(values);
            return cast(^AstNode) (self.allocate(new AstArrayType {
                id = self.next_id()
                location = beg.to((*target).location)
                count = count
                target = &*target
                scope = null
                typ = null
                value = Value.None
                flags = 0
            }))
        } else {}
        return cast(^AstNode) (self.allocate(new AstArray {
            id = self.next_id()
            location = beg.to(end)
            values = values
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_block(self: &Parser) -> ^AstNode {
        id : i64 = self.next_id()
        children : Array[^AstNode] = (Array[^AstNode]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        location : Location = (self.consume(TokenType.OpenBrace)).location
        lexer.skip_whitespace()
        loop {
            next : Token = *lexer.peek_token()
            if (((next).typ == TokenType.ClosingBrace) or ((next).typ == TokenType.EOF)) {
                break
            } else {}
            child : ^AstNode = #macro {
                
                value : ^AstNode = self.parse_expression(true, true)
                if (cast(^void) (value) == null) {
                    @destruct(children);
                    return null
                } else {}
                value
            }
            &children.add(child)
            next = *lexer.peek_token()
            if (((next).typ == TokenType.ClosingBrace) or ((next).typ == TokenType.EOF)) {
                break
            } else {}
            self.consume(TokenType.NewLine)
        }
        lexer.skip_whitespace()
        end : Location = (self.consume(TokenType.ClosingBrace)).location
        (location).end_line = (end).end_line
        return cast(^AstNode) (self.allocate(new AstBlock {
            id = id
            location = location
            sub_scope = null
            children = children
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_match(self: &Parser, allow_comma: bool) -> ^AstNode {
        location : Location = (self.consume(TokenType.KwMatch)).location
        lexer.skip_whitespace()
        value_expr : ^AstNode = if self.check_token(TokenType.OpenBrace) then null else self.parse_expression(allow_comma, false)
        lexer.skip_whitespace()
        self.consume(TokenType.OpenBrace)
        cases : Array[^AstMatchCase] = (Array[^AstMatchCase]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        loop {
            lexer.skip_whitespace()
            next : &Token = lexer.peek_token()
            if (((*next).typ == TokenType.ClosingBrace) or ((*next).typ == TokenType.EOF)) {
                break
            } else {}
            pattern : ^AstNode = #macro {
                
                value : ^AstNode = self.parse_expression(true, false)
                if (cast(^void) (value) == null) {
                    @destruct(cases);
                    return null
                } else {}
                value
            }
            lexer.skip_whitespace()
            condition : ^AstNode = if self.check_token(TokenType.KwIf) {
                lexer.next_token()
                #macro {
                    
                    value : ^AstNode = self.parse_expression(true, false)
                    if (cast(^void) (value) == null) {
                        @destruct(cases);
                        return null
                    } else {}
                    value
                }
            } else {
                null
            }
            lexer.skip_whitespace()
            self.consume(TokenType.Arrow)
            body : ^AstNode = #macro {
                
                value : ^AstNode = self.parse_expression(true, false)
                if (cast(^void) (value) == null) {
                    @destruct(cases);
                    return null
                } else {}
                value
            }
            &cases.add(self.allocate(new AstMatchCase { pattern = &*pattern, condition = condition, body = &*body }))
        }
        end : Location = (self.consume(TokenType.ClosingBrace)).location
        return cast(^AstNode) (self.allocate(new AstMatch {
            id = self.next_id()
            location = location.to(end)
            value_expr = value_expr
            cases = cases
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_if(self: &Parser, allow_comma: bool) -> ^AstNode {
        id : i64 = self.next_id()
        location : Location = (self.consume(TokenType.KwIf)).location
        lexer.skip_whitespace()
        condition : ^AstNode = self.parse_expression(false, false)
        true_case : ^AstNode = if self.check_token(TokenType.KwThen) {
            lexer.next_token()
            self.parse_expression(allow_comma, false)
        } else {
            self.parse_block()
        }
        location = location.to((*true_case).location)
        false_case : ^AstNode = if self.check_token(TokenType.KwElse) {
            lexer.next_token()
            lexer.skip_whitespace()
            expr : ^AstNode = self.parse_expression(allow_comma, false)
            location = location.to((*expr).location)
            expr
        } else {
            null
        }
        return cast(^AstNode) (self.allocate(new AstIf {
            id = id
            location = location
            condition = &*condition
            true_case = &*true_case
            false_case = false_case
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_loop(self: &Parser, allow_comma: bool) -> ^AstNode {
        id : i64 = self.next_id()
        location : Location = (self.consume(TokenType.KwLoop)).location
        body : ^AstNode = self.parse_expression(allow_comma, false)
        location = location.to((*body).location)
        return cast(^AstNode) (self.allocate(new AstLoop {
            id = id
            location = location
            body = &*body
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_for(self: &Parser, allow_comma: bool) -> ^AstNode {
        id : i64 = self.next_id()
        location : Location = (self.consume(TokenType.KwFor)).location
        it_pattern : ^AstNode = null
        index_name : ^AstIdentifier = null
        collection : ^AstNode = null
        expr : ^AstNode = self.parse_expression(false, false)
        if self.check_token(TokenType.Comma) {
            it_pattern = expr
            lexer.next_token()
            lexer.skip_whitespace()
            index_name = #macro {
                
                value : ^AstIdentifier = self.parse_identifier()
                if (cast(^void) (value) == null) {
                    return null
                } else {}
                value
            }
            lexer.skip_whitespace()
            self.consume(TokenType.KwIn)
            collection = self.parse_expression(false, false)
        } else if self.check_token(TokenType.KwIn) {
            it_pattern = expr
            lexer.next_token()
            lexer.skip_whitespace()
            collection = self.parse_expression(false, false)
        } else {
            collection = expr
        }
        body : ^AstNode = self.parse_block()
        location = location.to((*body).location)
        return cast(^AstNode) (self.allocate(new AstFor {
            id = id
            location = location
            it_pattern = it_pattern
            index_name = index_name
            collection = &*collection
            body = &*body
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_break(self: &Parser, allow_comma: bool) -> ^AstNode {
        id : i64 = self.next_id()
        location : Location = (self.consume(TokenType.KwBreak)).location
        return cast(^AstNode) (self.allocate(new AstBreak {
            id = id
            location = location
            label = null
            value_expr = null
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_continue(self: &Parser, allow_comma: bool) -> ^AstNode {
        id : i64 = self.next_id()
        location : Location = (self.consume(TokenType.KwContinue)).location
        return cast(^AstNode) (self.allocate(new AstContinue {
            id = id
            location = location
            label = null
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_defer(self: &Parser, allow_comma: bool) -> ^AstNode {
        id : i64 = self.next_id()
        location : Location = (self.consume(TokenType.KwDefer)).location
        sub : ^AstNode = self.parse_expression(allow_comma, false)
        location = location.to((*sub).location)
        return cast(^AstNode) (self.allocate(new AstDefer {
            id = id
            location = location
            sub = &*sub
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_return(self: &Parser, allow_comma: bool) -> ^AstNode {
        id : i64 = self.next_id()
        location : Location = (self.consume(TokenType.KwReturn)).location
        value_expr : ^AstNode = null
        if self.is_expr_token() {
            value_expr = self.parse_expression(allow_comma, true)
        } else {}
        return cast(^AstNode) (self.allocate(new AstReturn {
            id = id
            location = location
            value_expr = value_expr
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    values_to_params(self: &Parser, values: Array[^AstNode]) -> Array[^AstDecl] {
        params : Array[^AstDecl] = (Array[^AstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        #macro {
            local arr : &Array[^AstNode] = &values
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &^AstNode = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            e : &^AstNode = it
                            it_index : i64 = it_index
                            {
                                match @tempvar_465(*e) {
                                    AstDecl($decl) -> &params.add(decl)
                                    _ -> {
                                        decl : ^AstDecl = self.allocate(new AstDecl {
                                            id = self.next_id()
                                            location = (**e).location
                                            pattern = null
                                            type_expr = *e
                                            value_expr = null
                                            mutable = false
                                            scope = null
                                            typ = null
                                            value = Value.None
                                            flags = 0
                                            public = false
                                            name = "_"
                                            var_type = null
                                        })
                                        &params.add(decl)
                                    }
                                }
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        @destruct(values);
        return params
    }
    
    parse_parenthesized(self: &Parser, allow_comma: bool, allow_function: bool) -> ^AstNode {
        beg : Location = (self.consume(TokenType.OpenParen)).location
        ends_in_comma : bool = false
        values : Array[^AstNode] = (Array[^AstNode]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        loop {
            next : Token = *lexer.peek_token()
            if (((next).typ == TokenType.ClosingParen) or ((next).typ == TokenType.EOF)) {
                break
            } else {}
            expr : ^AstNode = self.parse_expression(false, true)
            ends_in_comma = false
            if (cast(^void) (expr) != null) {
                &values.add(expr)
            } else {}
            next = *lexer.peek_token()
            if (((next).typ == TokenType.ClosingParen) or ((next).typ == TokenType.EOF)) {
                break
            } else {}
            self.consume(TokenType.Comma)
            ends_in_comma = true
            lexer.skip_whitespace()
        }
        end : Location = (self.consume(TokenType.ClosingParen)).location
        if allow_function {
            if self.check_token(TokenType.KwConst) {
                lexer.next_token()
                lexer.skip_whitespace()
                body : ^AstNode = self.parse_expression(allow_comma, false)
                return cast(^AstNode) (self.allocate(new AstPoly {
                    id = self.next_id()
                    location = beg.to((*body).location)
                    param_scope = null
                    params = self.values_to_params(values)
                    value_expr = &*body
                    scope = null
                    typ = null
                    value = Value.None
                    flags = 0
                    name = "#anonymous"
                }))
            } else {}
            if ((self.check_token(TokenType.KwStruct) or self.check_token(TokenType.KwEnum)) or self.check_token(TokenType.KwTrait)) {
                body : ^AstNode = self.parse_expression(allow_comma, false)
                return cast(^AstNode) (self.allocate(new AstPoly {
                    id = self.next_id()
                    location = beg.to((*body).location)
                    param_scope = null
                    params = self.values_to_params(values)
                    value_expr = &*body
                    scope = null
                    typ = null
                    value = Value.None
                    flags = 0
                    name = "#anonymous"
                }))
            } else {}
            return_type_expr : ^AstNode = null
            if self.check_token(TokenType.Arrow) {
                lexer.next_token()
                lexer.skip_whitespace()
                return_type_expr = #macro {
                    
                    value : ^AstNode = self.parse_expression(true, false)
                    if (cast(^void) (value) == null) {
                        @destruct(values);
                        return null
                    } else {}
                    value
                }
            } else {}
            if ((cast(^void) (return_type_expr) != null) or self.check_token(TokenType.OpenBrace)) {
                body : ^AstNode = null
                if self.check_token(TokenType.OpenBrace) {
                    body = self.parse_block()
                } else {}
                return cast(^AstNode) (self.allocate(new AstFunction {
                    id = self.next_id()
                    location = beg.to((*body).location)
                    param_scope = null
                    params = self.values_to_params(values)
                    return_type_expr = return_type_expr
                    body = body
                    scope = null
                    typ = null
                    value = Value.None
                    flags = 0
                    name = "#anonymous"
                    return_type = null
                    bytecode = null
                }))
            } else {}
        } else {}
        if ((&values.count() == 1) and !ends_in_comma) {
            @destruct(values);
            return *access(&values, 0)
        } else {}
        return cast(^AstNode) (self.allocate(new AstTuple {
            id = self.next_id()
            location = beg.to(end)
            values = values
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_struct(self: &Parser) -> ^AstNode {
        nodes : Array[^AstNode] = (Array[^AstNode]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        beg : Location = (self.consume(TokenType.KwStruct)).location
        trait_expr : ^AstNode = if !self.check_token(TokenType.OpenBrace) #macro {
            
            value : ^AstNode = self.parse_expression(false, false)
            if (cast(^void) (value) == null) {
                @destruct(nodes);
                return null
            } else {}
            value
        } else null
        lexer.skip_whitespace()
        self.consume(TokenType.OpenBrace)
        loop {
            lexer.skip_whitespace()
            next : &Token = lexer.peek_token()
            if (((*next).typ == TokenType.ClosingBrace) or ((*next).typ == TokenType.EOF)) {
                break
            } else {}
            node : ^AstNode = self.parse_node()
            if (cast(^void) (node) == null) then break else {}
            &nodes.add(node)
        }
        end : Location = (self.consume(TokenType.ClosingBrace)).location
        return cast(^AstNode) (self.allocate(new AstStruct {
            id = self.next_id()
            location = beg.to(end)
            trait_expr = trait_expr
            children = nodes
            scope = null
            typ = null
            value = Value.None
            flags = 0
            name = "#anonymous"
            sub_scope = null
            struct_type = null
            members = (Array[^AstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            constants = (Array[^AstConstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            members_done = false
        }))
    }
    
    parse_enum(self: &Parser) -> ^AstNode {
        nodes : Array[^AstNode] = (Array[^AstNode]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        beg : Location = (self.consume(TokenType.KwEnum)).location
        lexer.skip_whitespace()
        self.consume(TokenType.OpenBrace)
        loop {
            lexer.skip_whitespace()
            next : &Token = lexer.peek_token()
            if (((*next).typ == TokenType.ClosingBrace) or ((*next).typ == TokenType.EOF)) {
                break
            } else {}
            node : ^AstNode = self.parse_node()
            if (cast(^void) (node) == null) then break else {}
            &nodes.add(node)
        }
        end : Location = (self.consume(TokenType.ClosingBrace)).location
        return cast(^AstNode) (self.allocate(new AstEnum {
            id = self.next_id()
            location = beg.to(end)
            children = nodes
            scope = null
            typ = null
            value = Value.None
            flags = 0
            name = "#anonymous"
            sub_scope = null
            enum_type = null
            members = (Array[^AstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            members_done = false
        }))
    }
    
    parse_trait(self: &Parser) -> ^AstNode {
        nodes : Array[^AstNode] = (Array[^AstNode]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        beg : Location = (self.consume(TokenType.KwTrait)).location
        lexer.skip_whitespace()
        self.consume(TokenType.OpenBrace)
        loop {
            lexer.skip_whitespace()
            next : &Token = lexer.peek_token()
            if (((*next).typ == TokenType.ClosingBrace) or ((*next).typ == TokenType.EOF)) {
                break
            } else {}
            node : ^AstNode = self.parse_node()
            if (cast(^void) (node) == null) then break else {}
            &nodes.add(node)
        }
        end : Location = (self.consume(TokenType.ClosingBrace)).location
        return cast(^AstNode) (self.allocate(new AstTrait {
            id = self.next_id()
            location = beg.to(end)
            children = nodes
            scope = null
            typ = null
            value = Value.None
            flags = 0
            name = "#anonymous"
            sub_scope = null
            trait_type = null
            members = (Array[^AstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            functions = (Array[^AstConstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            members_done = false
        }))
    }
    
    parse_impl(self: &Parser) -> ^AstNode {
        nodes : Array[^AstNode] = (Array[^AstNode]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        target_trait : ^AstNode = null
        beg : Location = (self.consume(TokenType.KwImpl)).location
        lexer.skip_whitespace()
        target : ^AstNode = #macro {
            
            value : ^AstNode = self.parse_expression(false, false)
            if (cast(^void) (value) == null) {
                @destruct(nodes);
                return null
            } else {}
            value
        }
        lexer.skip_whitespace()
        if self.check_token(TokenType.KwFor) {
            lexer.next_token()
            lexer.skip_whitespace()
            target_trait = target
            target = #macro {
                
                value : ^AstNode = self.parse_expression(false, false)
                if (cast(^void) (value) == null) {
                    @destruct(nodes);
                    return null
                } else {}
                value
            }
            lexer.skip_whitespace()
        } else {}
        self.consume(TokenType.OpenBrace)
        loop {
            lexer.skip_whitespace()
            next : &Token = lexer.peek_token()
            if (((*next).typ == TokenType.ClosingBrace) or ((*next).typ == TokenType.EOF)) {
                break
            } else {}
            node : ^AstNode = self.parse_node()
            if (cast(^void) (node) == null) then break else {}
            &nodes.add(node)
        }
        end : Location = (self.consume(TokenType.ClosingBrace)).location
        return cast(^AstNode) (self.allocate(new AstImpl {
            id = self.next_id()
            location = beg.to(end)
            children = nodes
            target_expr = &*target
            trait_expr = target_trait
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_use(self: &Parser, allow_comma: bool, allow_function: bool) -> ^AstNode {
        beg : Location = (self.consume(TokenType.KwUse)).location
        value : ^AstNode = #macro {
            
            value : ^AstNode = self.parse_expression(allow_comma, allow_function)
            if (cast(^void) (value) == null) {
                return null
            } else {}
            value
        }
        return cast(^AstNode) (self.allocate(new AstUse {
            id = self.next_id()
            location = beg.to((*value).location)
            value_expr = &*value
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_import(self: &Parser, allow_comma: bool, allow_function: bool) -> ^AstNode {
        beg : Location = (self.consume(TokenType.KwImport)).location
        path : ^AstNode = #macro {
            
            value : ^AstNode = self.parse_expression(allow_comma, allow_function)
            if (cast(^void) (value) == null) {
                return null
            } else {}
            value
        }
        return cast(^AstNode) (self.allocate(new AstImport {
            id = self.next_id()
            location = beg.to((*path).location)
            path = &*path
            scope = null
            typ = null
            value = Value.None
            flags = 0
        }))
    }
    
    parse_atomic_expression(self: &Parser, allow_comma: bool, allow_function: bool) -> ^AstNode {
        token : &Token = lexer.peek_token()
        return match @tempvar_467((*token).typ) {
            TokenType.Identifier -> cast(^AstNode) (self.parse_identifier())
            TokenType.KwBreak -> self.parse_break(allow_comma)
            TokenType.KwContinue -> self.parse_continue(allow_comma)
            TokenType.KwDefer -> self.parse_defer(allow_comma)
            TokenType.KwEnum -> self.parse_enum()
            TokenType.KwFalse -> cast(^AstNode) (self.parse_bool())
            TokenType.KwFor -> self.parse_for(allow_comma)
            TokenType.KwIf -> self.parse_if(allow_comma)
            TokenType.KwImpl -> self.parse_impl()
            TokenType.KwImport -> self.parse_import(allow_comma, allow_function)
            TokenType.KwLoop -> self.parse_loop(allow_comma)
            TokenType.KwMatch -> self.parse_match(allow_comma)
            TokenType.KwReturn -> self.parse_return(allow_comma)
            TokenType.KwStruct -> self.parse_struct()
            TokenType.KwTrait -> self.parse_trait()
            TokenType.KwTrue -> cast(^AstNode) (self.parse_bool())
            TokenType.KwUse -> self.parse_use(allow_comma, allow_function)
            TokenType.NumberLiteral -> self.parse_number()
            TokenType.OpenBrace -> self.parse_block()
            TokenType.OpenBracket -> self.parse_bracketed()
            TokenType.OpenParen -> self.parse_parenthesized(allow_comma, allow_function)
            TokenType.Period -> self.parse_anonymous_dot()
            TokenType.StringLiteral -> cast(^AstNode) (self.parse_string())
            _ -> {
                error_handler.report_error_at((*token).location, "Unexpected token {} in expression", cast([]^any) ([cast(^any) ((*token).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                null
            }
        }
    }
    
    parse_anonymous_dot(self: &Parser) -> ^AstNode {
        beg : Location = (self.consume(TokenType.Period)).location
        name : ^AstIdentifier = #macro {
            
            value : ^AstIdentifier = self.parse_identifier()
            if (cast(^void) (value) == null) {
                return null
            } else {}
            value
        }
        return cast(^AstNode) (self.allocate(new AstDot {
            id = self.next_id()
            location = beg.to((*name).location)
            sub = null
            name = &*name
            scope = null
            typ = null
            value = Value.None
            flags = 0
            symbol = Symbol.NotFound
        }))
    }
    
    parse_string(self: &Parser) -> ^AstString {
        id : i64 = self.next_id()
        tok : Token = lexer.next_token()
        value : string = if ((tok).typ == TokenType.StringLiteral) {
            ((tok).data).String
        } else {
            @assert(false)
            return null
        }
        return self.allocate(new AstString {
            id = id
            location = (tok).location
            string_value = value
            scope = null
            typ = null
            value = Value.None
            flags = 0
        })
    }
    
    parse_bool(self: &Parser) -> ^AstBool {
        id : i64 = self.next_id()
        tok : Token = lexer.next_token()
        value : bool = if ((tok).typ == TokenType.KwTrue) {
            true
        } else if ((tok).typ == TokenType.KwFalse) {
            false
        } else {
            @assert(false)
            return null
        }
        return self.allocate(new AstBool {
            id = id
            location = (tok).location
            bool_value = value
            scope = null
            typ = null
            value = Value.None
            flags = 0
        })
    }
    
    parse_identifier(self: &Parser) -> ^AstIdentifier {
        id : i64 = self.next_id()
        tok : Token = lexer.next_token()
        if ((tok).typ != TokenType.Identifier) {
            return null
        } else {}
        name : string = ((tok).data).String
        return self.allocate(new AstIdentifier {
            id = id
            location = (tok).location
            name = name
            scope = null
            typ = null
            value = Value.None
            flags = 0
            symbol = Symbol.NotFound
        })
    }
    
    parse_number(self: &Parser) -> ^AstNode {
        id : i64 = self.next_id()
        tok : Token = lexer.next_token()
        if ((tok).typ != TokenType.NumberLiteral) {
            return null
        } else {}
        value : Value = match @tempvar_468((tok).data) {
            TokenData.Integer($i) -> Value.Int(i)
            TokenData.Double($f) -> Value.Float(f)
            _ -> @assert(false)
        }
        return cast(^AstNode) (self.allocate(new AstNumberLiteral {
            id = id
            location = (tok).location
            value = value
            scope = null
            typ = null
            flags = 0
        }))
    }
    
    parse_argument(self: &Parser) -> ^AstArgument {
        id : i64 = self.next_id()
        name : ^AstIdentifier = null
        expr : ^AstNode = #macro {
            
            value : ^AstNode = self.parse_expression(false, true)
            if (cast(^void) (value) == null) {
                return null
            } else {}
            value
        }
        if self.check_token(TokenType.Equal) {
            match @tempvar_469(&*expr) {
                AstIdentifier($id) -> {
                    name = ^*id
                }
                _ -> {
                    error_handler.report_error_at((*expr).location, "Name of argument must be an identifier", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                }
            }
            lexer.next_token()
            lexer.skip_whitespace()
            expr = #macro {
                
                value : ^AstNode = self.parse_expression(false, true)
                if (cast(^void) (value) == null) {
                    return null
                } else {}
                value
            }
        } else {}
        return self.allocate(new AstArgument {
            id = id
            location = (*expr).location
            name = name
            value_expr = &*expr
            scope = null
            typ = null
            value = Value.None
            flags = 0
        })
    }
    
    parse_argument_list(self: &Parser, open: TokenType, close: TokenType) -> (Array[^AstArgument], Location, Location) {
        args : Array[^AstArgument] = (Array[^AstArgument]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        beg : Location = (self.consume(open)).location
        lexer.skip_whitespace()
        loop {
            next : Token = *lexer.peek_token()
            if (((next).typ == close) or ((next).typ == TokenType.EOF)) {
                break
            } else {}
            arg : ^AstArgument = self.parse_argument()
            if (cast(^void) (arg) == null) {
                return (args, beg, beg)
            } else {}
            &args.add(arg)
            next = *lexer.peek_token()
            if (((next).typ == close) or ((next).typ == TokenType.EOF)) {
                break
            } else if ((next).typ == TokenType.NewLine) {
                lexer.skip_whitespace()
            } else {
                self.consume(TokenType.Comma)
                lexer.skip_whitespace()
            }
        }
        end : Location = (self.consume(close)).location
        return (args, beg, end)
    }
    
    is_expr_token(self: &Parser) -> bool {
        token : &Token = lexer.peek_token()
        return match @tempvar_471((*token).typ) {
            TokenType.Identifier -> true
            TokenType.DollarIdentifier -> true
            TokenType.AtSignIdentifier -> true
            TokenType.HashIdentifier -> true
            TokenType.NumberLiteral -> true
            TokenType.StringLiteral -> true
            TokenType.KwTrue -> true
            TokenType.KwFalse -> true
            TokenType.KwIf -> true
            TokenType.KwLoop -> true
            TokenType.KwMatch -> true
            TokenType.KwNull -> true
            TokenType.OpenParen -> true
            TokenType.OpenBrace -> true
            TokenType.OpenBracket -> true
            TokenType.Ampersand -> true
            TokenType.Minus -> true
            TokenType.Asterisk -> true
            TokenType.LessLess -> true
            TokenType.Hat -> true
            TokenType.Bang -> true
            TokenType.Period -> true
            _ -> false
        }
    }
    
    check_token(self: &Parser, typ: TokenType) -> bool {
        token : &Token = lexer.peek_token()
        return ((*token).typ == typ)
    }
    
    consume(self: &Parser, typ: TokenType) -> Token {
        tok : &Token = lexer.peek_token()
        loop {
            if !((*tok).typ != typ) then break else {}
            match @tempvar_472((*tok).typ) {
                TokenType.EOF -> {
                    break
                }
            }
            error_handler.report_error_at((*tok).location, "Unexpected token {}, expected {}", cast([]^any) ([cast(^any) ((*tok).typ), cast(^any) (typ)]), "", cast([](fmt: string, args: []^any)) ([]))
            lexer.skip_line()
            return *tok
        }
        return lexer.next_token()
    }
}

#file scope.che
use import std.map

use import std.thread

use import std.array

fmt :  : import std.fmt

io :  : import std.io

use import logging.logger

use import ast

use import types

use import value

use import compiler

Scope :: struct { // size: 136, alignment: 8
    parent : ^Scope
    symbols : Map[string, Symbol] = (Map[string, Symbol]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    impls : Option[Map[TypeId, Array[^AstImpl]]] = Option[Map[TypeId, Array[^AstImpl]]].None
    mutex : Option[Mutex] = Option[Mutex].None
    constant : bool = false
}

impl Scope {
    debug_log(self: &Scope, msg: string, args: []^any = cast([]^any) ([])) {}
    
    lock(self: &Scope) {
        match @tempvar_473(&mutex) {
            Option[Mutex].Some($m) -> {
                m.lock()
            }
        }
    }
    
    release(self: &Scope) {
        match @tempvar_474(&mutex) {
            Option[Mutex].Some($m) -> {
                m.release()
            }
        }
    }
    
    define_value(self: &Scope, name: string, typ: ^TypeInfo, val: Value) -> Result[(), ()] {
        self.lock()
        defer self.release()
        if &symbols.contains(name) {
            self.release();
            return Result[(), ()].Err
        } else {}
        set(&symbols, name, Symbol.Val((typ, val)))
        self.release();
        return Result[(), ()].Ok
    }
    
    define_function(self: &Scope, name: string, func: &AstFunction) -> Result[(), ()] {
        self.lock()
        defer self.release()
        if &symbols.contains(name) {
            self.release();
            return Result[(), ()].Err
        } else {}
        set(&symbols, name, Symbol.Func(^*func))
        self.release();
        return Result[(), ()].Ok
    }
    
    define_decl(self: &Scope, name: string, decl: &AstDecl) -> Result[(), ()] {
        self.lock()
        defer self.release()
        if &symbols.contains(name) {
            self.release();
            return Result[(), ()].Err
        } else {}
        set(&symbols, name, Symbol.Decl(^*decl))
        self.release();
        return Result[(), ()].Ok
    }
    
    define_const_decl(self: &Scope, name: string, decl: &AstConstDecl) -> Result[(), ()] {
        self.lock()
        defer self.release()
        if &symbols.contains(name) {
            self.release();
            return Result[(), ()].Err
        } else {}
        set(&symbols, name, Symbol.ConstDecl(^*decl))
        self.release();
        return Result[(), ()].Ok
    }
    
    define_native_function(self: &Scope, name: string, wrapper: ^NativeFunctionWrapper) -> Result[(), ()] {
        self.lock()
        defer self.release()
        if &symbols.contains(name) {
            self.release();
            return Result[(), ()].Err
        } else {}
        set(&symbols, name, Symbol.NativeFunc(wrapper))
        self.release();
        return Result[(), ()].Ok
    }
    
    define_symbol(self: &Scope, name: string, symbol: Symbol) -> Result[(), ()] {
        self.lock()
        defer self.release()
        if &symbols.contains(name) {
            self.release();
            return Result[(), ()].Err
        } else {}
        set(&symbols, name, symbol)
        self.release();
        return Result[(), ()].Ok
    }
    
    get_symbol(self: &Scope, name: string, only_public: bool = false) -> Symbol {
        if (cast(^void) (parent) == null) {
            self.lock()
            defer self.release()
            #macro {
                
                
                
                
                fiber_context : ^FiberContext = (Fiber).user_data()
                if (*(*fiber_context).job).cancelled {
                    #link #anonymous {
                        self.release();
                        return Symbol.NotFound
                    }
                    loop {
                        (Fiber).yield()
                    }
                } else {}
                (*(*fiber_context).job).progressed = true
                loop {
                    if &symbols.contains(name) then break else {}
                    if DEBUG_WAIT then g_logger.log("suspending on {}", cast([]^any) ([cast(^any) (@expr_to_string(&symbols.contains(name)))]), (*fiber_context).job.get_name()) else {}
                    self.release()
                    (Fiber).yield()
                    self.lock()
                    if DEBUG_WAIT then g_logger.log("resuming on {}", cast([]^any) ([cast(^any) (@expr_to_string(&symbols.contains(name)))]), (*fiber_context).job.get_name()) else {}
                    (*(*fiber_context).job).progressed = false
                    if (*(*fiber_context).job).cancelled {
                        #link #anonymous {
                            self.release();
                            return Symbol.NotFound
                        }
                        loop {
                            (Fiber).yield()
                        }
                    } else {}
                }
                if DEBUG_WAIT then g_logger.log("done on {}", cast([]^any) ([cast(^any) (@expr_to_string(&symbols.contains(name)))]), (*fiber_context).job.get_name()) else {}
                (*(*fiber_context).job).progressed = true
            }
            result : &Symbol = &symbols.at(name)
            if only_public {
                match @tempvar_475(result) {
                    Symbol.Decl($decl) if !(**decl).public -> {
                        self.release();
                        return Symbol.Private(cast(^AstNode) (*decl))
                    }
                    Symbol.ConstDecl($decl) if !(**decl).public -> {
                        self.release();
                        return Symbol.Private(cast(^AstNode) (*decl))
                    }
                }
            } else {}
            self.release();
            return *result
        } else {}
        @assert(((*self).mutex == Option[Mutex].None))
        return match @tempvar_476(&symbols.get(name)) {
            Option[&Symbol].Some($sym) -> *sym
            Option[&Symbol].None -> {
                sym : Symbol = &*parent.get_symbol(name, false)
                if constant {
                    match @tempvar_477(&sym) {
                        Symbol.Decl(_) -> {
                            return Symbol.Poison
                        }
                    }
                } else {}
                return sym
            }
        }
    }
    
    add_impl(self: &Scope, imp: ^AstImpl) {
        if ((*self).impls == Option[Map[TypeId, Array[^AstImpl]]].None) {
            @destruct((*self).impls);
            (*self).impls = Option[Map[TypeId, Array[^AstImpl]]].Some((Map[TypeId, Array[^AstImpl]]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)))
        } else {}
        @assert(((*self).impls == Option[Map[TypeId, Array[^AstImpl]]].Some))
        type_id : TypeId = &*(*(*imp).target_expr).typ.id()
        arr : &Array[^AstImpl] = &((*self).impls).Some.get_or_insert(type_id, ()  -> Array[^AstImpl] => (Array[^AstImpl]).new(initial_capacity = 1, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)))
        arr.add(imp)
    }
    
    get_impls(self: &Scope, typ: ^TypeInfo) -> ScopeImplIterator {
        return new ScopeImplIterator { typ = typ, scope = self }
    }
}

ScopeImplIterator :: struct { // size: 24, alignment: 8
    typ : ^TypeInfo
    scope : &Scope
}

for_extension_ScopeImplIterator :: for_extension_ScopeImplIterator(iter: ScopeImplIterator, code: Code) #for {
    scope :  = ^*(iter).scope
    it_index :  = 0
    loop  #label outer_loop{
        if !(scope != null) then break
        match &(scope).impls {
            Some($map) -> {
                @static_assert((@typeof(map) == &Map[TypeId, Array[^AstImpl]]))
                for kv, _ : map {
                    if (((kv).key).type_info() == (iter).typ) {
                        impls :  = (kv).value
                        for imp : impls {
                            it :  = ^imp
                            @insert(code, _break = @link(break outer_loop), _continue = @link(continue))
                            it_index = 1
                        }
                    }
                }
            }
            None -> {}
        }
        scope = (scope).parent
    }
}

Symbol :: enum<i64> { // size: 0, alignment: 1
    Poison = 0
    NotFound = 1
    Private : ^AstNode = 2
    Decl : ^AstDecl = 3
    ConstDecl : ^AstConstDecl = 4
    Val : (typ: ^TypeInfo, value: Value) = 5
    Func : ^AstFunction = 6
    NativeFunc : ^NativeFunctionWrapper = 7
    NativeFunc2 : fn(fn(), ^Interpreter) = 8
    StructMember : ^TypeInfoStructMember = 9
}

#file string_database.che
use import std.string

use import std.hash

use import std.hash_table

use import std.mem.allocator

use import std.mem.arena_allocator

C :  : import std.c

impl string {
    same(a: string, b: string) -> bool {
        return ((((a).bytes).length == ((b).bytes).length) and (cast(^void) (((a).bytes).data) == cast(^void) (((b).bytes).data)))
    }
}

StringDatabase :: struct { // size: 120, alignment: 8
    pool : ArenaAllocator
    db : Table[string, string]
}

impl StringDatabase {
    new() -> StringDatabase {
        sdb : StringDatabase = new StringDatabase { pool = (ArenaAllocator).new(1024, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)), db = (Table[string, string]).create(strings_equal, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) }
        return sdb
    }
    
    intern(self: &StringDatabase, str: string) -> string {
        return match @tempvar_478(&db.get(str)) {
            Option[&string].Some($s) -> *s
            Option[&string].None -> {
                str_in_pool : string = {
                    mem : []u8 = alloc_n(cast (((str).bytes).length), cast(^Allocator) (^pool))
                    @string_from_ptr_and_length((mem).data, (mem).length)
                }
                (C).memcpy(cast(^void) (((str_in_pool).bytes).data), cast(^void) (((str).bytes).data), cast (((str).bytes).length))
                &db.set(str_in_pool, str_in_pool)
                str_in_pool
            }
        }
    }
}

#file value.che
mem :  : import std.mem.allocator

util :  : import std.util

use import ast

use import compiler

use import interpreter

Value :: enum<i64> { // size: 0, alignment: 1
    None = 0
    Poison = 1
    Function : ^AstFunction = 2
    Poly : ^AstPoly = 3
    Bool : bool = 4
    Int : i64 = 5
    Float : f64 = 6
    String : string = 7
    NativeFunc : ^NativeFunctionWrapper = 8
    NativeFunc2 : (wrapper: fn(fn(), ^Interpreter), func: fn()) = 9
    Type : ^TypeInfo = 10
    Module : ^SourceFile = 11
}

impl Value {
    as_type(self: &Value) -> ^TypeInfo {
        return match @tempvar_479(self) {
            Value.Type($ti) -> *ti
            _ -> @assert(false)
        }
    }
    
    as_module(self: &Value) -> ^SourceFile {
        return match @tempvar_480(self) {
            Value.Module($sf) -> *sf
            _ -> @assert(false)
        }
    }
}

NativeFunction :: Fn(^Interpreter) = Fn(^Interpreter)

NativeFunctionWrapper2 :: fn(fn(), ^Interpreter) = fn(fn(), ^Interpreter)

NativeFunctionWrapper :: struct { // size: 48, alignment: 8
    function : Fn(^Interpreter)
    function_type : ^TypeInfoFunction
    arg_slots : i64
    parameter_indices : []i64
}

impl NativeFunctionWrapper {
    new(func: NativeFunction, $T: type) -> ^NativeFunctionWrapper {
        ti :  = cast() (@type_info(T))
        raw :  = (mem).alloc_raw(u8, cast ((@sizeof(NativeFunctionWrapper) + (((ti).param_types).length * @sizeof(int)))))
        indices :  = cast() ((util).pointer_add(raw, @sizeof(NativeFunctionWrapper)))
        (indices).length = ((ti).param_types).length
        wrapper :  = cast() (raw)
        slot_index :  = 0
        for(reverse = true) typ : (ti).param_types {
            slot_index = (((typ).size + 7) / 8)
            *indices[it_index_rev] = slot_index
        }
        *wrapper = NativeFunctionWrapper(function = func, function_type = ti, arg_slots = -slot_index, parameter_indices = indices)
        return wrapper
    }
    // Polymorphic instances for new(func: NativeFunction, $T: type) -> ^NativeFunctionWrapper
        /*  */
        /* T = fn() -> ^Compiler */
        new(func: Fn(^Interpreter)) -> ^NativeFunctionWrapper {
            ti : ^TypeInfoFunction = cast(^TypeInfoFunction) (@type_info(fn() -> ^Compiler))
            raw : ^u8 = (mem).alloc_raw(cast ((@sizeof(NativeFunctionWrapper) + (((*ti).param_types).length * @sizeof(int)))), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            indices : []i64 = cast([]i64) (cast(^i64) ((util).pointer_add(raw, @sizeof(NativeFunctionWrapper))))
            (indices).length = ((*ti).param_types).length
            wrapper : ^NativeFunctionWrapper = cast(^NativeFunctionWrapper) (raw)
            slot_index : i64 = 0
            #macro {
                local arr : []^TypeInfo = (*ti).param_types
                
                local reverse : bool : true
                local by_ref : bool : false
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it_index_rev : i64 = (((arr).length - it_index) - 1)
                            it : ^TypeInfo = *get_index(arr, it_index_rev)
                            #link #anonymous {
                                typ : ^TypeInfo = it
                                it_index : i64 = it_index
                                {
                                    slot_index = (slot_index - (((*typ).size + 7) / 8))
                                    *get_index(indices, it_index_rev) = slot_index
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            *wrapper = new NativeFunctionWrapper { function = func, function_type = ti, arg_slots = -slot_index, parameter_indices = indices }
            return wrapper
        }
        /*  */
        /* T = fn(string) */
        new(func: Fn(^Interpreter)) -> ^NativeFunctionWrapper {
            ti : ^TypeInfoFunction = cast(^TypeInfoFunction) (@type_info(fn(string)))
            raw : ^u8 = (mem).alloc_raw(cast ((@sizeof(NativeFunctionWrapper) + (((*ti).param_types).length * @sizeof(int)))), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            indices : []i64 = cast([]i64) (cast(^i64) ((util).pointer_add(raw, @sizeof(NativeFunctionWrapper))))
            (indices).length = ((*ti).param_types).length
            wrapper : ^NativeFunctionWrapper = cast(^NativeFunctionWrapper) (raw)
            slot_index : i64 = 0
            #macro {
                local arr : []^TypeInfo = (*ti).param_types
                
                local reverse : bool : true
                local by_ref : bool : false
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it_index_rev : i64 = (((arr).length - it_index) - 1)
                            it : ^TypeInfo = *get_index(arr, it_index_rev)
                            #link #anonymous {
                                typ : ^TypeInfo = it
                                it_index : i64 = it_index
                                {
                                    slot_index = (slot_index - (((*typ).size + 7) / 8))
                                    *get_index(indices, it_index_rev) = slot_index
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            *wrapper = new NativeFunctionWrapper { function = func, function_type = ti, arg_slots = -slot_index, parameter_indices = indices }
            return wrapper
        }
        /*  */
        /* T = fn() */
        new(func: Fn(^Interpreter)) -> ^NativeFunctionWrapper {
            ti : ^TypeInfoFunction = cast(^TypeInfoFunction) (@type_info(fn()))
            raw : ^u8 = (mem).alloc_raw(cast ((@sizeof(NativeFunctionWrapper) + (((*ti).param_types).length * @sizeof(int)))), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            indices : []i64 = cast([]i64) (cast(^i64) ((util).pointer_add(raw, @sizeof(NativeFunctionWrapper))))
            (indices).length = ((*ti).param_types).length
            wrapper : ^NativeFunctionWrapper = cast(^NativeFunctionWrapper) (raw)
            slot_index : i64 = 0
            #macro {
                local arr : []^TypeInfo = (*ti).param_types
                
                local reverse : bool : true
                local by_ref : bool : false
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it_index_rev : i64 = (((arr).length - it_index) - 1)
                            it : ^TypeInfo = *get_index(arr, it_index_rev)
                            #link #anonymous {
                                typ : ^TypeInfo = it
                                it_index : i64 = it_index
                                {
                                    slot_index = (slot_index - (((*typ).size + 7) / 8))
                                    *get_index(indices, it_index_rev) = slot_index
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            *wrapper = new NativeFunctionWrapper { function = func, function_type = ti, arg_slots = -slot_index, parameter_indices = indices }
            return wrapper
        }
    
    
    slots_for_type(ti: ^TypeInfoFunction) -> i64 {
        slots : i64 = 0
        #macro {
            local arr : []^TypeInfo = (*ti).param_types
            
            local reverse : bool : true
            local by_ref : bool : false
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it_index_rev : i64 = (((arr).length - it_index) - 1)
                        it : ^TypeInfo = *get_index(arr, it_index_rev)
                        #link #anonymous {
                            typ : ^TypeInfo = it
                            it_index : i64 = it_index
                            {
                                slots = (slots + (((*typ).size + 7) / 8))
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return slots
    }
}

#file c.che
FILE :: struct { // size: 8, alignment: 8
    _Placeholder : ^void
}

__acrt_iob_func :: __acrt_iob_func(_: u32) -> ^FILE 

stdin : ^FILE = __acrt_iob_func(1)

stdout : ^FILE = __acrt_iob_func(1)

stderr : ^FILE = __acrt_iob_func(1)

getchar :: getchar() -> i32 

gets :: gets(string: ^char8) -> ^char8 

printf :: printf(format: ^char8) #varargs 

puts :: puts(str: ^char8) 

rand :: rand() -> i32 

scanf :: scanf(format: ^char8) -> i32 #varargs 

sprintf :: sprintf(buff: ^char8, f: ^char8) -> i32 #varargs 

srand :: srand(seed: u32) 

sscanf :: sscanf(str: ^char8, format: ^char8) -> i32 #varargs 

strcmp :: strcmp(a: ^char8, b: ^char8) -> i32 

strlen :: strlen(str: ^char8) -> u64 

strncmp :: strncmp(a: ^char8, b: ^char8, count: u64) -> i32 

strtod :: strtod(str: ^char8, endptr: ^^char8) -> f64 

strtol :: strtol(str: ^char8, endptr: ^^char8, base: i32) -> i64 

time :: time(timer: ^void) -> u32 

_fullpath :: _fullpath(absPath: ^char8, relPath: ^char8, maxLength: i64) -> ^char8 

alloca :: alloca(size: u64) -> ^void 

malloc :: malloc(size: u64) -> ^void 

realloc :: realloc(mem: ^void, size: u64) -> ^void 

free :: free(mem: ^void) 

memcpy :: memcpy(dest: ^void, src: ^void, size: u64) 

memmove :: memmove(dest: ^void, src: ^void, size: u64) 

memset :: memset(mem: ^void, value: i32, num: u64) -> ^void 

fflush :: fflush(file: ^FILE) 

errno_t :: i32 = i32

size_t :: u64 = u64

SEEK_SET : u0 : 0

SEEK_CUR : u0 : 1

SEEK_END : u0 : 2

clearerr_s :: clearerr_s(_Stream: ^FILE) -> i32 

fopen_s :: fopen_s(_Stream: ^^FILE, _FileName: ^char8, _Mode: ^char8) -> i32 

fopen :: fopen(_FileName: ^char8, _Mode: ^char8) -> ^FILE 

fread_s :: fread_s(_Buffer: ^void, _BufferSize: u64, _ElementSize: u64, _ElementCount: u64, _Stream: ^FILE) -> u64 

fread :: fread(ptr: ^void, size: u64, count: u64, stream: ^FILE) -> u64 

feof :: feof(stream: ^FILE) -> i32 

fseek :: fseek(_Stream: ^FILE, _Offset: i64, _Rel: i32) 

ftell :: ftell(_Stream: ^FILE) -> i64 

fclose :: fclose(_Stream: ^FILE) -> i32 

fwrite :: fwrite(buffer: ^void, size: u64, count: u64, _Stream: ^FILE) -> u64 

fprintf :: fprintf(_Stream: ^FILE, format: ^char8) #varargs 

system :: system(command: ^char8) -> i32 

exit :: exit(code: i32) -> void 

#file fmt.che
use import std.string

use import std.printable

use import std.util

C :  : import std.c

io :  : import std.io

FmtAlign :: struct { // size: 8, alignment: 8
    amount : i64
}

align :: align(amount: i64) -> FmtAlign {
    return new FmtAlign { amount = amount }
}

impl Printable for FmtAlign {
    print(self: &FmtAlign, str: &String, format: string) {
        loop {
            if !(str.get_length() < amount) then break else {}
            append_char(str, ' ')
        }
    }
}

parse_int :: parse_int(str: string) -> i64 {
    val : i64 = 0
    sign : i64 = 1
    if ((((str).bytes).length > 0) and (cast(char32) (*get_index(str, 0)) == '-')) {
        sign = -1
        str = get_range_from(str, new RangeFrom[i64] { start = 1 })
    } else {}
    #macro {
        local arr : string = str
        
        bytes : []u8 = (arr).bytes
        {
            it_index : i64 = 0
            loop {
                if !(it_index < (bytes).length) then break else {}
                @id((it, len)_22) : (char32, i32) = (Utf8).decode(get_range(bytes, new Range[i64] { start = it_index, end = (bytes).length }))
                it : char32 = @var(@id((it, len)_22))[0]
                len : i32 = @var(@id((it, len)_22))[1]
                #link #anonymous {
                    c : char32 = it
                    it_index : i64 = it_index
                    {
                        val = (val * 10)
                        val = (val + cast(i64) ((c - '0')))
                    }
                }
                it_index = (it_index + cast(i64) (len))
            }
        }
    }
    return (val * sign)
}

format_int : (buffer: &String, val: $T, _base: int = 10) : format_int(buffer: &String, val: $T, _base: int) {
    digit_to_char :  : (i: ) ->  {
        c :  = char(i)
        return if (i < 10) {
            (c + '`0')
        } else {
            ((c - char(10)) + '`0')
        }
    }
    base :  = T(_base)
    (len, sign) :  = if (val < 0) then (1, -1) else if (val == 0) then (1, 1) else (0, 1)
    {
        v :  = val
        loop {
            if !(v != 0) then break
            defer v = base
            len = 1
        }
    }
    (buffer).resize(((buffer).length + len))
    if (val == 0) {
        buffer[((buffer).length - 1)] = u8('`0')
    } else {
        i :  = ((buffer).length - 1)
        loop {
            if !(val != 0) then break
            defer i = 1
            lastDigit :  = ((val % base) * sign)
            val = (val / base)
            buffer[i] = u8(digit_to_char(lastDigit))
        }
        if (sign < 0) {
            buffer[i] = u8('`0')
            i = 1
        }
    }
}
// Polymorphic instances for format_int(buffer: &String, val: $T, _base: int)
    /* T = (type, i8) */
    /*  */
    format_int(buffer: &String, val: i8, _base: i64 = 10) {
        digit_to_char : (i: $T) -> char : digit_to_char(i: $T) -> char {
            c :  = char(i)
            return if (i < 10) {
                (c + '`0')
            } else {
                ((c - char(10)) + '`0')
            }
        }
        // Polymorphic instances for digit_to_char(i: $T) -> char
            /* T = (type, i8) */
            /*  */
            digit_to_char(i: i8) -> char32 {
                c : char32 = cast(char32) (i)
                return if (i < 10) {
                    (c + '0')
                } else {
                    ((c - cast(char32) (10)) + 'A')
                }
            }
        
        base : i8 = cast(i8) (_base)
        @id((len, sign)_482) : (i64, i8) = if (val < 0) then (1, -1) else if (val == 0) then (1, 1) else (0, 1)
        len : i64 = @var(@id((len, sign)_482))[0]
        sign : i8 = @var(@id((len, sign)_482))[1]
        {
            v : i8 = val
            loop {
                if !(v != 0) then break else {}
                defer v = (v / base)
                len = (len + 1)
                v = (v / base)
            }
        }
        buffer.resize(((*buffer).length + len))
        if (val == 0) {
            set_char_at(&*buffer, ((*buffer).length - 1), cast(u8) ('0'))
        } else {
            i : i64 = ((*buffer).length - 1)
            loop {
                if !(val != 0) then break else {}
                defer i = (i - 1)
                lastDigit : i8 = ((val % base) * sign)
                val = (val / base)
                set_char_at(&*buffer, i, cast(u8) (digit_to_char(lastDigit)))
                i = (i - 1)
            }
            if (sign < 0) {
                set_char_at(&*buffer, i, cast(u8) ('-'))
                i = (i - 1)
            } else {}
        }
    }
    /* T = (type, i16) */
    /*  */
    format_int(buffer: &String, val: i16, _base: i64 = 10) {
        digit_to_char : (i: $T) -> char : digit_to_char(i: $T) -> char {
            c :  = char(i)
            return if (i < 10) {
                (c + '`0')
            } else {
                ((c - char(10)) + '`0')
            }
        }
        // Polymorphic instances for digit_to_char(i: $T) -> char
            /* T = (type, i16) */
            /*  */
            digit_to_char(i: i16) -> char32 {
                c : char32 = cast(char32) (i)
                return if (i < 10) {
                    (c + '0')
                } else {
                    ((c - cast(char32) (10)) + 'A')
                }
            }
        
        base : i16 = cast(i16) (_base)
        @id((len, sign)_485) : (i64, i16) = if (val < 0) then (1, -1) else if (val == 0) then (1, 1) else (0, 1)
        len : i64 = @var(@id((len, sign)_485))[0]
        sign : i16 = @var(@id((len, sign)_485))[1]
        {
            v : i16 = val
            loop {
                if !(v != 0) then break else {}
                defer v = (v / base)
                len = (len + 1)
                v = (v / base)
            }
        }
        buffer.resize(((*buffer).length + len))
        if (val == 0) {
            set_char_at(&*buffer, ((*buffer).length - 1), cast(u8) ('0'))
        } else {
            i : i64 = ((*buffer).length - 1)
            loop {
                if !(val != 0) then break else {}
                defer i = (i - 1)
                lastDigit : i16 = ((val % base) * sign)
                val = (val / base)
                set_char_at(&*buffer, i, cast(u8) (digit_to_char(lastDigit)))
                i = (i - 1)
            }
            if (sign < 0) {
                set_char_at(&*buffer, i, cast(u8) ('-'))
                i = (i - 1)
            } else {}
        }
    }
    /* T = (type, i32) */
    /*  */
    format_int(buffer: &String, val: i32, _base: i64 = 10) {
        digit_to_char : (i: $T) -> char : digit_to_char(i: $T) -> char {
            c :  = char(i)
            return if (i < 10) {
                (c + '`0')
            } else {
                ((c - char(10)) + '`0')
            }
        }
        // Polymorphic instances for digit_to_char(i: $T) -> char
            /* T = (type, i32) */
            /*  */
            digit_to_char(i: i32) -> char32 {
                c : char32 = cast(char32) (i)
                return if (i < 10) {
                    (c + '0')
                } else {
                    ((c - cast(char32) (10)) + 'A')
                }
            }
        
        base : i32 = cast(i32) (_base)
        @id((len, sign)_488) : (i64, i32) = if (val < 0) then (1, -1) else if (val == 0) then (1, 1) else (0, 1)
        len : i64 = @var(@id((len, sign)_488))[0]
        sign : i32 = @var(@id((len, sign)_488))[1]
        {
            v : i32 = val
            loop {
                if !(v != 0) then break else {}
                defer v = (v / base)
                len = (len + 1)
                v = (v / base)
            }
        }
        buffer.resize(((*buffer).length + len))
        if (val == 0) {
            set_char_at(&*buffer, ((*buffer).length - 1), cast(u8) ('0'))
        } else {
            i : i64 = ((*buffer).length - 1)
            loop {
                if !(val != 0) then break else {}
                defer i = (i - 1)
                lastDigit : i32 = ((val % base) * sign)
                val = (val / base)
                set_char_at(&*buffer, i, cast(u8) (digit_to_char(lastDigit)))
                i = (i - 1)
            }
            if (sign < 0) {
                set_char_at(&*buffer, i, cast(u8) ('-'))
                i = (i - 1)
            } else {}
        }
    }
    /* T = (type, i64) */
    /*  */
    format_int(buffer: &String, val: i64, _base: i64 = 10) {
        digit_to_char : (i: $T) -> char : digit_to_char(i: $T) -> char {
            c :  = char(i)
            return if (i < 10) {
                (c + '`0')
            } else {
                ((c - char(10)) + '`0')
            }
        }
        // Polymorphic instances for digit_to_char(i: $T) -> char
            /* T = (type, i64) */
            /*  */
            digit_to_char(i: i64) -> char32 {
                c : char32 = cast(char32) (i)
                return if (i < 10) {
                    (c + '0')
                } else {
                    ((c - cast(char32) (10)) + 'A')
                }
            }
        
        base : i64 = _base
        @id((len, sign)_491) : (i64, i64) = if (val < 0) then (1, -1) else if (val == 0) then (1, 1) else (0, 1)
        len : i64 = @var(@id((len, sign)_491))[0]
        sign : i64 = @var(@id((len, sign)_491))[1]
        {
            v : i64 = val
            loop {
                if !(v != 0) then break else {}
                defer v = (v / base)
                len = (len + 1)
                v = (v / base)
            }
        }
        buffer.resize(((*buffer).length + len))
        if (val == 0) {
            set_char_at(&*buffer, ((*buffer).length - 1), cast(u8) ('0'))
        } else {
            i : i64 = ((*buffer).length - 1)
            loop {
                if !(val != 0) then break else {}
                defer i = (i - 1)
                lastDigit : i64 = ((val % base) * sign)
                val = (val / base)
                set_char_at(&*buffer, i, cast(u8) (digit_to_char(lastDigit)))
                i = (i - 1)
            }
            if (sign < 0) {
                set_char_at(&*buffer, i, cast(u8) ('-'))
                i = (i - 1)
            } else {}
        }
    }
    /* T = (type, u8) */
    /*  */
    format_int(buffer: &String, val: u8, _base: i64 = 10) {
        digit_to_char : (i: $T) -> char : digit_to_char(i: $T) -> char {
            c :  = char(i)
            return if (i < 10) {
                (c + '`0')
            } else {
                ((c - char(10)) + '`0')
            }
        }
        // Polymorphic instances for digit_to_char(i: $T) -> char
            /* T = (type, u8) */
            /*  */
            digit_to_char(i: u8) -> char32 {
                c : char32 = cast(char32) (i)
                return if (i < 10) {
                    (c + '0')
                } else {
                    ((c - cast(char32) (10)) + 'A')
                }
            }
        
        base : u8 = cast(u8) (_base)
        @id((len, sign)_494) : (i64, u8) = if (val < 0) then (1, -1) else if (val == 0) then (1, 1) else (0, 1)
        len : i64 = @var(@id((len, sign)_494))[0]
        sign : u8 = @var(@id((len, sign)_494))[1]
        {
            v : u8 = val
            loop {
                if !(v != 0) then break else {}
                defer v = (v / base)
                len = (len + 1)
                v = (v / base)
            }
        }
        buffer.resize(((*buffer).length + len))
        if (val == 0) {
            set_char_at(&*buffer, ((*buffer).length - 1), cast(u8) ('0'))
        } else {
            i : i64 = ((*buffer).length - 1)
            loop {
                if !(val != 0) then break else {}
                defer i = (i - 1)
                lastDigit : u8 = ((val % base) * sign)
                val = (val / base)
                set_char_at(&*buffer, i, cast(u8) (digit_to_char(lastDigit)))
                i = (i - 1)
            }
            if (sign < 0) {
                set_char_at(&*buffer, i, cast(u8) ('-'))
                i = (i - 1)
            } else {}
        }
    }
    /* T = (type, u16) */
    /*  */
    format_int(buffer: &String, val: u16, _base: i64 = 10) {
        digit_to_char : (i: $T) -> char : digit_to_char(i: $T) -> char {
            c :  = char(i)
            return if (i < 10) {
                (c + '`0')
            } else {
                ((c - char(10)) + '`0')
            }
        }
        // Polymorphic instances for digit_to_char(i: $T) -> char
            /* T = (type, u16) */
            /*  */
            digit_to_char(i: u16) -> char32 {
                c : char32 = cast(char32) (i)
                return if (i < 10) {
                    (c + '0')
                } else {
                    ((c - cast(char32) (10)) + 'A')
                }
            }
        
        base : u16 = cast(u16) (_base)
        @id((len, sign)_497) : (i64, u16) = if (val < 0) then (1, -1) else if (val == 0) then (1, 1) else (0, 1)
        len : i64 = @var(@id((len, sign)_497))[0]
        sign : u16 = @var(@id((len, sign)_497))[1]
        {
            v : u16 = val
            loop {
                if !(v != 0) then break else {}
                defer v = (v / base)
                len = (len + 1)
                v = (v / base)
            }
        }
        buffer.resize(((*buffer).length + len))
        if (val == 0) {
            set_char_at(&*buffer, ((*buffer).length - 1), cast(u8) ('0'))
        } else {
            i : i64 = ((*buffer).length - 1)
            loop {
                if !(val != 0) then break else {}
                defer i = (i - 1)
                lastDigit : u16 = ((val % base) * sign)
                val = (val / base)
                set_char_at(&*buffer, i, cast(u8) (digit_to_char(lastDigit)))
                i = (i - 1)
            }
            if (sign < 0) {
                set_char_at(&*buffer, i, cast(u8) ('-'))
                i = (i - 1)
            } else {}
        }
    }
    /* T = (type, u32) */
    /*  */
    format_int(buffer: &String, val: u32, _base: i64 = 10) {
        digit_to_char : (i: $T) -> char : digit_to_char(i: $T) -> char {
            c :  = char(i)
            return if (i < 10) {
                (c + '`0')
            } else {
                ((c - char(10)) + '`0')
            }
        }
        // Polymorphic instances for digit_to_char(i: $T) -> char
            /* T = (type, u32) */
            /*  */
            digit_to_char(i: u32) -> char32 {
                c : char32 = cast(char32) (i)
                return if (i < 10) {
                    (c + '0')
                } else {
                    ((c - cast(char32) (10)) + 'A')
                }
            }
        
        base : u32 = cast(u32) (_base)
        @id((len, sign)_500) : (i64, u32) = if (val < 0) then (1, -1) else if (val == 0) then (1, 1) else (0, 1)
        len : i64 = @var(@id((len, sign)_500))[0]
        sign : u32 = @var(@id((len, sign)_500))[1]
        {
            v : u32 = val
            loop {
                if !(v != 0) then break else {}
                defer v = (v / base)
                len = (len + 1)
                v = (v / base)
            }
        }
        buffer.resize(((*buffer).length + len))
        if (val == 0) {
            set_char_at(&*buffer, ((*buffer).length - 1), cast(u8) ('0'))
        } else {
            i : i64 = ((*buffer).length - 1)
            loop {
                if !(val != 0) then break else {}
                defer i = (i - 1)
                lastDigit : u32 = ((val % base) * sign)
                val = (val / base)
                set_char_at(&*buffer, i, cast(u8) (digit_to_char(lastDigit)))
                i = (i - 1)
            }
            if (sign < 0) {
                set_char_at(&*buffer, i, cast(u8) ('-'))
                i = (i - 1)
            } else {}
        }
    }
    /* T = (type, u64) */
    /*  */
    format_int(buffer: &String, val: u64, _base: i64 = 10) {
        digit_to_char : (i: $T) -> char : digit_to_char(i: $T) -> char {
            c :  = char(i)
            return if (i < 10) {
                (c + '`0')
            } else {
                ((c - char(10)) + '`0')
            }
        }
        // Polymorphic instances for digit_to_char(i: $T) -> char
            /* T = (type, u64) */
            /*  */
            digit_to_char(i: u64) -> char32 {
                c : char32 = cast(char32) (i)
                return if (i < 10) {
                    (c + '0')
                } else {
                    ((c - cast(char32) (10)) + 'A')
                }
            }
        
        base : u64 = cast(u64) (_base)
        @id((len, sign)_503) : (i64, u64) = if (val < 0) then (1, -1) else if (val == 0) then (1, 1) else (0, 1)
        len : i64 = @var(@id((len, sign)_503))[0]
        sign : u64 = @var(@id((len, sign)_503))[1]
        {
            v : u64 = val
            loop {
                if !(v != 0) then break else {}
                defer v = (v / base)
                len = (len + 1)
                v = (v / base)
            }
        }
        buffer.resize(((*buffer).length + len))
        if (val == 0) {
            set_char_at(&*buffer, ((*buffer).length - 1), cast(u8) ('0'))
        } else {
            i : i64 = ((*buffer).length - 1)
            loop {
                if !(val != 0) then break else {}
                defer i = (i - 1)
                lastDigit : u64 = ((val % base) * sign)
                val = (val / base)
                set_char_at(&*buffer, i, cast(u8) (digit_to_char(lastDigit)))
                i = (i - 1)
            }
            if (sign < 0) {
                set_char_at(&*buffer, i, cast(u8) ('-'))
                i = (i - 1)
            } else {}
        }
    }


format_any :: format_any(arg: ^any) -> String {
    return format("{}", cast([]^any) ([arg]))
}

format_into :: format_into(result: &String, text: string, args: []^any = cast([]^any) ([])) {
    State :: enum<i64> { // size: 0, alignment: 1
        Text = 0
        Format = 1
        Escape = 2
    }
    use State
    formatSpecifier : String = {
        len : u0 : 64
        mem : []u8 = @alloca(u8, len)
        @tempvar_18((String).from_raw_ptr((mem).data, len))
    }
    len : i64 = ((text).bytes).length
    argIndex : i64 = 0
    state : State = State.Text
    #macro {
        local arr : string = text
        
        bytes : []u8 = (arr).bytes
        {
            it_index : i64 = 0
            loop {
                if !(it_index < (bytes).length) then break else {}
                @id((it, len)_23) : (char32, i32) = (Utf8).decode(get_range(bytes, new Range[i64] { start = it_index, end = (bytes).length }))
                it : char32 = @var(@id((it, len)_23))[0]
                len : i32 = @var(@id((it, len)_23))[1]
                #link #anonymous {
                    c : char32 = it
                    it_index : i64 = it_index
                    {
                        match @tempvar_17(state) {
                            State.Text -> {
                                if (c == '``') {
                                    state = State.Escape
                                } else if (c == '{') {
                                    state = State.Format
                                } else {
                                    append_char(result, c)
                                }
                            }
                            State.Escape -> {
                                append_char(result, c)
                                state = State.Text
                            }
                            State.Format -> {
                                if (c == '}') {
                                    state = State.Text
                                    value : ^void = @ptr_of_any(get_index(args, argIndex))
                                    typ : ^TypeInfo = @type_info_of_any(get_index(args, argIndex))
                                    formatArg : string = ""
                                    colon : i64 = &formatSpecifier.index_of(':')
                                    if (colon >= 1) {
                                        argIndex = parse_int(&formatSpecifier.sliceL(colon))
                                    } else if ((colon == -1) and ((formatSpecifier).length > 0)) {
                                        argIndex = parse_int(&formatSpecifier.slice())
                                    } else {}
                                    if (colon != -1) {
                                        formatArg = &formatSpecifier.sliceF((colon + 1))
                                    } else {}
                                    if (argIndex >= (args).length) {
                                        (C).puts("error")
                                    } else {}
                                    @assert(((argIndex >= 0) and (argIndex < (args).length)))
                                    if streq(formatArg, "?") {
                                        format_any_into_string(result, value, typ, "", false)
                                    } else {
                                        format_any_into_string(result, value, typ, formatArg, true)
                                    }
                                    argIndex = (argIndex + 1)
                                    (formatSpecifier).length = 0
                                } else {
                                    append_char(&formatSpecifier, c)
                                }
                            }
                        }
                    }
                }
                it_index = (it_index + cast(i64) (len))
            }
        }
    }
    @destruct(formatSpecifier)
}

format :: format(text: string, args: []^any = cast([]^any) ([])) -> String {
    result : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    format_into(&result, text, args)
    return result
}

format_any_into_string :: format_any_into_string(result: &String, data: ^void, typ: ^TypeInfo, format: string, use_printable_if_possible: bool) {
    @assert((data != null))
    @assert((cast(^void) (typ) != null))
    if use_printable_if_possible {
        trait_func : fn(^void, &String, string) = &*typ.get_trait_function("print")
        if (trait_func != null) {
            trait_func(data, result, format)
            return
        } else {}
    } else {}
    match @tempvar_19(&*typ) {
        TypeInfoString(_) -> {
            ptr : ^string = cast(^string) (data)
            result.append_string(*ptr)
        }
        TypeInfoInt($ti) -> {
            base : i64 = if streq("b", format) then 2 else if streq("x", format) then 16 else 10
            match @tempvar_22(((*ti).size, (*ti).signed)) {
                (1, true) -> format_int(result, *cast(^i8) (data), base)
                (2, true) -> format_int(result, *cast(^i16) (data), base)
                (4, true) -> format_int(result, *cast(^i32) (data), base)
                (8, true) -> format_int(result, *cast(^i64) (data), base)
                (1, false) -> format_int(result, *cast(^u8) (data), base)
                (2, false) -> format_int(result, *cast(^u16) (data), base)
                (4, false) -> format_int(result, *cast(^u32) (data), base)
                (8, false) -> format_int(result, *cast(^u64) (data), base)
            }
        }
        TypeInfoFloat(_) -> {
            if ((*typ).size == 4) {
                ptr : ^f32 = cast(^f32) (data)
                result.appendf("{}", *ptr)
            } else if ((*typ).size == 8) {
                ptr : ^f64 = cast(^f64) (data)
                result.appendf("{}", *ptr)
            } else {
                result.appendf("<float: invalid size {}>", (*typ).size)
                @assert(false)
            }
        }
        TypeInfoBool(_) -> {
            ptr : ^bool = cast(^bool) (data)
            if *ptr then result.append_string("true") else result.append_string("false")
        }
        TypeInfoChar(_) -> {
            ptr : ^char32 = cast(^char32) (data)
            result.appendf("'{}'", *ptr)
        }
        TypeInfoPointer($ti) -> {
            ptr : ^^void = cast(^^void) (data)
            result.appendf("0x{:x}", cast(i64) (*ptr))
        }
        TypeInfoSlice($ti) -> {
            ptr : []void = *cast(^[]void) (data)
            append_string(result, "[")
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = (ptr).length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_24) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_24))[0]
                    it_index : i64 = @var(@id((it, it_index)_24))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (i > 0) {
                                    append_string(result, ", ")
                                } else {}
                                if (i >= 100) {
                                    append_string(result, "...")
                                    #anonymous {
                                        it_index = (it_index + 1)
                                        it = (it + inc)
                                    };
                                    break
                                } else {}
                                elem : ^void = pointer_add((ptr).data, (i * (*(*ti).target).size))
                                format_any_into_string(result, elem, (*ti).target, format, use_printable_if_possible)
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            append_string(result, "]")
        }
        TypeInfoArray($ti) -> {
            ptr : ^void = data
            append_string(result, "[")
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = (*ti).count }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_26) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_26))[0]
                    it_index : i64 = @var(@id((it, it_index)_26))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                if (i > 0) {
                                    append_string(result, ", ")
                                } else {}
                                if (i >= 100) {
                                    append_string(result, "...")
                                    #anonymous {
                                        it_index = (it_index + 1)
                                        it = (it + inc)
                                    };
                                    break
                                } else {}
                                elem : ^void = pointer_add(ptr, (i * (*(*ti).target).size))
                                format_any_into_string(result, elem, (*ti).target, format, use_printable_if_possible)
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            append_string(result, "]")
        }
        TypeInfoStruct($tstruct) -> {
            ptr : ^void = data
            append_string(result, (*tstruct).name)
            append_string(result, "(")
            if (cast(^void) (((*tstruct).members).data) != null) {
                comma : bool = false
                #macro {
                    local r : Range[i64] = new Range[i64] { start = 0, end = ((*tstruct).members).length }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_28) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_28))[0]
                        it_index : i64 = @var(@id((it, it_index)_28))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                i : i64 = it
                                it_index : i64 = it_index
                                {
                                    member_info : &TypeInfoStructMember = get_index((*tstruct).members, i)
                                    if member_info.has_attribute("fmt_ignore") then #anonymous {
                                        it_index = (it_index + 1)
                                        it = (it + inc)
                                    };
                                    continue else {}
                                    if comma {
                                        append_string(result, ", ")
                                    } else {}
                                    comma = true
                                    member_ptr : ^void = pointer_add(ptr, (*member_info).offset)
                                    append_string(result, (*member_info).name)
                                    append_string(result, " = ")
                                    format_any_into_string(result, member_ptr, (*member_info).typ, format, use_printable_if_possible)
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
            } else {}
            append_string(result, ")")
        }
        TypeInfoEnum($tenum) -> {
            ptr : ^void = data
            append_string(result, (*tenum).name)
            append_char(result, '.')
            tag : i64 = match @tempvar_31((*(*tenum).tag_type).size) {
                1 -> cast(i64) (*cast(^u8) (ptr))
                2 -> cast(i64) (*cast(^u16) (ptr))
                4 -> cast(i64) (*cast(^u32) (ptr))
                8 -> cast(i64) (*cast(^u64) (ptr))
                $_ -> {
                    @panic("Unsupported tag size")
                    0
                }
            }
            #macro {
                local arr : []TypeInfoEnumMember = (*tenum).members
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &TypeInfoEnumMember = get_index(arr, it_index)
                            #link #anonymous {
                                mem : &TypeInfoEnumMember = it
                                it_index : i64 = it_index
                                {
                                    if ((*mem).tag == tag) {
                                        append_string(result, (*mem).name)
                                        if (cast(^void) ((*mem).typ) != null) {
                                            mem_val_ptr : ^void = pointer_add(ptr, (*(*tenum).tag_type).size)
                                            append_string(result, "(")
                                            format_any_into_string(result, mem_val_ptr, (*mem).typ, format, use_printable_if_possible)
                                            append_string(result, ")")
                                        } else {}
                                    } else {}
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
        }
        TypeInfoTuple($ti) -> {
            ptr : ^void = data
            append_string(result, "(")
            if (cast(^void) (((*ti).members).data) != null) {
                #macro {
                    local arr : []TypeInfoTupleMember = (*ti).members
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &TypeInfoTupleMember = get_index(arr, it_index)
                                #link #anonymous {
                                    member_info : &TypeInfoTupleMember = it
                                    it_index : i64 = it_index
                                    {
                                        if (it_index > 0) {
                                            append_string(result, ", ")
                                        } else {}
                                        member_ptr : ^void = pointer_add(ptr, (*member_info).offset)
                                        format_any_into_string(result, member_ptr, (*member_info).typ, format, use_printable_if_possible)
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            } else {}
            append_string(result, ")")
        }
        TypeInfoFunction($ti) -> {
            ptr : ^^void = cast(^^void) (data)
            result.appendf("fn 0x{:x}", cast(i64) (*ptr))
        }
        $_ -> {
            format_into(result, "<unknown {}>", cast([]^any) ([cast(^any) (typ)]))
        }
    }
}

#file fs.che
import std.os.windows

use import std.os.windows_functions

use import std.os.windows_constants

use import std.os.windows_types

use import std.array

use import std.mem.allocator

use import std.string

use import std.util

C :  : import std.c

io :  : import std.io

FsError :: enum<i64> { // size: 0, alignment: 1
    Unknown = 0
    AlreadyExists = 1
    PathNotFound = 2
    InvalidUtf8 = 3
}

create_directory :: create_directory(path: string) -> Result[(), FsError] {
    #anonymous {
        full_path : String = #macro {
            
            
            @tempvar_37(match @tempvar_34(get_full_path(path)) {
                Result[String, ()].Ok($val) -> val
                Result[String, ()].Err($err) -> #link #anonymous {
                    return Result[(), FsError].Err(FsError.Unknown)
                }
            })
        }
        path_long : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        append_string(&path_long, "\\?\")
        append(&path_long, &full_path)
        full_path_utf16 : Array[u16] = #macro {
            
            
            @tempvar_38(match @tempvar_35(&path_long.slice().to_utf16()) {
                Result[Array[u16], ()].Ok($val) -> val
                Result[Array[u16], ()].Err($err) -> #link #anonymous {
                    @destruct(path_long);
                    @destruct(full_path);
                    return Result[(), FsError].Err(FsError.Unknown)
                }
            })
        }
        @destruct(full_path_utf16);
        @destruct(path_long);
        @destruct(full_path);
        return if (CreateDirectoryW((full_path_utf16).data, null) != 0) then Result[(), FsError].Ok(()) else match @tempvar_36(GetLastError()) {
            WindowsErrorCode.ERROR_ALREADY_EXISTS -> Result[(), FsError].Err(FsError.AlreadyExists)
            WindowsErrorCode.ERROR_PATH_NOT_FOUND -> Result[(), FsError].Err(FsError.PathNotFound)
            $_ -> Result[(), FsError].Err(FsError.Unknown)
        }
    }
    #anonymous {}
}

write_file :: write_file(path: string, content: string) -> Result[(), FsError] {
    #anonymous {
        path_utf16 : Array[u16] = #macro {
            
            
            @tempvar_40(match @tempvar_39(path.to_utf16()) {
                Result[Array[u16], ()].Ok($val) -> val
                Result[Array[u16], ()].Err($err) -> #link #anonymous {
                    return Result[(), FsError].Err(FsError.InvalidUtf8)
                }
            })
        }
        handle : ^void = CreateFileW(&path_utf16.get_raw(), GENERIC_WRITE, FILE_SHARE_WRITE, null, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, null)
        if (cast(i64) (handle) == -1) {
            @destruct(path_utf16);
            return Result[(), FsError].Err(FsError.Unknown)
        } else {}
        bytes_written : u32 = 0
        if (WriteFile(handle, cast(^void) (((content).bytes).data), cast (((content).bytes).length), ^bytes_written, null) == 0) {
            @destruct(path_utf16);
            return Result[(), FsError].Err(FsError.Unknown)
        } else {}
        if (CloseHandle(handle) == 0) {
            @destruct(path_utf16);
            return Result[(), FsError].Err(FsError.Unknown)
        } else {}
        @destruct(path_utf16);
        return Result[(), FsError].Ok(())
    }
    #anonymous {}
}

write_file_binary :: write_file_binary(path: string, content: []u8) -> Result[(), FsError] {
    #anonymous {
        path_utf16 : Array[u16] = #macro {
            
            
            @tempvar_42(match @tempvar_41(path.to_utf16()) {
                Result[Array[u16], ()].Ok($val) -> val
                Result[Array[u16], ()].Err($err) -> #link #anonymous {
                    return Result[(), FsError].Err(FsError.InvalidUtf8)
                }
            })
        }
        handle : ^void = CreateFileW(&path_utf16.get_raw(), GENERIC_WRITE, FILE_SHARE_WRITE, null, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, null)
        if (cast(i64) (handle) == -1) {
            @destruct(path_utf16);
            return Result[(), FsError].Err(FsError.Unknown)
        } else {}
        bytes_written : u32 = 0
        if (WriteFile(handle, cast(^void) ((content).data), cast ((content).length), ^bytes_written, null) == 0) {
            @destruct(path_utf16);
            return Result[(), FsError].Err(FsError.Unknown)
        } else {}
        if (CloseHandle(handle) == 0) {
            @destruct(path_utf16);
            return Result[(), FsError].Err(FsError.Unknown)
        } else {}
        @destruct(path_utf16);
        return Result[(), FsError].Ok(())
    }
    #anonymous {}
}

append_file :: append_file(path: string, content: string) -> Result[(), FsError] {
    #anonymous {
        path_utf16 : Array[u16] = #macro {
            
            
            @tempvar_44(match @tempvar_43(path.to_utf16()) {
                Result[Array[u16], ()].Ok($val) -> val
                Result[Array[u16], ()].Err($err) -> #link #anonymous {
                    return Result[(), FsError].Err(FsError.InvalidUtf8)
                }
            })
        }
        handle : ^void = CreateFileW(&path_utf16.get_raw(), GENERIC_WRITE, FILE_SHARE_WRITE, null, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, null)
        if (cast(i64) (handle) == -1) {
            @destruct(path_utf16);
            return Result[(), FsError].Err(FsError.Unknown)
        } else {}
        SetFilePointerEx(handle, 0, null, FILE_END)
        bytes_written : u32 = 0
        if (WriteFile(handle, cast(^void) (((content).bytes).data), cast (((content).bytes).length), ^bytes_written, null) == 0) {
            @destruct(path_utf16);
            return Result[(), FsError].Err(FsError.Unknown)
        } else {}
        if (CloseHandle(handle) == 0) {
            @destruct(path_utf16);
            return Result[(), FsError].Err(FsError.Unknown)
        } else {}
        @destruct(path_utf16);
        return Result[(), FsError].Ok(())
    }
    #anonymous {}
}

read_file :: read_file(path: string) -> Result[String, FsError] {
    #anonymous {
        path_utf16 : Array[u16] = #macro {
            
            
            @tempvar_46(match @tempvar_45(path.to_utf16()) {
                Result[Array[u16], ()].Ok($val) -> val
                Result[Array[u16], ()].Err($err) -> #link #anonymous {
                    return Result[String, FsError].Err(FsError.InvalidUtf8)
                }
            })
        }
        handle : ^void = CreateFileW(&path_utf16.get_raw(), GENERIC_READ, FILE_SHARE_READ, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, null)
        if (cast(i64) (handle) == -1) {
            @destruct(path_utf16);
            return Result[String, FsError].Err(FsError.PathNotFound)
        } else {}
        size : i64 = 0
        if (GetFileSizeEx(handle, ^size) == 0) {
            @destruct(path_utf16);
            return Result[String, FsError].Err(FsError.Unknown)
        } else {}
        result : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &result.resize(size)
        bytesRead : u32 = 0
        if (ReadFile(handle, cast(^void) (&result.get_raw()), cast(u32) (size), ^bytesRead, null) == 0) {
            @destruct(result);
            @destruct(path_utf16);
            return Result[String, FsError].Err(FsError.Unknown)
        } else {}
        if (CloseHandle(handle) == 0) {
            @destruct(result);
            @destruct(path_utf16);
            return Result[String, FsError].Err(FsError.Unknown)
        } else {}
        @destruct(path_utf16);
        return Result[String, FsError].Ok(result)
    }
    #anonymous {}
}

read_file_binary :: read_file_binary(path: string) -> Result[Array[u8], FsError] {
    #anonymous {
        path_utf16 : Array[u16] = #macro {
            
            
            @tempvar_48(match @tempvar_47(path.to_utf16()) {
                Result[Array[u16], ()].Ok($val) -> val
                Result[Array[u16], ()].Err($err) -> #link #anonymous {
                    return Result[Array[u8], FsError].Err(FsError.InvalidUtf8)
                }
            })
        }
        handle : ^void = CreateFileW(&path_utf16.get_raw(), GENERIC_READ, FILE_SHARE_READ, null, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, null)
        if (cast(i64) (handle) == -1) {
            @destruct(path_utf16);
            return Result[Array[u8], FsError].Err(FsError.PathNotFound)
        } else {}
        size : i64 = 0
        if (GetFileSizeEx(handle, ^size) == 0) {
            @destruct(path_utf16);
            return Result[Array[u8], FsError].Err(FsError.Unknown)
        } else {}
        result : Array[u8] = (Array[u8]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &result.resize(size)
        bytesRead : u32 = 0
        if (ReadFile(handle, cast(^void) (&result.get_raw()), cast(u32) (size), ^bytesRead, null) == 0) {
            @destruct(result);
            @destruct(path_utf16);
            return Result[Array[u8], FsError].Err(FsError.Unknown)
        } else {}
        if (CloseHandle(handle) == 0) {
            @destruct(result);
            @destruct(path_utf16);
            return Result[Array[u8], FsError].Err(FsError.Unknown)
        } else {}
        @destruct(path_utf16);
        return Result[Array[u8], FsError].Ok(result)
    }
    #anonymous {}
}

get_full_path :: get_full_path(path: string) -> Result[String, ()] {
    #anonymous {
        path_utf16 : Array[u16] = #macro {
            
            @tempvar_52(match @tempvar_49(path.to_utf16()) {
                Result[Array[u16], ()].Ok($val) -> val
                Result[Array[u16], ()].Err($err) -> {
                    ReturnType :: (@function_type()).return_type = Result[String, ()]
                    return #anonymous {
                        TargetType :: (ReturnType).E = ()
                        ErrorType :: () = ()
                        @tempvar_51(#anonymous {
                            @tempvar_50(Result[String, ()].Err((()).into(&err)))
                        })
                    }
                }
            })
        }
        required_length : u32 = GetFullPathNameW(&path_utf16.get_raw(), 0, null, null)
        buffer : []u16 = alloc_n(cast(u64) (required_length), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        defer free_n(buffer, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        len : u32 = GetFullPathNameW(&path_utf16.get_raw(), required_length, cast ((buffer).data), null)
        if (len == 0) {
            free_n(buffer, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR));
            @destruct(path_utf16);
            return Result[String, ()].Err(())
        } else {}
        free_n(buffer, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR));
        @destruct(path_utf16);
        return (String).from_utf16(get_range_to(buffer, new RangeTo[i64] { end = cast(i64) (len) }))
    }
    #anonymous {}
}

expand_path :: expand_path(path: string) -> Result[String, ()] {
    #anonymous {
        path_utf16 : Array[u16] = #macro {
            
            @tempvar_56(match @tempvar_53(path.to_utf16()) {
                Result[Array[u16], ()].Ok($val) -> val
                Result[Array[u16], ()].Err($err) -> {
                    ReturnType :: (@function_type()).return_type = Result[String, ()]
                    return #anonymous {
                        TargetType :: (ReturnType).E = ()
                        ErrorType :: () = ()
                        @tempvar_55(#anonymous {
                            @tempvar_54(Result[String, ()].Err((()).into(&err)))
                        })
                    }
                }
            })
        }
        required_length : u32 = GetFullPathNameW(&path_utf16.get_raw(), 0, null, null)
        buffer : []u16 = alloc_n(cast(u64) (required_length), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        defer free_n(buffer, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        len : u32 = GetFullPathNameW(&path_utf16.get_raw(), required_length, cast ((buffer).data), null)
        if (len == 0) {
            free_n(buffer, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR));
            @destruct(path_utf16);
            return Result[String, ()].Err(())
        } else {}
        free_n(buffer, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR));
        @destruct(path_utf16);
        return (String).from_utf16(get_range_to(buffer, new RangeTo[i64] { end = cast(i64) (len) }))
    }
    #anonymous {}
}

get_working_directory :: get_working_directory() -> Result[String, ()] {
    #anonymous {
        buff : [512]u16 = default
        length : u32 = GetCurrentDirectoryW(cast ((buff).length), (buff).data)
        return (String).from_utf16(get_range_to(&buff, new RangeTo[i64] { end = cast(i64) (length) }))
    }
    #anonymous {}
}

Path :: struct { // size: 0, alignment: 1
    
}

impl Path {
    get_containing_directory(path: string) -> string {
        index_slash : i64 = path.last_index_of('/')
        index_backslash : i64 = path.last_index_of('\')
        index : i64 = max(index_slash, index_backslash)
        if (index < 0) {
            return path
        } else {}
        return get_range_to(path, new RangeTo[i64] { end = index })
    }
    
    get_file_name(path: string) -> string {
        index_slash : i64 = path.last_index_of('/')
        index_backslash : i64 = path.last_index_of('\')
        index : i64 = max(index_slash, index_backslash)
        if (index < 0) {
            return path
        } else {}
        return get_range_from(path, new RangeFrom[i64] { start = (index + 1) })
    }
    
    concat(path1: string, path2: string) -> String {
        result : String = (String).with_capacity(((((path1).bytes).length + ((path2).bytes).length) + 1), cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        append_string(&result, path1)
        if (!path1.ends_with("/") and !path1.ends_with("\")) {
            append_string(&result, "/")
        } else {}
        append_string(&result, path2)
        return result
    }
    
    normalize(path: string) -> String {
        parts : Array[string] = (Array[string]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        starts_with_slash : bool = false
        start : i64 = 0
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = ((path).bytes).length }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_209) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_209))[0]
                it_index : i64 = @var(@id((it, it_index)_209))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            c : char32 = cast(char32) (*get_index((path).bytes, i))
                            if ((c == '/') and (i == 0)) {
                                starts_with_slash = true
                            } else {}
                            if ((c == '/') or (c == '\')) {
                                sub : string = get_range(path, new Range[i64] { start = start, end = i })
                                if strings_equal(sub, ".") {} else if (strings_equal(sub, "..") and (&parts.count() > 0)) {
                                    &parts.pop()
                                } else if (((sub).bytes).length > 0) {
                                    &parts.add(sub)
                                } else {}
                                start = (i + 1)
                            } else {}
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        if (start < ((path).bytes).length) {
            sub : string = get_range_from(path, new RangeFrom[i64] { start = start })
            if strings_equal(sub, ".") {} else if (strings_equal(sub, "..") and (&parts.count() > 0)) {
                &parts.pop()
            } else if (((sub).bytes).length > 0) {
                &parts.add(sub)
            } else {}
        } else {}
        result : String = (String).with_capacity(((path).bytes).length, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        if starts_with_slash {
            append_string(&result, "/")
        } else {}
        #macro {
            local arr : &Array[string] = &parts
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &string = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            p : &string = it
                            it_index : i64 = it_index
                            {
                                if (it_index > 0) {
                                    #anonymous {
                                        append_string(&result, "\")
                                    }
                                    #anonymous {}
                                } else {}
                                append_string(&result, *p)
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        @destruct(parts);
        return result
    }
    
    get_current_executable_path() -> Result[String, ()] {
        #anonymous {
            buff : [260]u16 = @dup(0u16, MAX_PATH)
            size : i64 = cast(i64) (GetModuleFileNameW(null, (buff).data, cast ((buff).length)))
            return (String).from_utf16(get_range_to(&buff, new RangeTo[i64] { end = size }))
        }
        #anonymous {}
    }
}

#file io.che
use import std.string

use import std.printable

C :  : import std.c

fmt :  : import std.fmt

use import std.os.windows

use import std.os.windows_functions

use import std.os.windows_constants

formatln :: formatln(format: ^any, args: []^any = cast([]^any) ([])) {
    format_string : String = (fmt).format_any(format)
    println((fmt).format(&format_string.slice(), args))
    @destruct(format_string)
}

format :: format(format: ^any, args: []^any = cast([]^any) ([])) {
    format_string : String = (fmt).format_any(format)
    print((fmt).format(&format_string.slice(), args))
    @destruct(format_string)
}

println : (v: $T) : println(v: $T) {
    s :  = (String).empty()
    (s).appendf("{}`n", v)
    print_string(&s)
}
// Polymorphic instances for println(v: $T)
    /* T = (type, String) */
    /*  */
    println(v: String) {
        s : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &s.appendf("{}`n", v)
        print_string(&s)
        @destruct(s)
    }
    /* T = (type, string) */
    /*  */
    println(v: string) {
        s : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &s.appendf("{}`n", v)
        print_string(&s)
        @destruct(s)
    }


print : (v: $T) : print(v: $T) {
    s :  = (String).empty()
    (s).appendf("{}", v)
    print_string(&s)
}
// Polymorphic instances for print(v: $T)
    /* T = (type, String) */
    /*  */
    print(v: String) {
        s : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &s.appendf("{}", v)
        print_string(&s)
        @destruct(s)
    }
    /* T = (type, string) */
    /*  */
    print(v: string) {
        s : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &s.appendf("{}", v)
        print_string(&s)
        @destruct(s)
    }
    /* T = (type, i64) */
    /*  */
    print(v: i64) {
        s : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &s.appendf("{}", v)
        print_string(&s)
        @destruct(s)
    }


printf : (format: string, args: $T) : printf(format: string, args: $T) {
    s :  = (String).empty()
    (s).appendf(format, args)
    print_string(&s)
}

printfln : (format: string, args: $T) : printfln(format: string, args: $T) {
    s :  = (String).empty()
    (s).appendf(format, args)
    s = '`0'
    print_string(&s)
}
// Polymorphic instances for printfln(format: string, args: $T)
    /* T = (type, string) */
    /*  */
    printfln(format: string, args: string) {
        s : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &s.appendf(format, args)
        append_char(&s, '`n')
        print_string(&s)
        @destruct(s)
    }
    /* T = (type, ()) */
    /*  */
    printfln(format: string, args: ()) {
        s : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &s.appendf(format, args)
        append_char(&s, '`n')
        print_string(&s)
        @destruct(s)
    }
    /* T = (type, i64) */
    /*  */
    printfln(format: string, args: i64) {
        s : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &s.appendf(format, args)
        append_char(&s, '`n')
        print_string(&s)
        @destruct(s)
    }
    /* T = (type, (i64, u64, i64)) */
    /*  */
    printfln(format: string, args: (i64, u64, i64)) {
        s : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &s.appendf(format, args)
        append_char(&s, '`n')
        print_string(&s)
        @destruct(s)
    }
    /* T = (type, (u64, u64)) */
    /*  */
    printfln(format: string, args: (u64, u64)) {
        s : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &s.appendf(format, args)
        append_char(&s, '`n')
        print_string(&s)
        @destruct(s)
    }
    /* T = (type, (i64, u64, i64)) */
    /*  */
    printfln(format: string, args: (i64, u64, i64)) {
        s : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &s.appendf(format, args)
        append_char(&s, '`n')
        print_string(&s)
        @destruct(s)
    }
    /* T = (type, (u64, u64)) */
    /*  */
    printfln(format: string, args: (u64, u64)) {
        s : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        &s.appendf(format, args)
        append_char(&s, '`n')
        print_string(&s)
        @destruct(s)
    }


ConsoleColor :: enum<i64> { // size: 0, alignment: 1
    Black = 0
    Red = 1
    Green = 2
    Blue = 4
    Bright = 8
    White = 7
}

set_console_color :: set_console_color(foreground: ConsoleColor, background: ConsoleColor) {
    #anonymous {
        fg : u16 = cast(u16) (foreground)
        bg : u16 = cast(u16) (background)
        attributes : u16 = 0u16
        if (@bin_and(fg, cast(u16) (ConsoleColor.Red)) != 0) {
            attributes = @bin_or(attributes, FOREGROUND_RED)
        } else {}
        if (@bin_and(fg, cast(u16) (ConsoleColor.Green)) != 0) {
            attributes = @bin_or(attributes, FOREGROUND_GREEN)
        } else {}
        if (@bin_and(fg, cast(u16) (ConsoleColor.Blue)) != 0) {
            attributes = @bin_or(attributes, FOREGROUND_BLUE)
        } else {}
        if (@bin_and(fg, cast(u16) (ConsoleColor.Bright)) != 0) {
            attributes = @bin_or(attributes, FOREGROUND_INTENSITY)
        } else {}
        if (@bin_and(bg, cast(u16) (ConsoleColor.Red)) != 0) {
            attributes = @bin_or(attributes, BACKGROUND_RED)
        } else {}
        if (@bin_and(bg, cast(u16) (ConsoleColor.Green)) != 0) {
            attributes = @bin_or(attributes, BACKGROUND_GREEN)
        } else {}
        if (@bin_and(bg, cast(u16) (ConsoleColor.Blue)) != 0) {
            attributes = @bin_or(attributes, BACKGROUND_BLUE)
        } else {}
        if (@bin_and(bg, cast(u16) (ConsoleColor.Bright)) != 0) {
            attributes = @bin_or(attributes, BACKGROUND_INTENSITY)
        } else {}
        SetConsoleTextAttribute(__std_out_handle, attributes)
    }
    #anonymous {}
}

set_console_foreground_color :: set_console_foreground_color(foreground: ConsoleColor) {
    #anonymous {
        fg : u16 = cast(u16) (foreground)
        attributes : u16 = 0u16
        if (@bin_and(fg, cast(u16) (ConsoleColor.Red)) != 0) {
            attributes = @bin_or(attributes, FOREGROUND_RED)
        } else {}
        if (@bin_and(fg, cast(u16) (ConsoleColor.Green)) != 0) {
            attributes = @bin_or(attributes, FOREGROUND_GREEN)
        } else {}
        if (@bin_and(fg, cast(u16) (ConsoleColor.Blue)) != 0) {
            attributes = @bin_or(attributes, FOREGROUND_BLUE)
        } else {}
        if (@bin_and(fg, cast(u16) (ConsoleColor.Bright)) != 0) {
            attributes = @bin_or(attributes, FOREGROUND_INTENSITY)
        } else {}
        SetConsoleTextAttribute(__std_out_handle, attributes)
    }
    #anonymous {}
}

print_string :: print_string(s: &String) {
    #anonymous {
        mode : u32 = 0u32
        if (GetConsoleMode(__std_out_handle, ^mode) == 0) {
            bytesWritten : u32 = 0u32
            WriteFile(__std_out_handle, cast (s.get_raw()), cast (s.get_length()), ^bytesWritten, null)
        } else {
            match @tempvar_57(s.slice().to_utf16()) {
                Result[Array[u16], ()].Ok($str) -> {
                    bytesWritten : u32 = 0u32
                    WriteConsoleW(__std_out_handle, cast (&str.get_raw()), cast (&str.get_length()), ^bytesWritten, null)
                };
                @destruct(str);
                Result[Array[u16], ()].Err -> {
                    @assert(false, "print_string failed")
                }
            }
        }
    }
    #anonymous {}
}

#file std_heap_allocator.che
use import std.mem.allocator

c :  : import std.c

StdHeapAllocator :: struct { // size: 4, alignment: 4
    _unused : i32 = 0
}

impl Allocator for StdHeapAllocator {
    allocate(self: &StdHeapAllocator, count: u64, elementSize: u64, alignment: u64) -> ^void {
        return (c).malloc((count * elementSize))
    }
    
    reallocate(self: &StdHeapAllocator, mem: ^void, count: u64, elementSize: u64, alignment: u64) -> ^void {
        return (c).realloc(mem, (count * elementSize))
    }
    
    free(self: &StdHeapAllocator, mem: ^void) {
        (c).free(mem)
    }
}

DEFAULT_STD_HEAP_ALLOCATOR : StdHeapAllocator = new StdHeapAllocator { _unused = 0 }

#file iterator.che
use import std.array

Iterator :: trait(T: type) {
    next :: f.Accept(this)
}
// Polymorphic instances for Iterator
    // T = i64
    trait {
        next :: f.Accept(this)
    }


impl(It: type, T: type) $It if It : Iterator[T] {
    
}
// Polymorphic instances for impl(It: type, T: type) $It if It : Iterator[T]
    // It = (type, RangeIterator), T = (type, i64)
    impl(It: type, T: type) RangeIterator {
        skip(self: &RangeIterator, count: i64) -> RangeIterator {
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = count }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_292) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_292))[0]
                    it_index : i64 = @var(@id((it, it_index)_292))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            it : i64 = it
                            it_index : i64 = it_index
                            {
                                self.next()
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            return *self
        }
        
        take(self: &RangeIterator, count: i64) -> TakeIterator[i64] {
            return new TakeIterator[i64] { it = cast(^Iterator[i64]) (^*self), count = count }
        }
        
        map(self: &Self, mapFunc: fn(i64) -> $X) -> MapIterator[i64, X] {
            return MapIterator[T, X](^*self, mapFunc)
        }
        
        foreach(self: &RangeIterator, func: fn(i64)) {
            loop {
                if !true then break else {}
                match @tempvar_723(self.next()) {
                    Option[i64].Some($v) -> func(v)
                    Option[i64].None -> {
                        break
                    }
                }
            }
        }
        
        to_array(self: &RangeIterator) -> Array[i64] {
            a : Array[i64] = (Array[i64]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            loop {
                if !match @tempvar_724(self.next()) {
                    Option[i64].Some($v) -> {
                        &a.add(v)
                        true
                    }
                    Option[i64].None -> false
                } then break else {}
            }
            return a
        }
    }


TakeIterator :: struct(T: type) {
    it : 
    count : 
}
// Polymorphic instances for struct(T: type)
    // T = i64
    struct { // size: 24, alignment: 8
        it : ^Iterator[i64]
        count : i64
    }


impl(T: type) Iterator[$T] for Cheez.Types.Abstract.GenericStructType {
    
}

MapIterator :: struct(T: type, X: type) {
    it : 
    mapFunc : 
}

impl(T: type, X: type) Iterator[$X] for Cheez.Types.Abstract.GenericStructType {
    
}

RangeIterator :: struct { // size: 16, alignment: 8
    from : i64
    to : i64
}

impl Iterator[i64] for RangeIterator {
    next(self: &RangeIterator) -> Option[i64] {
        if (from > to) {
            return Option[i64].None
        } else {}
        n : i64 = from
        from = (from + 1)
        return Option[i64].Some(n)
    }
}

range :: range(start: i64, end: i64) -> RangeIterator {
    return new RangeIterator { from = start, to = end }
}

#file printable.che
use import std.array

use import std.hash_table

use import std.string

use import std.box

use import std.math

C :  : import std.c

io :  : import std.io

fmt :  : import std.fmt

Printable :: trait {
    print :: f.Accept(this)
}

impl Printable for () {
    print(self: &(), str: &String, format: string) {
        append_string(str, "()")
    }
}

impl Printable for string {
    print(self: &string, str: &String, format: string) {
        str.append_string(*self)
    }
}

impl Printable for char8 {
    print(self: &char8, str: &String, format: string) {
        str.append_char(cast (*self))
    }
}

impl Printable for char16 {
    print(self: &char16, str: &String, format: string) {
        str.append_char(cast (*self))
    }
}

impl Printable for char32 {
    print(self: &char32, str: &String, format: string) {
        str.append_char(*self)
    }
}

impl Printable for f32 {
    print(self: &f32, str: &String, format: string) {
        buff : []char8 = @alloca(char8, 128)
        (buff).length = cast(i64) ((C).sprintf((buff).data, "%g", cast(f64) (*self)))
        str.append_cstring((buff).data)
    }
}

impl Printable for f64 {
    print(self: &f64, str: &String, format: string) {
        buff : []char8 = @alloca(char8, 128)
        (buff).length = cast(i64) ((C).sprintf((buff).data, "%g", *self))
        str.append_cstring((buff).data)
    }
}

impl Printable for bool {
    print(self: &bool, str: &String, format: string) {
        str.append_string(if streq(format, "b") {
            if *self {
                "1"
            } else {
                "0"
            }
        } else if streq(format, "s") {
            if *self {
                "t"
            } else {
                "f"
            }
        } else {
            if *self {
                "true"
            } else {
                "false"
            }
        })
    }
}

impl Printable for i8 {
    print(self: &i8, str: &String, format: string) {
        printf_int_to_string(str, *self, format)
    }
}

impl Printable for i16 {
    print(self: &i16, str: &String, format: string) {
        printf_int_to_string(str, *self, format)
    }
}

impl Printable for i32 {
    print(self: &i32, str: &String, format: string) {
        printf_int_to_string(str, *self, format)
    }
}

impl Printable for i64 {
    print(self: &i64, str: &String, format: string) {
        printf_int_to_string(str, *self, format)
    }
}

impl Printable for u8 {
    print(self: &u8, str: &String, format: string) {
        printf_int_to_string(str, *self, format)
    }
}

impl Printable for u16 {
    print(self: &u16, str: &String, format: string) {
        printf_int_to_string(str, *self, format)
    }
}

impl Printable for u32 {
    print(self: &u32, str: &String, format: string) {
        printf_int_to_string(str, *self, format)
    }
}

impl Printable for u64 {
    print(self: &u64, str: &String, format: string) {
        printf_int_to_string(str, *self, format)
    }
}

impl(T: type) Printable for Option[$T] if T : Printable {
    
}
// Polymorphic instances for impl(T: type) Printable for Option[$T] if T : Printable
    // T = (type, string)
    impl(T: type) Printable for Option[string] {
        print(self: &Option[string], str: &String, format: string) {
            match @tempvar_739(self) {
                Option[string].Some($v) -> {
                    v_str : String = (fmt).format("Some({})", cast([]^any) ([cast(^any) (^v)]))
                    str.append(&v_str)
                    @destruct(v_str)
                }
                Option[string].None -> str.append_string("None")
            }
        }
    }
    // T = (type, i64)
    impl(T: type) Printable for Option[i64] {
        print(self: &Option[i64], str: &String, format: string) {
            match @tempvar_792(self) {
                Option[i64].Some($v) -> {
                    v_str : String = (fmt).format("Some({})", cast([]^any) ([cast(^any) (^v)]))
                    str.append(&v_str)
                    @destruct(v_str)
                }
                Option[i64].None -> str.append_string("None")
            }
        }
    }
    // T = (type, Location)
    impl(T: type) Printable for Option[Location] {
        print(self: &Option[Location], str: &String, format: string) {
            match @tempvar_795(self) {
                Option[Location].Some($v) -> {
                    v_str : String = (fmt).format("Some({})", cast([]^any) ([cast(^any) (^v)]))
                    str.append(&v_str)
                    @destruct(v_str)
                }
                Option[Location].None -> str.append_string("None")
            }
        }
    }
    // T = (type, String)
    impl(T: type) Printable for Option[String] {
        print(self: &Option[String], str: &String, format: string) {
            match @tempvar_814(self) {
                Option[String].Some($v) -> {
                    v_str : String = (fmt).format("Some({})", cast([]^any) ([cast(^any) (^v)]))
                    str.append(&v_str)
                    @destruct(v_str)
                }
                Option[String].None -> str.append_string("None")
            }
        }
    }
    // T = (type, Token)
    impl(T: type) Printable for Option[Token] {
        print(self: &Option[Token], str: &String, format: string) {
            match @tempvar_834(self) {
                Option[Token].Some($v) -> {
                    v_str : String = (fmt).format("Some({})", cast([]^any) ([cast(^any) (^v)]))
                    str.append(&v_str)
                    @destruct(v_str)
                }
                Option[Token].None -> str.append_string("None")
            }
        }
    }
    // T = (type, u16)
    impl(T: type) Printable for Option[u16] {
        print(self: &Option[u16], str: &String, format: string) {
            match @tempvar_839(self) {
                Option[u16].Some($v) -> {
                    v_str : String = (fmt).format("Some({})", cast([]^any) ([cast(^any) (^v)]))
                    str.append(&v_str)
                    @destruct(v_str)
                }
                Option[u16].None -> str.append_string("None")
            }
        }
    }
    // T = (type, u64)
    impl(T: type) Printable for Option[u64] {
        print(self: &Option[u64], str: &String, format: string) {
            match @tempvar_864(self) {
                Option[u64].Some($v) -> {
                    v_str : String = (fmt).format("Some({})", cast([]^any) ([cast(^any) (^v)]))
                    str.append(&v_str)
                    @destruct(v_str)
                }
                Option[u64].None -> str.append_string("None")
            }
        }
    }


impl(T: type) Printable for Cheez.Types.Abstract.GenericStructType if T : Printable {
    
}
// Polymorphic instances for impl(T: type) Printable for Cheez.Types.Abstract.GenericStructType if T : Printable
    // T = (type, u64)
    impl(T: type) Printable for Array[u64] {
        print(self: &Array[u64], str: &String, format: string) {
            append_string(str, "[")
            #macro {
                local arr : []u64 = self.slice()
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &u64 = get_index(arr, it_index)
                            #link #anonymous {
                                v : &u64 = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(str, ", ")
                                    } else {}
                                    v.print(str, "")
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(str, "]")
        }
    }
    // T = (type, i64)
    impl(T: type) Printable for Array[i64] {
        print(self: &Array[i64], str: &String, format: string) {
            append_string(str, "[")
            #macro {
                local arr : []i64 = self.slice()
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &i64 = get_index(arr, it_index)
                            #link #anonymous {
                                v : &i64 = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(str, ", ")
                                    } else {}
                                    v.print(str, "")
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(str, "]")
        }
    }
    // T = (type, String)
    impl(T: type) Printable for Array[String] {
        print(self: &Array[String], str: &String, format: string) {
            append_string(str, "[")
            #macro {
                local arr : []String = self.slice()
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &String = get_index(arr, it_index)
                            #link #anonymous {
                                v : &String = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(str, ", ")
                                    } else {}
                                    v.print(str, "")
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(str, "]")
        }
    }
    // T = (type, string)
    impl(T: type) Printable for Array[string] {
        print(self: &Array[string], str: &String, format: string) {
            append_string(str, "[")
            #macro {
                local arr : []string = self.slice()
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &string = get_index(arr, it_index)
                            #link #anonymous {
                                v : &string = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(str, ", ")
                                    } else {}
                                    v.print(str, "")
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(str, "]")
        }
    }
    // T = (type, u16)
    impl(T: type) Printable for Array[u16] {
        print(self: &Array[u16], str: &String, format: string) {
            append_string(str, "[")
            #macro {
                local arr : []u16 = self.slice()
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &u16 = get_index(arr, it_index)
                            #link #anonymous {
                                v : &u16 = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(str, ", ")
                                    } else {}
                                    v.print(str, "")
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(str, "]")
        }
    }
    // T = (type, u8)
    impl(T: type) Printable for Array[u8] {
        print(self: &Array[u8], str: &String, format: string) {
            append_string(str, "[")
            #macro {
                local arr : []u8 = self.slice()
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &u8 = get_index(arr, it_index)
                            #link #anonymous {
                                v : &u8 = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(str, ", ")
                                    } else {}
                                    v.print(str, "")
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(str, "]")
        }
    }


impl(K: type, V: type) Printable for Cheez.Types.Abstract.GenericStructType if K : Printable, V : Printable {
    
}
// Polymorphic instances for impl(K: type, V: type) Printable for Cheez.Types.Abstract.GenericStructType if K : Printable, V : Printable
    // K = (type, string), V = (type, string)
    impl(K: type, V: type) Printable for Table[string, string] {
        print(self: &Table[string, string], str: &String, format: string) {
            append_string(str, "{")
            #macro {
                local r : &Table[string, string] = self
                
                it_index : i64 = 0
                #macro {
                    local arr : []Entry[string, string] = r.get_entries()
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &Entry[string, string] = get_index(arr, it_index)
                                #link #anonymous {
                                    e : &Entry[string, string] = it
                                    _ : i64 = it_index
                                    {
                                        if !(*e).filled then it_index = (it_index + 1);
                                        continue else {}
                                        it : (name: string, value: &string) = ((*e).key, &((*e).value).Some)
                                        #link #anonymous {
                                            v : (name: string, value: &string) = it
                                            it_index : i64 = it_index
                                            {
                                                if (it_index > 0) {
                                                    append_string(str, ", ")
                                                } else {}
                                                &(v).name.print(str, "")
                                                append_string(str, ": ")
                                                (v).value.print(str, "")
                                            }
                                        }
                                        it_index = (it_index + 1)
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            }
            append_string(str, "}")
        }
    }


impl(T: type) Printable for Cheez.Types.Abstract.GenericStructType {
    
}

impl(V: type, E: type) Printable for Result[$V, $E] if V : Printable, E : Printable {
    
}
// Polymorphic instances for impl(V: type, E: type) Printable for Result[$V, $E] if V : Printable, E : Printable
    // V = (type, String), E = (type, ())
    impl(V: type, E: type) Printable for Result[String, ()] {
        print(self: &Result[String, ()], str: &String, format: string) {
            match @tempvar_752(self) {
                Result[String, ()].Ok($v) -> str.appendf("Ok({})", (fmt).format_any(cast(^any) (v)))
                Result[String, ()].Err($v) -> str.appendf("Err({})", (fmt).format_any(cast(^any) (v)))
            }
        }
    }
    // V = (type, ()), E = (type, ())
    impl(V: type, E: type) Printable for Result[(), ()] {
        print(self: &Result[(), ()], str: &String, format: string) {
            match @tempvar_767(self) {
                Result[(), ()].Ok($v) -> str.appendf("Ok({})", (fmt).format_any(cast(^any) (v)))
                Result[(), ()].Err($v) -> str.appendf("Err({})", (fmt).format_any(cast(^any) (v)))
            }
        }
    }
    // V = (type, string), E = (type, ())
    impl(V: type, E: type) Printable for Result[string, ()] {
        print(self: &Result[string, ()], str: &String, format: string) {
            match @tempvar_784(self) {
                Result[string, ()].Ok($v) -> str.appendf("Ok({})", (fmt).format_any(cast(^any) (v)))
                Result[string, ()].Err($v) -> str.appendf("Err({})", (fmt).format_any(cast(^any) (v)))
            }
        }
    }
    // V = (type, Array[u16]), E = (type, ())
    impl(V: type, E: type) Printable for Result[Array[u16], ()] {
        print(self: &Result[Array[u16], ()], str: &String, format: string) {
            match @tempvar_836(self) {
                Result[Array[u16], ()].Ok($v) -> str.appendf("Ok({})", (fmt).format_any(cast(^any) (v)))
                Result[Array[u16], ()].Err($v) -> str.appendf("Err({})", (fmt).format_any(cast(^any) (v)))
            }
        }
    }


impl Printable for Complex {
    print(self: &Complex, str: &String, format: string) {
        str.appendf("{} + {}i", (r, i))
    }
}

impl Printable for TypeInfo {
    print(self: &TypeInfo, str: &String, format: string) {
        print_func : fn(^void, &String, string) = self.get_trait_function("print")
        if (print_func != null) {
            print_func(((Traits).destructure(^self)).ptr, str, "")
        } else {
            append_string(str, "TypeInfo<unknown>")
        }
    }
}

impl Printable for TypeInfoVoid {
    print(self: &TypeInfoVoid, str: &String, format: string) {
        append_string(str, "void")
    }
}

impl Printable for TypeInfoType {
    print(self: &TypeInfoType, str: &String, format: string) {
        append_string(str, "type")
    }
}

impl Printable for TypeInfoFloat {
    print(self: &TypeInfoFloat, str: &String, format: string) {
        str.append_string(match @tempvar_481((*self).size) {
            4 -> "f32"
            8 -> "f64"
            _ -> @assert(false)
        })
    }
}

impl Printable for TypeInfoBool {
    print(self: &TypeInfoBool, str: &String, format: string) {
        append_string(str, "bool")
    }
}

impl Printable for TypeInfoChar {
    print(self: &TypeInfoChar, str: &String, format: string) {
        str.append_string(match @tempvar_482((*self).size) {
            1 -> "char8"
            2 -> "char16"
            4 -> "char32"
            _ -> @assert(false)
        })
    }
}

impl Printable for TypeInfoString {
    print(self: &TypeInfoString, str: &String, format: string) {
        append_string(str, "string")
    }
}

impl Printable for TypeInfoAny {
    print(self: &TypeInfoAny, str: &String, format: string) {
        append_string(str, "any")
    }
}

impl Printable for TypeInfoFunction {
    print(self: &TypeInfoFunction, str: &String, format: string) {
        append_string(str, "fn (")
        #macro {
            local arr : []^TypeInfo = (*self).param_types
            
            local reverse : bool : false
            local by_ref : bool : false
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : ^TypeInfo = *get_index(arr, it_index)
                        #link #anonymous {
                            param_type : ^TypeInfo = it
                            it_index : i64 = it_index
                            {
                                if (it_index > 0) {
                                    append_string(str, ", ")
                                } else {}
                                (fmt).format_into(str, "{}", cast([]^any) ([cast(^any) (param_type)]))
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        append_string(str, ") -> ")
        (fmt).format_into(str, "{}", cast([]^any) ([cast(^any) ((*self).return_type)]))
    }
}

impl Printable for TypeInfoTuple {
    print(self: &TypeInfoTuple, str: &String, format: string) {
        append_string(str, "TODO: printable for TypeInfoTuple")
    }
}

impl Printable for TypeInfoInt {
    print(self: &TypeInfoInt, str: &String, format: string) {
        str.append_string(match @tempvar_483(((*self).size, (*self).signed)) {
            (1, true) -> "i8"
            (2, true) -> "i16"
            (4, true) -> "i32"
            (8, true) -> "i64"
            (1, false) -> "u8"
            (2, false) -> "u16"
            (4, false) -> "u32"
            (8, false) -> "u64"
            _ -> @assert(false)
        })
    }
}

impl Printable for TypeInfoPointer {
    print(self: &TypeInfoPointer, str: &String, format: string) {
        append_string(str, "^")
        if (*self).is_mut {
            append_string(str, "mut ")
        } else {}
        (fmt).format_into(str, "{}", cast([]^any) ([cast(^any) (target)]))
    }
}

impl Printable for TypeInfoReference {
    print(self: &TypeInfoReference, str: &String, format: string) {
        append_string(str, "&")
        if (*self).is_mut {
            append_string(str, "mut ")
        } else {}
        (fmt).format_into(str, "{}", cast([]^any) ([cast(^any) (target)]))
    }
}

impl Printable for TypeInfoSlice {
    print(self: &TypeInfoSlice, str: &String, format: string) {
        append_string(str, "[]")
        (fmt).format_into(str, "{}", cast([]^any) ([cast(^any) (target)]))
    }
}

impl Printable for TypeInfoArray {
    print(self: &TypeInfoArray, str: &String, format: string) {
        str.appendf("[{}]", count)
        (fmt).format_into(str, "{}", cast([]^any) ([cast(^any) (target)]))
    }
}

impl Printable for TypeInfoTrait {
    print(self: &TypeInfoTrait, str: &String, format: string) {
        if strings_equal(format, "?") {
            (fmt).format_into(str, "trait {} ``{`n", cast([]^any) ([cast(^any) ((*self).name)]))
            append_string(str, "}")
        } else {
            append_string(str, (*self).name)
        }
    }
}

impl Printable for TypeInfoStruct {
    print(self: &TypeInfoStruct, str: &String, format: string) {
        if strings_equal(format, "?") {
            (fmt).format_into(str, "struct {} ``{`n", cast([]^any) ([cast(^any) ((*self).name)]))
            #macro {
                local arr : []TypeInfoStructMember = (*self).members
                
                local reverse : bool : false
                local by_ref : bool : false
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : TypeInfoStructMember = *get_index(arr, it_index)
                            #link #anonymous {
                                mem : TypeInfoStructMember = it
                                it_index : i64 = it_index
                                {
                                    (fmt).format_into(str, "    {} : {}`n", cast([]^any) ([cast(^any) ((mem).name), cast(^any) ((mem).typ)]))
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(str, "}")
        } else {
            append_string(str, (*self).name)
        }
    }
}

impl Printable for TypeInfoEnum {
    print(self: &TypeInfoEnum, str: &String, format: string) {
        if strings_equal(format, "?") {
            (fmt).format_into(str, "enum {} ``{`n", cast([]^any) ([cast(^any) ((*self).name)]))
            append_string(str, "}")
        } else {
            append_string(str, (*self).name)
        }
    }
}

printf_int_to_string : (str: &String, i: $T, format: string) : printf_int_to_string(str: &String, i: $T, format: string) {
    base :  = if streq("b", format) then 2 else if streq("x", format) then 16 else 10
    (fmt).format_int(str, i, base)
}
// Polymorphic instances for printf_int_to_string(str: &String, i: $T, format: string)
    /* T = (type, i8) */
    /*  */
    printf_int_to_string(str: &String, i: i8, format: string) {
        base : i64 = if streq("b", format) then 2 else if streq("x", format) then 16 else 10
        (fmt).format_int(str, i, base)
    }
    /* T = (type, i16) */
    /*  */
    printf_int_to_string(str: &String, i: i16, format: string) {
        base : i64 = if streq("b", format) then 2 else if streq("x", format) then 16 else 10
        (fmt).format_int(str, i, base)
    }
    /* T = (type, i32) */
    /*  */
    printf_int_to_string(str: &String, i: i32, format: string) {
        base : i64 = if streq("b", format) then 2 else if streq("x", format) then 16 else 10
        (fmt).format_int(str, i, base)
    }
    /* T = (type, i64) */
    /*  */
    printf_int_to_string(str: &String, i: i64, format: string) {
        base : i64 = if streq("b", format) then 2 else if streq("x", format) then 16 else 10
        (fmt).format_int(str, i, base)
    }
    /* T = (type, u8) */
    /*  */
    printf_int_to_string(str: &String, i: u8, format: string) {
        base : i64 = if streq("b", format) then 2 else if streq("x", format) then 16 else 10
        (fmt).format_int(str, i, base)
    }
    /* T = (type, u16) */
    /*  */
    printf_int_to_string(str: &String, i: u16, format: string) {
        base : i64 = if streq("b", format) then 2 else if streq("x", format) then 16 else 10
        (fmt).format_int(str, i, base)
    }
    /* T = (type, u32) */
    /*  */
    printf_int_to_string(str: &String, i: u32, format: string) {
        base : i64 = if streq("b", format) then 2 else if streq("x", format) then 16 else 10
        (fmt).format_int(str, i, base)
    }
    /* T = (type, u64) */
    /*  */
    printf_int_to_string(str: &String, i: u64, format: string) {
        base : i64 = if streq("b", format) then 2 else if streq("x", format) then 16 else 10
        (fmt).format_int(str, i, base)
    }


#file util.che
next_aligned_num : (val: $T, align: T) -> T : next_aligned_num(val: $T, align: T) -> T {
    mul :  = ((val + align) - 1)
    mul = (mul % align)
    return mul
}
// Polymorphic instances for next_aligned_num(val: $T, align: T) -> T
    /* T = (type, i64) */
    /*  */
    next_aligned_num(val: i64, align: i64) -> i64 {
        mul : i64 = ((val + align) - 1)
        mul = (mul - (mul % align))
        return mul
    }


next_aligned : (_add: ^$T, align: u64) -> ^T : next_aligned(_add: ^$T, align: u64) -> ^T {
    add :  = u64(_add)
    mul :  = ((add + align) - 1)
    mul = (mul % align)
    return cast (mul)
}
// Polymorphic instances for next_aligned(_add: ^$T, align: u64) -> ^T
    /* T = (type, u8) */
    /*  */
    next_aligned(_add: ^u8, align: u64) -> ^u8 {
        add : u64 = cast(u64) (_add)
        mul : u64 = ((add + align) - 1)
        mul = (mul - (mul % align))
        return cast (mul)
    }


pointer_add_sized : (ptr: ^$T, amount: int) -> ^T : pointer_add_sized(ptr: ^$T, amount: int) -> ^T {
    return cast() ((cast() (ptr) + (amount * @sizeof(T))))
}
// Polymorphic instances for pointer_add_sized(ptr: ^$T, amount: int) -> ^T
    /* T = (type, u8) */
    /*  */
    pointer_add_sized(ptr: ^u8, amount: i64) -> ^u8 {
        return cast(^u8) ((cast(i64) (ptr) + (amount * @sizeof(u8))))
    }
    /* T = (type, ^CompilationJob) */
    /*  */
    pointer_add_sized(ptr: ^^CompilationJob, amount: i64) -> ^^CompilationJob {
        return cast(^^CompilationJob) ((cast(i64) (ptr) + (amount * @sizeof(^CompilationJob))))
    }
    /* T = (type, ^FiberContext) */
    /*  */
    pointer_add_sized(ptr: ^^FiberContext, amount: i64) -> ^^FiberContext {
        return cast(^^FiberContext) ((cast(i64) (ptr) + (amount * @sizeof(^FiberContext))))
    }


pointer_add : (ptr: ^$T, amount: int) -> ^T : pointer_add(ptr: ^$T, amount: int) -> ^T {
    return cast() ((cast() (ptr) + amount))
}
// Polymorphic instances for pointer_add(ptr: ^$T, amount: int) -> ^T
    /* T = (type, void) */
    /*  */
    pointer_add(ptr: ^void, amount: i64) -> ^void {
        return cast(^void) ((cast(i64) (ptr) + amount))
    }
    /* T = (type, u8) */
    /*  */
    pointer_add(ptr: ^u8, amount: i64) -> ^u8 {
        return cast(^u8) ((cast(i64) (ptr) + amount))
    }


#file windows.che
use import std.os.windows_functions

use import std.os.windows_types

__std_in_handle : ^void = GetStdHandle(-10)

__std_out_handle : ^void = GetStdHandle(-11)

__std_err_handle : ^void = GetStdHandle(-12)

#file windows_functions.che
use import windows_types

use import windows_constants

GetCursorPos :: GetCursorPos(pos: ^POINT) -> i32 #stdcall 

SetCursorPos :: SetCursorPos(x: i32, y: i32) -> i32 #stdcall 

MultiByteToWideChar :: MultiByteToWideChar(CodePage: u32, dwFlags: u32, lpMultiByteStr: ^u8, cbMultiByte: i32, lpWideCharStr: ^u16, cchWideChar: i32) -> i32 #stdcall 

WideCharToMultiByte :: WideCharToMultiByte(CodePage: u32, dwFlags: u32, lpWideCharStr: ^u16, cchWideChar: i32, lpMultiByteStr: ^u8, cbMultiByte: i32, lpDefaultChar: ^u8, lpUsedDefaultChar: ^i32) -> i32 #stdcall 

FindFirstChangeNotificationA :: FindFirstChangeNotificationA(lpPathName: ^char8, bWatchSubtree: i32, dwNotifyFilter: u32) -> ^void #stdcall 

FindNextChangeNotification :: FindNextChangeNotification(hChangeHandle: ^void) -> i32 #stdcall 

FindCloseChangeNotification :: FindCloseChangeNotification(hChangeHandle: ^void) -> i32 #stdcall 

RegisterWaitForSingleObject :: RegisterWaitForSingleObject(phNewWaitObject: ^^void, hObject: ^void, callback: fn(^void, bool), context: ^void, dwMilliseconds: u32, dwFlags: u32) -> i32 #stdcall 

ReadDirectoryChangesW :: ReadDirectoryChangesW(hDirectory: ^void, lpBuffer: ^void, nBufferLength: u32, bWatchSubtree: i32, dwNotifyFilter: u32, lpBytesReturned: ^u32, lpOverlapped: ^void, lpCompletionRoutine: ^void) -> i32 #stdcall 

WaitForSingleObject :: WaitForSingleObject(handle: ^void, millis: u32) -> u32 #stdcall 

WaitForMultipleObjects :: WaitForMultipleObjects(nCount: u32, lpHandles: ^^void, bWaitAll: i32, dwMilliseconds: u32) -> u32 #stdcall 

UnregisterWait :: UnregisterWait(handle: ^void) #stdcall 

GetCommandLineA :: GetCommandLineA() -> ^char8 #stdcall 

GetCommandLineW :: GetCommandLineW() -> ^u16 #stdcall 

CommandLineToArgvW :: CommandLineToArgvW(lpCmdLine: ^u16, pNumArgs: ^i32) -> ^^u16 #stdcall 

GetLastError :: GetLastError() -> WindowsErrorCode #stdcall 

CloseHandle :: CloseHandle(hObject: ^void) -> i32 #stdcall 

QueryPerformanceCounter :: QueryPerformanceCounter(lpPerformanceCount: ^i64) -> i32 #stdcall 

QueryPerformanceFrequency :: QueryPerformanceFrequency(lpPerformanceCount: ^i64) -> i32 #stdcall 

Sleep :: Sleep(millis: u32) #stdcall 

GetStdHandle :: GetStdHandle(nStdHandle: u32) -> ^void #stdcall 

SetFilePointerEx :: SetFilePointerEx(hFile: ^void, liDistanceToMove: i64, lpNewFilePointer: ^i64, dwMoveMethod: u32) -> i32 #stdcall 

WriteFile :: WriteFile(hFile: ^void, lpBuffer: ^void, nNumberOfBytesToWrite: u32, lpNumberOfBytesWritten: ^u32, lpOverlapped: ^void) -> i32 #stdcall 

ReadFile :: ReadFile(hFile: ^void, lpBuffer: ^void, nNumberOfBytesToRead: u32, lpNumberOfBytesRead: ^u32, lpOverlapped: ^void) -> i32 #stdcall 

CreateFileA :: CreateFileA(lpFileName: ^u8, dwDesiredAccess: u32, dwShareMode: u32, lpSecurityAttributes: ^SECURITY_ATTRIBUTES, dwCreationDisposition: u32, dwFlagsAndAttributes: u32, hTemplateFile: ^void) -> ^void #stdcall 

CreateFileW :: CreateFileW(lpFileName: ^u16, dwDesiredAccess: u32, dwShareMode: u32, lpSecurityAttributes: ^SECURITY_ATTRIBUTES, dwCreationDisposition: u32, dwFlagsAndAttributes: u32, hTemplateFile: ^void) -> ^void #stdcall 

CreateDirectoryA :: CreateDirectoryA(lpPathName: ^u8, lpSecurityAttributes: ^SECURITY_ATTRIBUTES) -> i32 #stdcall 

CreateDirectoryW :: CreateDirectoryW(lpPathName: ^u16, lpSecurityAttributes: ^SECURITY_ATTRIBUTES) -> i32 #stdcall 

GetFileSize :: GetFileSize(hFile: ^void, lpFileSizeHigh: ^u32) -> u32 #stdcall 

GetFileSizeEx :: GetFileSizeEx(hFile: ^void, lpFileSize: ^i64) -> i32 #stdcall 

GetFullPathNameW :: GetFullPathNameW(lpFileName: ^u16, nBufferLength: u32, lpBuffer: ^char8, lpFilePart: ^^char8) -> u32 #stdcall 

WriteConsoleW :: WriteConsoleW(hConsoleOutput: ^void, lpBuffer: ^void, nNumberOfBytesToWrite: u32, lpNumberOfCharsWritten: ^u32, lpOverlapped: ^void) -> i32 #stdcall 

GetConsoleMode :: GetConsoleMode(hConsoleHandle: ^void, lpMode: ^u32) -> i32 #stdcall 

SetConsoleTextAttribute :: SetConsoleTextAttribute(hConsoleOutput: ^void, wAttributes: u16) -> i32 #stdcall 

SetConsoleMode :: SetConsoleMode(hConsoleHandle: ^void, dwMode: u32) -> i32 #stdcall 

FlushConsoleInputBuffer :: FlushConsoleInputBuffer(hConsoleInput: ^void) -> i32 #stdcall 

SetWindowTextA :: SetWindowTextA(hWnd: ^void, lpString: ^char8) -> i32 #stdcall 

SetWindowTextW :: SetWindowTextW(hWnd: ^void, lpString: ^u16) -> i32 #stdcall 

DefWindowProcA :: DefWindowProcA(hwnd: ^void, msg: u32, wparam: u64, lparam: i64) -> i64 #stdcall 

RegisterClassA :: RegisterClassA(wndClass: ^WNDCLASSA) -> u16 #stdcall 

AdjustWindowRectEx :: AdjustWindowRectEx(lpRect: ^RECT, dwStyle: u32, bMenu: i32, dwExStyle: u32) -> i32 #stdcall 

CreateWindowExA :: CreateWindowExA(dwExStyle: u32, lpClassNa: ^char8, lpWindowName: ^char8, dwSty: u32, X: i32, Y: i32, nWidt: i32, nHeig: i32, hWndParen: ^void, hMenu: ^void, hInstance: ^void, lpPar: ^void) -> ^void #stdcall 

PostMessageA :: PostMessageA(hWnd: ^void, msg: u32, wparam: u64, lparam: i64) -> i32 #stdcall 

PeekMessageA :: PeekMessageA(lpMsg: ^MSG, hWnd: ^void, wMsgFilterMin: u32, wMsgFilterMax: u32, wRemoveMsg: u32) -> i32 #stdcall 

GetMessageA :: GetMessageA(lpMsg: ^MSG, hWnd: ^void, wMsgFilterMin: u32, wMsgFilterMax: u32) -> i32 #stdcall 

TranslateMessage :: TranslateMessage(lpMsg: ^MSG) -> i32 #stdcall 

DispatchMessageA :: DispatchMessageA(lpMsg: ^MSG) -> i64 #stdcall 

LoadIconA :: LoadIconA(hInstance: ^void, lpIconName: ^char8) -> ^void #stdcall 

LoadCursorA :: LoadCursorA(hInstance: ^void, lpIconName: ^char8) -> ^void #stdcall 

PostQuitMessage :: PostQuitMessage(exitCode: i32) #stdcall 

GetDC :: GetDC(hwnd: ^void) -> ^void #stdcall 

ChoosePixelFormat :: ChoosePixelFormat(hdc: ^void, ppfd: ^PIXELFORMATDESCRIPTOR) -> i32 #stdcall 

SetPixelFormat :: SetPixelFormat(hdc: ^void, format: i32, ppfd: ^PIXELFORMATDESCRIPTOR) -> i32 #stdcall 

SwapBuffers :: SwapBuffers(^void) -> i32 #stdcall 

wglCreateContext :: wglCreateContext(hdc: ^void) -> ^void #stdcall 

wglMakeCurrent :: wglMakeCurrent(^void, ^void) -> i32 #stdcall 

wglGetProcAddress :: wglGetProcAddress(^char8) -> fn() #stdcall 

ConvertThreadToFiber :: ConvertThreadToFiber(lpParameter: ^void) -> ^void #stdcall 

SwitchToFiber :: SwitchToFiber(fiber: ^void) #stdcall 

CreateFiber :: CreateFiber(dwStackSize: i64, lpStartAddress: fn(^void), lpParameter: ^void) -> ^void #stdcall 

DeleteFiber :: DeleteFiber(fiber: ^void) #stdcall 

GetModuleHandleA :: GetModuleHandleA(lpModuleName: ^char8) -> ^void #stdcall 

CreateProcessA :: CreateProcessA(lpApplicationName: ^char8, lpCommandLine: ^char8, lpProcessAttributes: ^SECURITY_ATTRIBUTES, lpThreadAttributes: ^SECURITY_ATTRIBUTES, bInheritHandles: i32, dwCreationFlags: u32, lpEnvironment: ^void, lpCurrentDirectory: ^char8, lpStartupInfo: ^STARTUPINFOA, lpProcessInformation: ^PROCESS_INFORMATION) -> i32 #stdcall 

PathFindOnPathA :: PathFindOnPathA(pszPath: ^char8, ppszOtherDirs: ^^char8) -> i32 #stdcall 

GetCurrentThread :: GetCurrentThread() -> ^void #stdcall 

GetCurrentThreadId :: GetCurrentThreadId() -> u32 #stdcall 

GetThreadId :: GetThreadId(handle: ^void) -> u32 #stdcall 

CreateThread :: CreateThread(lpThreadAttributes: ^SECURITY_ATTRIBUTES, dwStackSize: u64, lpStartAddress: fn(^void) -> u32, lpParameter: ^void, dwCreationFlags: u32, lpThreadId: ^u32) -> ^void #stdcall 

ResumeThread :: ResumeThread(hThread: ^void) -> u32 #stdcall 

ExitThread :: ExitThread(exitCode: u32) -> u32 #stdcall 

TerminateThread :: TerminateThread(hThread: ^void, dwExitCode: u32) -> i32 #stdcall 

ReleaseMutex :: ReleaseMutex(handle: ^void) -> i32 #stdcall 

CreateMutexA :: CreateMutexA(lpMutexAttributes: ^void, bInitialOwner: i32, lpName: ^char32) -> ^void #stdcall 

GetExitCodeThread :: GetExitCodeThread(hThread: ^void, lpExitCode: ^u32) -> i32 #stdcall 

InitializeCriticalSection :: InitializeCriticalSection(section: ^CRITICAL_SECTION) #stdcall 

EnterCriticalSection :: EnterCriticalSection(section: ^CRITICAL_SECTION) #stdcall 

LeaveCriticalSection :: LeaveCriticalSection(section: ^CRITICAL_SECTION) #stdcall 

InitializeCriticalSectionAndSpinCount :: InitializeCriticalSectionAndSpinCount(section: ^CRITICAL_SECTION, spin_count: u32) -> i32 #stdcall 

InitializeCriticalSectionEx :: InitializeCriticalSectionEx(section: ^CRITICAL_SECTION, spin_count: u32, flags: u32) -> i32 #stdcall 

SetCriticalSectionSpinCount :: SetCriticalSectionSpinCount(section: ^CRITICAL_SECTION, spin_count: u32) -> u32 #stdcall 

TryEnterCriticalSection :: TryEnterCriticalSection(section: ^CRITICAL_SECTION) -> i32 #stdcall 

DeleteCriticalSection :: DeleteCriticalSection(section: ^CRITICAL_SECTION) #stdcall 

InitializeConditionVariable :: InitializeConditionVariable(var: ^CONDITION_VARIABLE) #stdcall 

WakeConditionVariable :: WakeConditionVariable(var: ^CONDITION_VARIABLE) #stdcall 

WakeAllConditionVariable :: WakeAllConditionVariable(var: ^CONDITION_VARIABLE) #stdcall 

SleepConditionVariableCS :: SleepConditionVariableCS(var: ^CONDITION_VARIABLE, section: ^CRITICAL_SECTION, milliseconds: u32) -> i32 #stdcall 

_InterlockedCompareExchange64 :: _InterlockedCompareExchange64(dest: ^i64, value: i64, compare_to: i64) -> i64 #stdcall 

_InterlockedExchange64 :: _InterlockedExchange64(dest: ^i64, value: i64) -> i64 #stdcall 

GetCurrentDirectoryW :: GetCurrentDirectoryW(nBufferLength: u32, lpBuffer: ^u16) -> u32 #stdcall 

GetModuleFileNameW :: GetModuleFileNameW(hModule: ^void, lpFilename: ^u16, nSize: u32) -> u32 #stdcall 

#file windows_constants.che
use import windows_types

CP_UTF8 : u0 : 65001

WAIT_OBJECT_0 : u0 : 0

WAIT_ABANDONED : u0 : 0x00000080

WAIT_TIMEOUT : u0 : 0x00000102

WAIT_FAILED : u0 : 0xFFFFFFFF

MAX_PATH : u0 : 260

FILE_NOTIFY_CHANGE_LAST_WRITE : u0 : 0x00000010

FILE_NOTIFY_CHANGE_SIZE : u0 : 0x00000008

WT_EXECUTEONLYONCE : u0 : 0x00000008

INFINITE : u0 : 0xFFFFFFFF

FOREGROUND_BLUE : u0 : 0x0001

FOREGROUND_GREEN : u0 : 0x0002

FOREGROUND_RED : u0 : 0x0004

FOREGROUND_INTENSITY : u0 : 0x0008

BACKGROUND_BLUE : u0 : 0x0010

BACKGROUND_GREEN : u0 : 0x0020

BACKGROUND_RED : u0 : 0x0040

BACKGROUND_INTENSITY : u0 : 0x0080

COMMON_LVB_LEADING_BYTE : u0 : 0x0100

COMMON_LVB_TRAILING_BYTE : u0 : 0x0200

COMMON_LVB_GRID_HORIZONTAL : u0 : 0x0400

COMMON_LVB_GRID_LVERTICAL : u0 : 0x0800

COMMON_LVB_GRID_RVERTICAL : u0 : 0x1000

COMMON_LVB_REVERSE_VIDEO : u0 : 0x4000

COMMON_LVB_UNDERSCORE : u0 : 0x8000

COMMON_LVB_SBCSDBCS : u0 : 0x0300

CREATE_SUSPENDED : u0 : 0x00000004

STACK_SIZE_PARAM_IS_A_RESERVATION : u0 : 0x00010000

PFD_MAIN_PLANE : u0 : 0

PFD_OVERLAY_PLANE : u0 : 1

PFD_UNDERLAY_PLANE : u8 : (u8).max

PFD_TYPE_RGBA : u0 : 0

PFD_TYPE_COLORINDEX : u0 : 1

PFD_DOUBLEBUFFER : u0 : 0x00000001

PFD_STEREO : u0 : 0x00000002

PFD_DRAW_TO_WINDOW : u0 : 0x00000004

PFD_DRAW_TO_BITMAP : u0 : 0x00000008

PFD_SUPPORT_GDI : u0 : 0x00000010

PFD_SUPPORT_OPENGL : u0 : 0x00000020

PFD_GENERIC_FORMAT : u0 : 0x00000040

PFD_NEED_PALETTE : u0 : 0x00000080

PFD_NEED_SYSTEM_PALETTE : u0 : 0x00000100

PFD_SWAP_EXCHANGE : u0 : 0x00000200

PFD_SWAP_COPY : u0 : 0x00000400

PFD_SWAP_LAYER_BUFFERS : u0 : 0x00000800

PFD_GENERIC_ACCELERATED : u0 : 0x00001000

PFD_SUPPORT_DIRECTDRAW : u0 : 0x00002000

PFD_DIRECT3D_ACCELERATED : u0 : 0x00004000

PFD_SUPPORT_COMPOSITION : u0 : 0x00008000

PFD_DEPTH_DONTCARE : u0 : 0x20000000

PFD_DOUBLEBUFFER_DONTCARE : u0 : 0x40000000

PFD_STEREO_DONTCARE : u0 : 0x80000000

MAKEINTRESOURCE :: MAKEINTRESOURCE(i: u64) -> ^char32 {
    return cast(^char32) (cast(u32) (cast(u16) (i)))
}

FILE_BEGIN : u0 : 0

FILE_CURRENT : u0 : 1

FILE_END : u0 : 2

GENERIC_READ : u0 : 0x80000000

GENERIC_WRITE : u0 : 0x40000000

FILE_SHARE_READ : u0 : 0x00000001

FILE_SHARE_WRITE : u0 : 0x00000002

FILE_SHARE_DELETE : u0 : 0x00000004

CREATE_NEW : u0 : 1

CREATE_ALWAYS : u0 : 2

OPEN_EXISTING : u0 : 3

OPEN_ALWAYS : u0 : 4

TRUNCATE_EXISTING : u0 : 5

FILE_ATTRIBUTE_NORMAL : u0 : 0x80

IDI_APPLICATION : ^char8 : cast(^char8) (32512)

IDC_ARROW : ^char8 : cast(^char8) (32512)

CS_VREDRAW : u0 : 0x0001

CS_HREDRAW : u0 : 0x0002

CS_OWNDC : u0 : 0x0020

WS_EX_DLGMODALFRAME : u0 : 0x00000001

WS_EX_NOPARENTNOTIFY : u0 : 0x00000004

WS_EX_TOPMOST : u0 : 0x00000008

WS_EX_ACCEPTFILES : u0 : 0x00000010

WS_EX_TRANSPARENT : u0 : 0x00000020

WS_EX_MDICHILD : u0 : 0x00000040

WS_EX_TOOLWINDOW : u0 : 0x00000080

WS_EX_WINDOWEDGE : u0 : 0x00000100

WS_EX_CLIENTEDGE : u0 : 0x00000200

WS_EX_CONTEXTHELP : u0 : 0x00000400

WS_EX_RIGHT : u0 : 0x00001000

WS_EX_LEFT : u0 : 0x00000000

WS_EX_RTLREADING : u0 : 0x00002000

WS_EX_LTRREADING : u0 : 0x00000000

WS_EX_LEFTSCROLLBAR : u0 : 0x00004000

WS_EX_RIGHTSCROLLBAR : u0 : 0x00000000

WS_EX_CONTROLPARENT : u0 : 0x00010000

WS_EX_STATICEDGE : u0 : 0x00020000

WS_EX_APPWINDOW : u0 : 0x00040000

WS_EX_LAYERED : u0 : 0x00080000

WS_EX_NOINHERITLAYOUT : u0 : 0x00100000

WS_EX_NOREDIRECTIONBITMAP : u0 : 0x00200000

WS_EX_LAYOUTRTL : u0 : 0x00400000

WS_EX_COMPOSITED : u0 : 0x02000000

WS_EX_NOACTIVATE : u0 : 0x08000000

WS_EX_OVERLAPPEDWINDOW : u0 : @bin_or(WS_EX_WINDOWEDGE, WS_EX_CLIENTEDGE)

WS_EX_PALETTEWINDOW : u0 : @bin_or(WS_EX_WINDOWEDGE, WS_EX_TOOLWINDOW, WS_EX_TOPMOST)

WS_TILED : u0 : 0x00000000

WS_OVERLAPPED : u0 : 0x00000000

WS_TABSTOP : u0 : 0x00010000

WS_MAXIMIZEBOX : u0 : 0x00010000

WS_MINIMIZEBOX : u0 : 0x00020000

WS_GROUP : u0 : 0x00020000

WS_THICKFRAME : u0 : 0x00040000

WS_SIZEBOX : u0 : 0x00040000

WS_SYSMENU : u0 : 0x00080000

WS_HSCROLL : u0 : 0x00100000

WS_VSCROLL : u0 : 0x00200000

WS_DLGFRAME : u0 : 0x00400000

WS_BORDER : u0 : 0x00800000

WS_CAPTION : u0 : 0x00C00000

WS_MAXIMIZE : u0 : 0x01000000

WS_CLIPCHILDREN : u0 : 0x02000000

WS_CLIPSIBLINGS : u0 : 0x04000000

WS_DISABLED : u0 : 0x08000000

WS_VISIBLE : u0 : 0x10000000

WS_MINIMIZE : u0 : 0x20000000

WS_ICONIC : u0 : 0x20000000

WS_CHILD : u0 : 0x40000000

WS_POPUP : u0 : 0x80000000

WS_CHILDWINDOW : u0 : WS_CHILD

WS_OVERLAPPEDWINDOW : u0 : @bin_or(WS_OVERLAPPED, WS_CAPTION, WS_SYSMENU, WS_THICKFRAME, WS_MINIMIZEBOX, WS_MAXIMIZEBOX)

WS_POPUPWINDOW : u0 : @bin_or(WS_POPUP, WS_BORDER, WS_SYSMENU)

WM_NULL : u0 : 0x0000

WM_CREATE : u0 : 0x0001

WM_DESTROY : u0 : 0x0002

WM_MOVE : u0 : 0x0003

WM_SIZE : u0 : 0x0005

WM_ACTIVATE : u0 : 0x0006

WM_SETFOCUS : u0 : 0x0007

WM_KILLFOCUS : u0 : 0x0008

WM_ENABLE : u0 : 0x000A

WM_SETREDRAW : u0 : 0x000B

WM_SETTEXT : u0 : 0x000C

WM_GETTEXT : u0 : 0x000D

WM_GETTEXTLENGTH : u0 : 0x000E

WM_PAINT : u0 : 0x000F

WM_CLOSE : u0 : 0x0010

WM_QUERYENDSESSION : u0 : 0x0011

WM_QUERYOPEN : u0 : 0x0013

WM_ENDSESSION : u0 : 0x0016

WM_QUIT : u0 : 0x0012

WM_ERASEBKGND : u0 : 0x0014

WM_SYSCOLORCHANGE : u0 : 0x0015

WM_SHOWWINDOW : u0 : 0x0018

WM_WININICHANGE : u0 : 0x001A

WM_DEVMODECHANGE : u0 : 0x001B

WM_ACTIVATEAPP : u0 : 0x001C

WM_FONTCHANGE : u0 : 0x001D

WM_TIMECHANGE : u0 : 0x001E

WM_CANCELMODE : u0 : 0x001F

WM_SETCURSOR : u0 : 0x0020

WM_MOUSEACTIVATE : u0 : 0x0021

WM_CHILDACTIVATE : u0 : 0x0022

WM_QUEUESYNC : u0 : 0x0023

WM_GETMINMAXINFO : u0 : 0x0024

WM_PAINTICON : u0 : 0x0026

WM_ICONERASEBKGND : u0 : 0x0027

WM_NEXTDLGCTL : u0 : 0x0028

WM_SPOOLERSTATUS : u0 : 0x002A

WM_DRAWITEM : u0 : 0x002B

WM_MEASUREITEM : u0 : 0x002C

WM_DELETEITEM : u0 : 0x002D

WM_VKEYTOITEM : u0 : 0x002E

WM_CHARTOITEM : u0 : 0x002F

WM_SETFONT : u0 : 0x0030

WM_GETFONT : u0 : 0x0031

WM_SETHOTKEY : u0 : 0x0032

WM_GETHOTKEY : u0 : 0x0033

WM_QUERYDRAGICON : u0 : 0x0037

WM_COMPAREITEM : u0 : 0x0039

WM_GETOBJECT : u0 : 0x003D

WM_COMPACTING : u0 : 0x0041

WM_COMMNOTIFY : u0 : 0x0044

WM_WINDOWPOSCHANGING : u0 : 0x0046

WM_WINDOWPOSCHANGED : u0 : 0x0047

WM_POWER : u0 : 0x0048

WM_COPYDATA : u0 : 0x004A

WM_CANCELJOURNAL : u0 : 0x004B

WM_NOTIFY : u0 : 0x004E

WM_INPUTLANGCHANGEREQUEST : u0 : 0x0050

WM_INPUTLANGCHANGE : u0 : 0x0051

WM_TCARD : u0 : 0x0052

WM_HELP : u0 : 0x0053

WM_USERCHANGED : u0 : 0x0054

WM_NOTIFYFORMAT : u0 : 0x0055

WM_CONTEXTMENU : u0 : 0x007B

WM_STYLECHANGING : u0 : 0x007C

WM_STYLECHANGED : u0 : 0x007D

WM_DISPLAYCHANGE : u0 : 0x007E

WM_GETICON : u0 : 0x007F

WM_SETICON : u0 : 0x0080

WM_NCCREATE : u0 : 0x0081

WM_NCDESTROY : u0 : 0x0082

WM_NCCALCSIZE : u0 : 0x0083

WM_NCHITTEST : u0 : 0x0084

WM_NCPAINT : u0 : 0x0085

WM_NCACTIVATE : u0 : 0x0086

WM_GETDLGCODE : u0 : 0x0087

WM_SYNCPAINT : u0 : 0x0088

WM_NCMOUSEMOVE : u0 : 0x00A0

WM_NCLBUTTONDOWN : u0 : 0x00A1

WM_NCLBUTTONUP : u0 : 0x00A2

WM_NCLBUTTONDBLCLK : u0 : 0x00A3

WM_NCRBUTTONDOWN : u0 : 0x00A4

WM_NCRBUTTONUP : u0 : 0x00A5

WM_NCRBUTTONDBLCLK : u0 : 0x00A6

WM_NCMBUTTONDOWN : u0 : 0x00A7

WM_NCMBUTTONUP : u0 : 0x00A8

WM_NCMBUTTONDBLCLK : u0 : 0x00A9

WM_NCXBUTTONDOWN : u0 : 0x00AB

WM_NCXBUTTONUP : u0 : 0x00AC

WM_NCXBUTTONDBLCLK : u0 : 0x00AD

WM_INPUT_DEVICE_CHANGE : u0 : 0x00FE

WM_INPUT : u0 : 0x00FF

WM_KEYFIRST : u0 : 0x0100

WM_KEYDOWN : u0 : 0x0100

WM_KEYUP : u0 : 0x0101

WM_CHAR : u0 : 0x0102

WM_DEADCHAR : u0 : 0x0103

WM_SYSKEYDOWN : u0 : 0x0104

WM_SYSKEYUP : u0 : 0x0105

WM_SYSCHAR : u0 : 0x0106

WM_SYSDEADCHAR : u0 : 0x0107

WM_UNICHAR : u0 : 0x0109

WM_KEYLAST : u0 : 0x0109

WM_IME_STARTCOMPOSITION : u0 : 0x010D

WM_IME_ENDCOMPOSITION : u0 : 0x010E

WM_IME_COMPOSITION : u0 : 0x010F

WM_IME_KEYLAST : u0 : 0x010F

WM_INITDIALOG : u0 : 0x0110

WM_COMMAND : u0 : 0x0111

WM_SYSCOMMAND : u0 : 0x0112

WM_TIMER : u0 : 0x0113

WM_HSCROLL : u0 : 0x0114

WM_VSCROLL : u0 : 0x0115

WM_INITMENU : u0 : 0x0116

WM_INITMENUPOPUP : u0 : 0x0117

WM_GESTURE : u0 : 0x0119

WM_GESTURENOTIFY : u0 : 0x011A

WM_MENUSELECT : u0 : 0x011F

WM_MENUCHAR : u0 : 0x0120

WM_ENTERIDLE : u0 : 0x0121

WM_MENURBUTTONUP : u0 : 0x0122

WM_MENUDRAG : u0 : 0x0123

WM_MENUGETOBJECT : u0 : 0x0124

WM_UNINITMENUPOPUP : u0 : 0x0125

WM_MENUCOMMAND : u0 : 0x0126

WM_CHANGEUISTATE : u0 : 0x0127

WM_UPDATEUISTATE : u0 : 0x0128

WM_QUERYUISTATE : u0 : 0x0129

WM_CTLCOLORMSGBOX : u0 : 0x0132

WM_CTLCOLOREDIT : u0 : 0x0133

WM_CTLCOLORLISTBOX : u0 : 0x0134

WM_CTLCOLORBTN : u0 : 0x0135

WM_CTLCOLORDLG : u0 : 0x0136

WM_CTLCOLORSCROLLBAR : u0 : 0x0137

WM_CTLCOLORSTATIC : u0 : 0x0138

MN_GETHMENU : u0 : 0x01E1

WM_MOUSEFIRST : u0 : 0x0200

WM_MOUSEMOVE : u0 : 0x0200

WM_LBUTTONDOWN : u0 : 0x0201

WM_LBUTTONUP : u0 : 0x0202

WM_LBUTTONDBLCLK : u0 : 0x0203

WM_RBUTTONDOWN : u0 : 0x0204

WM_RBUTTONUP : u0 : 0x0205

WM_RBUTTONDBLCLK : u0 : 0x0206

WM_MBUTTONDOWN : u0 : 0x0207

WM_MBUTTONUP : u0 : 0x0208

WM_MBUTTONDBLCLK : u0 : 0x0209

WM_MOUSEWHEEL : u0 : 0x020A

WM_XBUTTONDOWN : u0 : 0x020B

WM_XBUTTONUP : u0 : 0x020C

WM_XBUTTONDBLCLK : u0 : 0x020D

WM_MOUSEHWHEEL : u0 : 0x020E

WM_MOUSELAST : u0 : 0x020E

WM_PARENTNOTIFY : u0 : 0x0210

WM_ENTERMENULOOP : u0 : 0x0211

WM_EXITMENULOOP : u0 : 0x0212

WM_NEXTMENU : u0 : 0x0213

WM_SIZING : u0 : 0x0214

WM_CAPTURECHANGED : u0 : 0x0215

WM_MOVING : u0 : 0x0216

WM_POWERBROADCAST : u0 : 0x0218

WM_DEVICECHANGE : u0 : 0x0219

WM_MDICREATE : u0 : 0x0220

WM_MDIDESTROY : u0 : 0x0221

WM_MDIACTIVATE : u0 : 0x0222

WM_MDIRESTORE : u0 : 0x0223

WM_MDINEXT : u0 : 0x0224

WM_MDIMAXIMIZE : u0 : 0x0225

WM_MDITILE : u0 : 0x0226

WM_MDICASCADE : u0 : 0x0227

WM_MDIICONARRANGE : u0 : 0x0228

WM_MDIGETACTIVE : u0 : 0x0229

WM_MDISETMENU : u0 : 0x0230

WM_ENTERSIZEMOVE : u0 : 0x0231

WM_EXITSIZEMOVE : u0 : 0x0232

WM_DROPFILES : u0 : 0x0233

WM_MDIREFRESHMENU : u0 : 0x0234

WM_POINTERDEVICECHANGE : u0 : 0x238

WM_POINTERDEVICEINRANGE : u0 : 0x239

WM_POINTERDEVICEOUTOFRANGE : u0 : 0x23A

WM_TOUCH : u0 : 0x0240

WM_NCPOINTERUPDATE : u0 : 0x0241

WM_NCPOINTERDOWN : u0 : 0x0242

WM_NCPOINTERUP : u0 : 0x0243

WM_POINTERUPDATE : u0 : 0x0245

WM_POINTERDOWN : u0 : 0x0246

WM_POINTERUP : u0 : 0x0247

WM_POINTERENTER : u0 : 0x0249

WM_POINTERLEAVE : u0 : 0x024A

WM_POINTERACTIVATE : u0 : 0x024B

WM_POINTERCAPTURECHANGED : u0 : 0x024C

WM_TOUCHHITTESTING : u0 : 0x024D

WM_POINTERWHEEL : u0 : 0x024E

WM_POINTERHWHEEL : u0 : 0x024F

WM_POINTERROUTEDTO : u0 : 0x0251

WM_POINTERROUTEDAWAY : u0 : 0x0252

WM_POINTERROUTEDRELEASED : u0 : 0x0253

WM_IME_SETCONTEXT : u0 : 0x0281

WM_IME_NOTIFY : u0 : 0x0282

WM_IME_CONTROL : u0 : 0x0283

WM_IME_COMPOSITIONFULL : u0 : 0x0284

WM_IME_SELECT : u0 : 0x0285

WM_IME_CHAR : u0 : 0x0286

WM_IME_REQUEST : u0 : 0x0288

WM_IME_KEYDOWN : u0 : 0x0290

WM_IME_KEYUP : u0 : 0x0291

WM_MOUSEHOVER : u0 : 0x02A1

WM_MOUSELEAVE : u0 : 0x02A3

WM_NCMOUSEHOVER : u0 : 0x02A0

WM_NCMOUSELEAVE : u0 : 0x02A2

WM_WTSSESSION_CHANGE : u0 : 0x02B1

WM_TABLET_FIRST : u0 : 0x02c0

WM_TABLET_LAST : u0 : 0x02df

WM_DPICHANGED : u0 : 0x02E0

WM_DPICHANGED_BEFOREPARENT : u0 : 0x02E2

WM_DPICHANGED_AFTERPARENT : u0 : 0x02E3

WM_GETDPISCALEDSIZE : u0 : 0x02E4

WM_CUT : u0 : 0x0300

WM_COPY : u0 : 0x0301

WM_PASTE : u0 : 0x0302

WM_CLEAR : u0 : 0x0303

WM_UNDO : u0 : 0x0304

WM_RENDERFORMAT : u0 : 0x0305

WM_RENDERALLFORMATS : u0 : 0x0306

WM_DESTROYCLIPBOARD : u0 : 0x0307

WM_DRAWCLIPBOARD : u0 : 0x0308

WM_PAINTCLIPBOARD : u0 : 0x0309

WM_VSCROLLCLIPBOARD : u0 : 0x030A

WM_SIZECLIPBOARD : u0 : 0x030B

WM_ASKCBFORMATNAME : u0 : 0x030C

WM_CHANGECBCHAIN : u0 : 0x030D

WM_HSCROLLCLIPBOARD : u0 : 0x030E

WM_QUERYNEWPALETTE : u0 : 0x030F

WM_PALETTEISCHANGING : u0 : 0x0310

WM_PALETTECHANGED : u0 : 0x0311

WM_HOTKEY : u0 : 0x0312

WM_PRINT : u0 : 0x0317

WM_PRINTCLIENT : u0 : 0x0318

WM_APPCOMMAND : u0 : 0x0319

WM_THEMECHANGED : u0 : 0x031A

WM_CLIPBOARDUPDATE : u0 : 0x031D

WM_DWMCOMPOSITIONCHANGED : u0 : 0x031E

WM_DWMNCRENDERINGCHANGED : u0 : 0x031F

WM_DWMCOLORIZATIONCOLORCHANGED : u0 : 0x0320

WM_DWMWINDOWMAXIMIZEDCHANGE : u0 : 0x0321

WM_DWMSENDICONICTHUMBNAIL : u0 : 0x0323

WM_DWMSENDICONICLIVEPREVIEWBITMAP : u0 : 0x0326

WM_GETTITLEBARINFOEX : u0 : 0x033F

WM_HANDHELDFIRST : u0 : 0x0358

WM_HANDHELDLAST : u0 : 0x035F

WM_AFXFIRST : u0 : 0x0360

WM_AFXLAST : u0 : 0x037F

WM_PENWINFIRST : u0 : 0x0380

WM_PENWINLAST : u0 : 0x038F

WM_APP : u0 : 0x8000

WM_USER : u0 : 0x0400

VK_LBUTTON : u0 : 0x01

VK_RBUTTON : u0 : 0x02

VK_CANCEL : u0 : 0x03

VK_MBUTTON : u0 : 0x04

VK_XBUTTON1 : u0 : 0x05

VK_XBUTTON2 : u0 : 0x06

VK_BACK : u0 : 0x08

VK_TAB : u0 : 0x09

VK_CLEAR : u0 : 0x0C

VK_RETURN : u0 : 0x0D

VK_SHIFT : u0 : 0x10

VK_CONTROL : u0 : 0x11

VK_MENU : u0 : 0x12

VK_PAUSE : u0 : 0x13

VK_CAPITAL : u0 : 0x14

VK_KANA : u0 : 0x15

VK_HANGEUL : u0 : 0x15

VK_HANGUL : u0 : 0x15

VK_JUNJA : u0 : 0x17

VK_FINAL : u0 : 0x18

VK_HANJA : u0 : 0x19

VK_KANJI : u0 : 0x19

VK_ESCAPE : u0 : 0x1B

VK_CONVERT : u0 : 0x1C

VK_NONCONVERT : u0 : 0x1D

VK_ACCEPT : u0 : 0x1E

VK_MODECHANGE : u0 : 0x1F

VK_SPACE : u0 : 0x20

VK_PRIOR : u0 : 0x21

VK_NEXT : u0 : 0x22

VK_END : u0 : 0x23

VK_HOME : u0 : 0x24

VK_LEFT : u0 : 0x25

VK_UP : u0 : 0x26

VK_RIGHT : u0 : 0x27

VK_DOWN : u0 : 0x28

VK_SELECT : u0 : 0x29

VK_PRINT : u0 : 0x2A

VK_EXECUTE : u0 : 0x2B

VK_SNAPSHOT : u0 : 0x2C

VK_INSERT : u0 : 0x2D

VK_DELETE : u0 : 0x2E

VK_HELP : u0 : 0x2F

VK_LWIN : u0 : 0x5B

VK_RWIN : u0 : 0x5C

VK_APPS : u0 : 0x5D

VK_SLEEP : u0 : 0x5F

VK_NUMPAD0 : u0 : 0x60

VK_NUMPAD1 : u0 : 0x61

VK_NUMPAD2 : u0 : 0x62

VK_NUMPAD3 : u0 : 0x63

VK_NUMPAD4 : u0 : 0x64

VK_NUMPAD5 : u0 : 0x65

VK_NUMPAD6 : u0 : 0x66

VK_NUMPAD7 : u0 : 0x67

VK_NUMPAD8 : u0 : 0x68

VK_NUMPAD9 : u0 : 0x69

VK_MULTIPLY : u0 : 0x6A

VK_ADD : u0 : 0x6B

VK_SEPARATOR : u0 : 0x6C

VK_SUBTRACT : u0 : 0x6D

VK_DECIMAL : u0 : 0x6E

VK_DIVIDE : u0 : 0x6F

VK_F1 : u0 : 0x70

VK_F2 : u0 : 0x71

VK_F3 : u0 : 0x72

VK_F4 : u0 : 0x73

VK_F5 : u0 : 0x74

VK_F6 : u0 : 0x75

VK_F7 : u0 : 0x76

VK_F8 : u0 : 0x77

VK_F9 : u0 : 0x78

VK_F10 : u0 : 0x79

VK_F11 : u0 : 0x7A

VK_F12 : u0 : 0x7B

VK_F13 : u0 : 0x7C

VK_F14 : u0 : 0x7D

VK_F15 : u0 : 0x7E

VK_F16 : u0 : 0x7F

VK_F17 : u0 : 0x80

VK_F18 : u0 : 0x81

VK_F19 : u0 : 0x82

VK_F20 : u0 : 0x83

VK_F21 : u0 : 0x84

VK_F22 : u0 : 0x85

VK_F23 : u0 : 0x86

VK_F24 : u0 : 0x87

VK_NAVIGATION_VIEW : u0 : 0x88

VK_NAVIGATION_MENU : u0 : 0x89

VK_NAVIGATION_UP : u0 : 0x8A

VK_NAVIGATION_DOWN : u0 : 0x8B

VK_NAVIGATION_LEFT : u0 : 0x8C

VK_NAVIGATION_RIGHT : u0 : 0x8D

VK_NAVIGATION_ACCEPT : u0 : 0x8E

VK_NAVIGATION_CANCEL : u0 : 0x8F

VK_NUMLOCK : u0 : 0x90

VK_SCROLL : u0 : 0x91

VK_OEM_NEC_EQUAL : u0 : 0x92

VK_OEM_FJ_JISHO : u0 : 0x92

VK_OEM_FJ_MASSHOU : u0 : 0x93

VK_OEM_FJ_TOUROKU : u0 : 0x94

VK_OEM_FJ_LOYA : u0 : 0x95

VK_OEM_FJ_ROYA : u0 : 0x96

VK_LSHIFT : u0 : 0xA0

VK_RSHIFT : u0 : 0xA1

VK_LCONTROL : u0 : 0xA2

VK_RCONTROL : u0 : 0xA3

VK_LMENU : u0 : 0xA4

VK_RMENU : u0 : 0xA5

VK_BROWSER_BACK : u0 : 0xA6

VK_BROWSER_FORWARD : u0 : 0xA7

VK_BROWSER_REFRESH : u0 : 0xA8

VK_BROWSER_STOP : u0 : 0xA9

VK_BROWSER_SEARCH : u0 : 0xAA

VK_BROWSER_FAVORITES : u0 : 0xAB

VK_BROWSER_HOME : u0 : 0xAC

VK_VOLUME_MUTE : u0 : 0xAD

VK_VOLUME_DOWN : u0 : 0xAE

VK_VOLUME_UP : u0 : 0xAF

VK_MEDIA_NEXT_TRACK : u0 : 0xB0

VK_MEDIA_PREV_TRACK : u0 : 0xB1

VK_MEDIA_STOP : u0 : 0xB2

VK_MEDIA_PLAY_PAUSE : u0 : 0xB3

VK_LAUNCH_MAIL : u0 : 0xB4

VK_LAUNCH_MEDIA_SELECT : u0 : 0xB5

VK_LAUNCH_APP1 : u0 : 0xB6

VK_LAUNCH_APP2 : u0 : 0xB7

VK_OEM_1 : u0 : 0xBA

VK_OEM_PLUS : u0 : 0xBB

VK_OEM_COMMA : u0 : 0xBC

VK_OEM_MINUS : u0 : 0xBD

VK_OEM_PERIOD : u0 : 0xBE

VK_OEM_2 : u0 : 0xBF

VK_OEM_3 : u0 : 0xC0

VK_GAMEPAD_A : u0 : 0xC3

VK_GAMEPAD_B : u0 : 0xC4

VK_GAMEPAD_X : u0 : 0xC5

VK_GAMEPAD_Y : u0 : 0xC6

VK_GAMEPAD_RIGHT_SHOULDER : u0 : 0xC7

VK_GAMEPAD_LEFT_SHOULDER : u0 : 0xC8

VK_GAMEPAD_LEFT_TRIGGER : u0 : 0xC9

VK_GAMEPAD_RIGHT_TRIGGER : u0 : 0xCA

VK_GAMEPAD_DPAD_UP : u0 : 0xCB

VK_GAMEPAD_DPAD_DOWN : u0 : 0xCC

VK_GAMEPAD_DPAD_LEFT : u0 : 0xCD

VK_GAMEPAD_DPAD_RIGHT : u0 : 0xCE

VK_GAMEPAD_MENU : u0 : 0xCF

VK_GAMEPAD_VIEW : u0 : 0xD0

VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON : u0 : 0xD1

VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON : u0 : 0xD2

VK_GAMEPAD_LEFT_THUMBSTICK_UP : u0 : 0xD3

VK_GAMEPAD_LEFT_THUMBSTICK_DOWN : u0 : 0xD4

VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT : u0 : 0xD5

VK_GAMEPAD_LEFT_THUMBSTICK_LEFT : u0 : 0xD6

VK_GAMEPAD_RIGHT_THUMBSTICK_UP : u0 : 0xD7

VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN : u0 : 0xD8

VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT : u0 : 0xD9

VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT : u0 : 0xDA

VK_OEM_4 : u0 : 0xDB

VK_OEM_5 : u0 : 0xDC

VK_OEM_6 : u0 : 0xDD

VK_OEM_7 : u0 : 0xDE

VK_OEM_8 : u0 : 0xDF

VK_OEM_AX : u0 : 0xE1

VK_OEM_102 : u0 : 0xE2

VK_ICO_HELP : u0 : 0xE3

VK_ICO_00 : u0 : 0xE4

VK_PROCESSKEY : u0 : 0xE5

VK_ICO_CLEAR : u0 : 0xE6

VK_PACKET : u0 : 0xE7

VK_OEM_RESET : u0 : 0xE9

VK_OEM_JUMP : u0 : 0xEA

VK_OEM_PA1 : u0 : 0xEB

VK_OEM_PA2 : u0 : 0xEC

VK_OEM_PA3 : u0 : 0xED

VK_OEM_WSCTRL : u0 : 0xEE

VK_OEM_CUSEL : u0 : 0xEF

VK_OEM_ATTN : u0 : 0xF0

VK_OEM_FINISH : u0 : 0xF1

VK_OEM_COPY : u0 : 0xF2

VK_OEM_AUTO : u0 : 0xF3

VK_OEM_ENLW : u0 : 0xF4

VK_OEM_BACKTAB : u0 : 0xF5

VK_ATTN : u0 : 0xF6

VK_CRSEL : u0 : 0xF7

VK_EXSEL : u0 : 0xF8

VK_EREOF : u0 : 0xF9

VK_PLAY : u0 : 0xFA

VK_ZOOM : u0 : 0xFB

VK_NONAME : u0 : 0xFC

VK_PA1 : u0 : 0xFD

VK_OEM_CLEAR : u0 : 0xFE

INVALID_HANDLE_VALUE : u0 : 0xFFFFFFFFFFFFFFFF

WindowsErrorCode :: enum<i32> { // size: 0, alignment: 1
    ERROR_SUCCESS = 0
    ERROR_INVALID_FUNCTION = 1
    ERROR_FILE_NOT_FOUND = 2
    ERROR_PATH_NOT_FOUND = 3
    ERROR_INVALID_PARAMETER = 87
    ERROR_INSUFFICIENT_BUFFER = 122
    ERROR_ALREADY_EXISTS = 183
    ERROR_INVALID_FLAGS = 1004
    ERROR_NO_UNICODE_TRANSLATION = 1113
}

ENABLE_ECHO_INPUT : u0 : 0x0004

ENABLE_EXTENDED_FLAGS : u0 : 0x0080

ENABLE_INSERT_MODE : u0 : 0x0020

ENABLE_LINE_INPUT : u0 : 0x0002

ENABLE_MOUSE_INPUT : u0 : 0x0010

ENABLE_PROCESSED_INPUT : u0 : 0x0001

ENABLE_QUICK_EDIT_MODE : u0 : 0x0040

ENABLE_WINDOW_INPUT : u0 : 0x0008

ENABLE_VIRTUAL_TERMINAL_INPUT : u0 : 0x0200

#file windows_types.che
DWORD :: u32 = u32

HANDLE :: ^void = ^void

HWND :: HANDLE = ^void

HINSTANCE :: HANDLE = ^void

HMODULE :: HANDLE = ^void

HICON :: HANDLE = ^void

HMENU :: HANDLE = ^void

HDC :: HANDLE = ^void

HGLRC :: HANDLE = ^void

HCURSOR :: HICON = ^void

HBRUSH :: HANDLE = ^void

HFILE :: i32 = i32

BOOL :: i32 = i32

UINT :: u32 = u32

LONG :: i32 = i32

ULONG :: u32 = u32

LONGLONG :: i64 = i64

LONG64 :: i64 = i64

LARGE_INTEGER :: LONGLONG = i64

UINT_PTR :: u64 = u64

LONG_PTR :: i64 = i64

ULONG_PTR :: u64 = u64

WPARAM :: UINT_PTR = u64

LPARAM :: LONG_PTR = i64

LRESULT :: LONG_PTR = i64

ATOM :: u16 = u16

WNDCLASS :: WNDCLASSA = WNDCLASSA

UCHAR :: u8 = u8

BYTE :: u8 = u8

WORD :: u16 = u16

SIZE_T :: u64 = u64

THREAD_START_ROUTINE :: fn(^void) -> DWORD = fn(^void) -> u32

WAITORTIMERCALLBACK :: fn(^void, bool) = fn(^void, bool)

POINT :: struct { // size: 8, alignment: 4
    x : i32 = 0
    y : i32 = 0
}

MSG :: struct { // size: 48, alignment: 8
    hwnd : ^void = default
    message : u32 = default
    wParam : u64 = default
    lParam : i64 = default
    time : u32 = default
    pt : POINT = default
    lPrivate : u32 = default
}

RECT :: struct { // size: 16, alignment: 4
    left : i32
    top : i32
    right : i32
    bottom : i32
}

WNDCLASSA :: struct { // size: 72, alignment: 8
    style : u32 = default
    lpfnWndProc : fn(^void, u32, u64, i64) -> i64 = default
    cbClsExtra : i32 = default
    cbWndExtra : i32 = default
    hInstance : ^void = default
    hIcon : ^void = default
    hCursor : ^void = default
    hbrBackground : ^void = default
    lpszMenuName : ^char8 = default
    lpszClassName : ^char8 = default
}

MINMAXINFO :: struct { // size: 40, alignment: 4
    ptReserved : POINT
    ptMaxSize : POINT
    ptMaxPosition : POINT
    ptMinTrackSize : POINT
    ptMaxTrackSize : POINT
}

MDINEXTMENU :: struct { // size: 24, alignment: 8
    hmenuIn : ^void
    hmenuNext : ^void
    hwndNext : ^void
}

GUID :: struct { // size: 16, alignment: 4
    Data1 : u32
    Data2 : u16
    Data3 : u16
    Data4 : [8]u8
}

POWERBROADCAST_SETTING :: struct { // size: 24, alignment: 4
    PowerSetting : GUID
    DataLength : u32
    Data : [1]u8
}

CREATESTRUCTA :: struct { // size: 80, alignment: 8
    lpCreateParams : ^void
    hInstance : ^void
    hMenu : ^void
    hwndParent : ^void
    cy : i32
    cx : i32
    y : i32
    x : i32
    style : i32
    lpszName : ^char8
    lpszClass : ^char8
    dwExStyle : u32
}

PIXELFORMATDESCRIPTOR :: struct { // size: 40, alignment: 4
    nSize : u16
    nVersion : u16
    dwFlags : u32
    iPixelType : u8
    cColorBits : u8
    cRedBits : u8
    cRedShift : u8
    cGreenBits : u8
    cGreenShift : u8
    cBlueBits : u8
    cBlueShift : u8
    cAlphaBits : u8
    cAlphaShift : u8
    cAccumBits : u8
    cAccumRedBits : u8
    cAccumGreenBits : u8
    cAccumBlueBits : u8
    cAccumAlphaBits : u8
    cDepthBits : u8
    cStencilBits : u8
    cAuxBuffers : u8
    iLayerType : u8
    bReserved : u8
    dwLayerMask : u32
    dwVisibleMask : u32
    dwDamageMask : u32
}

SECURITY_ATTRIBUTES :: struct { // size: 24, alignment: 8
    nLength : u32
    lpSecurityDescriptor : ^void
    bInheritHandle : i32
}

STARTUPINFOA :: struct { // size: 104, alignment: 8
    cb : u32 = @sizeof(STARTUPINFOA)
    lpReserved : ^char8 = default
    lpDesktop : ^char8 = default
    lpTitle : ^char8 = default
    dwX : u32 = default
    dwY : u32 = default
    dwXSize : u32 = default
    dwYSize : u32 = default
    dwXCountChars : u32 = default
    dwYCountChars : u32 = default
    dwFillAttribute : u32 = default
    dwFlags : u32 = default
    wShowWindow : u16 = default
    cbReserved2 : u16 = default
    lpReserved2 : ^u8 = default
    hStdInput : ^void = default
    hStdOutput : ^void = default
    hStdError : ^void = default
}

PROCESS_INFORMATION :: struct { // size: 24, alignment: 8
    hProcess : ^void = default
    hThread : ^void = default
    dwProcessId : u32 = default
    dwThreadId : u32 = default
}

CRITICAL_SECTION :: struct { // size: 40, alignment: 8
    DebugInfo : ^void = default
    LockCount : i32 = default
    RecursionCount : i32 = default
    OwningThread : ^void = default
    LockSemaphore : ^void = default
    SpinCount : u32 = default
}

CONDITION_VARIABLE :: struct { // size: 8, alignment: 8
    ptr : ^void = default
}

#file hash.che
Hashable :: trait {
    hash :: f.Accept(this)
}

impl Hashable for ^char8 {
    hash(self: &^char8) -> u64 {
        h : u32 = 2166136261
        {
            i : i64 = 0
            loop {
                if !(*self[i] != '`0') then break else {}
                defer i = (i + 1)
                h = (h + cast(u32) (*self[i]))
                h = (h * 16777619)
                i = (i + 1)
            }
        }
        return cast (h)
    }
}

impl Hashable for string {
    hash(self: &string) -> u64 {
        h : u32 = 2166136261
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = ((*self).bytes).length }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_215) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_215))[0]
                it_index : i64 = @var(@id((it, it_index)_215))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            h = (h + cast(u32) (*get_index(*self, i)))
                            h = (h * 16777619)
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        return cast(u64) (h)
    }
}

impl Hashable for i64 {
    hash(self: &i64) -> u64 {
        return cast(u64) ((*self * 123))
    }
}

impl Hashable for TypeId {
    hash(self: &TypeId) -> u64 {
        ptr : u64 = cast(u64) (((Traits).destructure((*self).ptr)).ptr)
        return @bin_xor((ptr * 987654321), 0x15af86e28b57d91b)
    }
}

#file unicode.che
Utf8Format :: struct { // size: 16, alignment: 4
    mask : u8
    lead : u8
    beg : u32
    end : u32
    bits : u32
}

utf8_formats : [5]Utf8Format = [new Utf8Format {
    mask = 0b00111111
    lead = 0b10000000
    beg = 0x0
    end = 0x0
    bits = 6
}, new Utf8Format {
    mask = 0b01111111
    lead = 0b00000000
    beg = 0x0
    end = 0x7F
    bits = 7
}, new Utf8Format {
    mask = 0b00011111
    lead = 0b11000000
    beg = 0x80
    end = 0x7FF
    bits = 5
}, new Utf8Format {
    mask = 0b00001111
    lead = 0b11100000
    beg = 0x800
    end = 0xFFFF
    bits = 4
}, new Utf8Format {
    mask = 0b00000111
    lead = 0b11110000
    beg = 0x10000
    end = 0x10FFFF
    bits = 3
}]

Utf8 :: struct { // size: 0, alignment: 1
    
}

impl Utf8 {
    encode(ch: char32) -> ([4]u8, i32) {
        rune : u32 = cast(u32) (ch)
        ext : &Utf8Format = get_index(&utf8_formats, 0)
        {
            format : &Utf8Format = get_index(&utf8_formats, 1)
            if (rune <= (*format).end) {
                return ([cast(u8) (rune), 0, 0, 0], 1)
            } else {
                format : &Utf8Format = get_index(&utf8_formats, 2)
                if (rune <= (*format).end) {
                    return ([@bin_or((*format).lead, @bin_and((*format).mask, cast(u8) (@bin_lsr(@tempvar_484(rune), 6)))), @bin_or((*ext).lead, @bin_and((*ext).mask, cast(u8) (@bin_lsr(@tempvar_485(rune), 0)))), 0, 0], 2)
                } else {
                    format : &Utf8Format = get_index(&utf8_formats, 3)
                    if (rune <= (*format).end) {
                        return ([@bin_or((*format).lead, @bin_and((*format).mask, cast(u8) (@bin_lsr(@tempvar_486(rune), 12)))), @bin_or((*ext).lead, @bin_and((*ext).mask, cast(u8) (@bin_lsr(@tempvar_487(rune), 6)))), @bin_or((*ext).lead, @bin_and((*ext).mask, cast(u8) (@bin_lsr(@tempvar_488(rune), 0)))), 0], 3)
                    } else {
                        format : &Utf8Format = get_index(&utf8_formats, 4)
                        if (rune <= (*format).end) {
                            return ([@bin_or((*format).lead, @bin_and((*format).mask, cast(u8) (@bin_lsr(@tempvar_489(rune), 18)))), @bin_or((*ext).lead, @bin_and((*ext).mask, cast(u8) (@bin_lsr(@tempvar_490(rune), 12)))), @bin_or((*ext).lead, @bin_and((*ext).mask, cast(u8) (@bin_lsr(@tempvar_491(rune), 6)))), @bin_or((*ext).lead, @bin_and((*ext).mask, cast(u8) (@bin_lsr(@tempvar_492(rune), 0))))], 4)
                        } else {}
                    }
                }
            }
        }
        return ([0, 0, 0, 0], 0)
    }
    
    decode(bytes: []u8) -> (char32, i32) {
        ext : &Utf8Format = get_index(&utf8_formats, 0)
        mask :: mask(format: &Utf8Format, b: u8) -> u32 {
            return cast(u32) (@bin_and((*format).mask, b))
        }
        b0 : u32 = cast(u32) (*get_index(bytes, 0))
        byte_count : i32 = 0
        code_point : u32 = 0
        if (@bin_lsr(b0, 7) == 0) {
            code_point = b0
            byte_count = 1
        } else if (@bin_lsr(b0, 5) == 0b110) {
            format : &Utf8Format = get_index(&utf8_formats, 2)
            code_point = @bin_or(mask(ext, *get_index(bytes, 1)), @bin_lsl(@tempvar_493(mask(format, *get_index(bytes, 0))), 6))
            byte_count = 2
        } else if (@bin_lsr(b0, 4) == 0b1110) {
            format : &Utf8Format = get_index(&utf8_formats, 3)
            code_point = @bin_or(mask(ext, *get_index(bytes, 2)), @bin_lsl(@tempvar_495(@bin_or(mask(ext, *get_index(bytes, 1)), @bin_lsl(@tempvar_494(mask(format, *get_index(bytes, 0))), 6))), 6))
            byte_count = 3
        } else if (@bin_lsr(b0, 3) == 0b11110) {
            format : &Utf8Format = get_index(&utf8_formats, 4)
            code_point = @bin_or(mask(ext, *get_index(bytes, 3)), @bin_lsl(@tempvar_498(@bin_or(mask(ext, *get_index(bytes, 2)), @bin_lsl(@tempvar_497(@bin_or(mask(ext, *get_index(bytes, 1)), @bin_lsl(@tempvar_496(cast(u32) (@bin_and((*format).mask, *get_index(bytes, 0)))), 6))), 6))), 6))
            byte_count = 4
        } else {}
        return (cast(char32) (code_point), byte_count)
    }
}

#file alloca.che
___chkstk_ms :: ___chkstk_ms() #extern #linkname("___chkstk_ms") #nostacktrace #unused {}

#file thread.che
use import std.mem.allocator

use import std.array

use import std.rc

use import std.ring_queue

io :  : import std.io

C :  : import std.c

use import std.os.windows

use import std.os.windows_functions

use import std.os.windows_constants

use import std.os.windows_types

use import std.os.windows_macros

ThreadHandle :: HANDLE = ^void

MutexHandle :: HANDLE = ^void

#thread_local
current_thread_data : ^ThreadData = null

Thread :: struct { // size: 8, alignment: 8
    data : ^ThreadData
}

ThreadData :: struct { // size: 40, alignment: 8
    handle : ^void
    user : ^void
    func : Fn(^void)
    id : u64
}

impl Thread {
    current() -> ^ThreadData {
        if (cast(^void) (current_thread_data) == null) {
            current_thread_data = alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #anonymous {
                *current_thread_data = new ThreadData { handle = GetCurrentThread(), user = null, func = cast(Fn(^void)) (null), id = cast (GetCurrentThreadId()) }
            }
            #anonymous {}
        } else {}
        return current_thread_data
    }
    
    create(func: Fn(^$T), user_data: ^$T) -> Thread {
        thread_data :  = alloc(ThreadData)
        (thread_data).func = @cast(Fn(^void), func)
        (thread_data).user = @cast(^void, user_data)
        if @is_os("windows") {
            thread_func :  : (data: ) ->  #stdcall {
                thread_data :  = @cast(^ThreadData, data)
                current_thread_data = thread_data
                (thread_data).func((thread_data).user)
                return 0
            }
            (thread_data).handle = CreateThread(null, 0, thread_func, cast (thread_data), 0, null)
            (thread_data).id = cast (GetThreadId((thread_data).handle))
            @assert(((thread_data).handle != null))
        }
        if @is_os("linux") {
            thread_func :  : (data: ) ->  {
                thread_data :  = @cast(^ThreadData, data)
                current_thread_data = thread_data
                (thread_data).func((thread_data).user)
                return null
            }
            {
                attr :  = default
                result :  = pthread_create(^(thread_data).handle, null, thread_func, cast (thread_data))
                (thread_data).id = cast ((thread_data).handle)
            }
        }
        return Thread(thread_data)
    }
    // Polymorphic instances for create(func: Fn(^$T), user_data: ^$T) -> Thread
        /* T = (type, Data) */
        /*  */
        create(func: Fn(^Data), user_data: ^Data) -> Thread {
            thread_data : ^ThreadData = alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            (*thread_data).func = cast(Fn(^void)) (func)
            (*thread_data).user = cast(^void) (user_data)
            #anonymous {
                thread_func :: thread_func(data: ^void) -> u32 #stdcall {
                    thread_data : ^ThreadData = cast(^ThreadData) (data)
                    current_thread_data = thread_data
                    (*thread_data).func((*thread_data).user)
                    return 0
                }
                (*thread_data).handle = CreateThread(null, 0, thread_func, cast (thread_data), 0, null)
                (*thread_data).id = cast (GetThreadId((*thread_data).handle))
                @assert(((*thread_data).handle != null))
            }
            #anonymous {}
            return new Thread { data = thread_data }
        }
    
    
    new(func: Fn()) -> Thread {
        return create_without_data(func)
    }
    
    create_without_data(func: Fn()) -> Thread {
        thread_data : ^ThreadData = alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        (*thread_data).func = cast(Fn(^void)) (func)
        (*thread_data).user = null
        #anonymous {
            thread_func :: thread_func(data: ^void) -> u32 #stdcall {
                thread_data : ^ThreadData = cast(^ThreadData) (data)
                current_thread_data = thread_data
                func : Fn() = cast(Fn()) ((*thread_data).func)
                func()
                return 0
            }
            (*thread_data).handle = CreateThread(null, 0, thread_func, cast (thread_data), 0, null)
            (*thread_data).id = cast (GetThreadId((*thread_data).handle))
            @assert(((*thread_data).handle != null))
        }
        #anonymous {}
        return new Thread { data = thread_data }
    }
    
    join(self: &Thread) {
        #anonymous {
            WaitForSingleObject((*data).handle, INFINITE)
        }
        #anonymous {}
    }
    
    sleep(millis: i64) {
        #anonymous {
            Sleep(cast (millis))
        }
        #anonymous {}
    }
}

impl Drop for Thread {
    drop(self: &Thread) {
        self.join()
    }
}

Mutex :: struct { // size: 8, alignment: 8
    handle : ^void
}

impl Mutex {
    new() -> Mutex {
        #anonymous {
            handle : ^void = CreateMutexA(null, 0, null)
            if (handle == null) {
                @panic("Failed to create mutex")
            } else {}
            return new Mutex { handle = handle }
        }
        #anonymous {}
    }
    
    try_lock(self: &Mutex, timeout: i64) -> bool {
        #anonymous {
            return match @tempvar_499(WaitForSingleObject(handle, cast (timeout))) {
                0x00000000 -> true
                0x00000080 -> true
                0x00000102 -> false
                0xFFFFFFFF -> false
                $_ -> false
            }
        }
        #anonymous {}
    }
    
    lock(self: &Mutex) {
        #anonymous {
            match @tempvar_500(WaitForSingleObject(handle, INFINITE)) {
                0x00000000 -> {}
                0x00000080 -> {}
                0x00000102 -> @panic("failed to lock mutex (time out)")
                0xFFFFFFFF -> {
                    (io).formatln(cast(^any) ("lock failed with windows error code {:x}"), cast([]^any) ([cast(^any) (cast(i64) (GetLastError()))]))
                    @panic("failed to lock mutex")
                }
                $_ -> @panic("failed to lock mutex (unknown error)")
            }
        }
        #anonymous {}
    }
    
    release(self: &Mutex) {
        #anonymous {
            ReleaseMutex(handle)
        }
        #anonymous {}
    }
}

impl Drop for Mutex {
    drop(self: &Mutex) {
        #anonymous {
            CloseHandle((*self).handle)
        }
        #anonymous {}
    }
}

#file rc.che
mem :  : import std.mem.allocator

io :  : import std.io

RcData :: struct { // size: 16, alignment: 8
    count : i64
    internal_count : i64
}

Rc :: struct(T: type) {
    data : 
    value : 
    drop_impl : 
    owns_memory : 
}
// Polymorphic instances for struct(T: type)
    // T = Logger
    struct { // size: 40, alignment: 8
        data : ^RcData
        value : ^Logger
        drop_impl : fn(^Logger)
        owns_memory : bool
    }
    // T = Workspace
    struct { // size: 32, alignment: 8
        data : ^RcData
        value : ^Workspace
        drop_impl : fn(^Workspace)
        owns_memory : bool
    }
    // T = Lexer
    struct { // size: 32, alignment: 8
        data : ^RcData
        value : ^Lexer
        drop_impl : fn(^Lexer)
        owns_memory : bool
    }
    // T = Compiler
    struct { // size: 32, alignment: 8
        data : ^RcData
        value : ^Compiler
        drop_impl : fn(^Compiler)
        owns_memory : bool
    }
    // T = ByteCodeGenerator
    struct { // size: 32, alignment: 8
        data : ^RcData
        value : ^ByteCodeGenerator
        drop_impl : fn(^ByteCodeGenerator)
        owns_memory : bool
    }
    // T = CodeRunner
    struct { // size: 40, alignment: 8
        data : ^RcData
        value : ^CodeRunner
        drop_impl : fn(^CodeRunner)
        owns_memory : bool
    }
    // T = FileLogger
    struct { // size: 32, alignment: 8
        data : ^RcData
        value : ^FileLogger
        drop_impl : fn(^FileLogger)
        owns_memory : bool
    }


Ref :: struct(T: type) {
    data : 
    value : 
    owns_memory : 
}
// Polymorphic instances for struct(T: type)
    // T = Workspace
    struct { // size: 24, alignment: 8
        data : ^RcData
        value : ^Workspace
        owns_memory : bool
    }
    // T = Lexer
    struct { // size: 24, alignment: 8
        data : ^RcData
        value : ^Lexer
        owns_memory : bool
    }
    // T = Compiler
    struct { // size: 24, alignment: 8
        data : ^RcData
        value : ^Compiler
        owns_memory : bool
    }
    // T = FileLogger
    struct { // size: 24, alignment: 8
        data : ^RcData
        value : ^FileLogger
        owns_memory : bool
    }
    // T = CodeRunner
    struct { // size: 32, alignment: 8
        data : ^RcData
        value : ^CodeRunner
        owns_memory : bool
    }
    // T = ByteCodeGenerator
    struct { // size: 24, alignment: 8
        data : ^RcData
        value : ^ByteCodeGenerator
        owns_memory : bool
    }


impl(T: type) Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(T: type) Cheez.Types.Abstract.GenericStructType
    // T = (type, Workspace)
    impl(T: type) Rc[Workspace] {
        empty() -> Rc[Workspace] {
            return new Rc[Workspace] { data = null, value = null, drop_impl = cast(fn(^Workspace)) (null), owns_memory = false }
        }
        
        from_pointer(ptr: ^$K, owned: bool) -> Rc[Workspace] {
            data :  = (mem).alloc(RcData)
            *data = RcData(1, 1)
            drop_impl :  = cast (if (!@is_trait(K) and @type_has_trait(K, Drop)) then (ptr).drop else null)
            return Rc[T](data, cast (ptr), drop_impl, owned)
        }
        
        new(value: $K) -> Rc[Workspace] {
            data :  = (mem).alloc(RcData)
            *data = RcData(1, 1)
            ptr :  = (mem).alloc(K)
            *ptr = value
            drop :  : (ptr: ) {
                (Memory).drop(*ptr)
            }
            drop_impl :  = cast (if (!@is_trait(K) and @type_has_trait(K, Drop)) then drop else null)
            return Rc[T](data, cast (ptr), drop_impl, true)
        }
        // Polymorphic instances for new(value: $K) -> Rc[Workspace]
            /* K = (type, Workspace) */
            /*  */
            new(value: Workspace) -> Rc[Workspace] {
                data : ^RcData = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                *data = new RcData { count = 1, internal_count = 1 }
                ptr : ^Workspace = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                *ptr = value
                drop :: drop(ptr: ^Workspace) {
                    (Memory).drop(*ptr)
                }
                drop_impl : fn(^Workspace) = cast (null)
                return new Rc[Workspace] { data = data, value = ptr, drop_impl = drop_impl, owns_memory = true }
            }
        
        
        borrow(self: &Rc[Workspace]) -> Ref[Workspace] {
            (@tempvar_725(*data)).internal_count = ((@tempvar_725(*data)).internal_count + 1)
            return new Ref[Workspace] { data = data, value = value, owns_memory = owns_memory }
        }
        
        count(self: &Rc[Workspace]) -> i64 {
            @assert((cast(^void) (data) != null))
            return (*data).count
        }
        
        is_null(self: &Rc[Workspace]) -> bool {
            return (cast(^void) (value) == null)
        }
        
        get(self: &Rc[Workspace]) -> &Workspace {
            @assert((cast(^void) (value) != null))
            return &*value
        }
        
        change_type(self: Self, $R: type) -> Rc[R] {
            result :  = Rc[R](data, null, cast (drop_impl), owns_memory)
            if (@is_trait(T) and !@is_trait(R)) {
                (result).value = cast (@ptr_of_trait(value))
            } else {
                (result).value = cast (value)
            }
            data = null
            value = null
            return result
        }
    }
    // T = (type, Lexer)
    impl(T: type) Rc[Lexer] {
        empty() -> Rc[Lexer] {
            return new Rc[Lexer] { data = null, value = null, drop_impl = cast(fn(^Lexer)) (null), owns_memory = false }
        }
        
        from_pointer(ptr: ^$K, owned: bool) -> Rc[Lexer] {
            data :  = (mem).alloc(RcData)
            *data = RcData(1, 1)
            drop_impl :  = cast (if (!@is_trait(K) and @type_has_trait(K, Drop)) then (ptr).drop else null)
            return Rc[T](data, cast (ptr), drop_impl, owned)
        }
        
        new(value: $K) -> Rc[Lexer] {
            data :  = (mem).alloc(RcData)
            *data = RcData(1, 1)
            ptr :  = (mem).alloc(K)
            *ptr = value
            drop :  : (ptr: ) {
                (Memory).drop(*ptr)
            }
            drop_impl :  = cast (if (!@is_trait(K) and @type_has_trait(K, Drop)) then drop else null)
            return Rc[T](data, cast (ptr), drop_impl, true)
        }
        // Polymorphic instances for new(value: $K) -> Rc[Lexer]
            /* K = (type, Lexer) */
            /*  */
            new(value: Lexer) -> Rc[Lexer] {
                data : ^RcData = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                *data = new RcData { count = 1, internal_count = 1 }
                ptr : ^Lexer = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                *ptr = value
                drop :: drop(ptr: ^Lexer) {
                    (Memory).drop(*ptr)
                }
                drop_impl : fn(^Lexer) = cast (null)
                return new Rc[Lexer] { data = data, value = ptr, drop_impl = drop_impl, owns_memory = true }
            }
        
        
        borrow(self: &Rc[Lexer]) -> Ref[Lexer] {
            (@tempvar_730(*data)).internal_count = ((@tempvar_730(*data)).internal_count + 1)
            return new Ref[Lexer] { data = data, value = value, owns_memory = owns_memory }
        }
        
        count(self: &Rc[Lexer]) -> i64 {
            @assert((cast(^void) (data) != null))
            return (*data).count
        }
        
        is_null(self: &Rc[Lexer]) -> bool {
            return (cast(^void) (value) == null)
        }
        
        get(self: &Rc[Lexer]) -> &Lexer {
            @assert((cast(^void) (value) != null))
            return &*value
        }
        
        change_type(self: Self, $R: type) -> Rc[R] {
            result :  = Rc[R](data, null, cast (drop_impl), owns_memory)
            if (@is_trait(T) and !@is_trait(R)) {
                (result).value = cast (@ptr_of_trait(value))
            } else {
                (result).value = cast (value)
            }
            data = null
            value = null
            return result
        }
    }
    // T = (type, Compiler)
    impl(T: type) Rc[Compiler] {
        empty() -> Rc[Compiler] {
            return new Rc[Compiler] { data = null, value = null, drop_impl = cast(fn(^Compiler)) (null), owns_memory = false }
        }
        
        from_pointer(ptr: ^$K, owned: bool) -> Rc[Compiler] {
            data :  = (mem).alloc(RcData)
            *data = RcData(1, 1)
            drop_impl :  = cast (if (!@is_trait(K) and @type_has_trait(K, Drop)) then (ptr).drop else null)
            return Rc[T](data, cast (ptr), drop_impl, owned)
        }
        
        new(value: $K) -> Rc[Compiler] {
            data :  = (mem).alloc(RcData)
            *data = RcData(1, 1)
            ptr :  = (mem).alloc(K)
            *ptr = value
            drop :  : (ptr: ) {
                (Memory).drop(*ptr)
            }
            drop_impl :  = cast (if (!@is_trait(K) and @type_has_trait(K, Drop)) then drop else null)
            return Rc[T](data, cast (ptr), drop_impl, true)
        }
        // Polymorphic instances for new(value: $K) -> Rc[Compiler]
            /* K = (type, Compiler) */
            /*  */
            new(value: Compiler) -> Rc[Compiler] {
                data : ^RcData = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                *data = new RcData { count = 1, internal_count = 1 }
                ptr : ^Compiler = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                *ptr = value
                drop :: drop(ptr: ^Compiler) {
                    (Memory).drop(*ptr)
                }
                drop_impl : fn(^Compiler) = drop
                return new Rc[Compiler] { data = data, value = ptr, drop_impl = drop_impl, owns_memory = true }
            }
        
        
        borrow(self: &Rc[Compiler]) -> Ref[Compiler] {
            (@tempvar_741(*data)).internal_count = ((@tempvar_741(*data)).internal_count + 1)
            return new Ref[Compiler] { data = data, value = value, owns_memory = owns_memory }
        }
        
        count(self: &Rc[Compiler]) -> i64 {
            @assert((cast(^void) (data) != null))
            return (*data).count
        }
        
        is_null(self: &Rc[Compiler]) -> bool {
            return (cast(^void) (value) == null)
        }
        
        get(self: &Rc[Compiler]) -> &Compiler {
            @assert((cast(^void) (value) != null))
            return &*value
        }
        
        change_type(self: Self, $R: type) -> Rc[R] {
            result :  = Rc[R](data, null, cast (drop_impl), owns_memory)
            if (@is_trait(T) and !@is_trait(R)) {
                (result).value = cast (@ptr_of_trait(value))
            } else {
                (result).value = cast (value)
            }
            data = null
            value = null
            return result
        }
    }
    // T = (type, FileLogger)
    impl(T: type) Rc[FileLogger] {
        empty() -> Rc[FileLogger] {
            return new Rc[FileLogger] { data = null, value = null, drop_impl = cast(fn(^FileLogger)) (null), owns_memory = false }
        }
        
        from_pointer(ptr: ^$K, owned: bool) -> Rc[FileLogger] {
            data :  = (mem).alloc(RcData)
            *data = RcData(1, 1)
            drop_impl :  = cast (if (!@is_trait(K) and @type_has_trait(K, Drop)) then (ptr).drop else null)
            return Rc[T](data, cast (ptr), drop_impl, owned)
        }
        
        new(value: $K) -> Rc[FileLogger] {
            data :  = (mem).alloc(RcData)
            *data = RcData(1, 1)
            ptr :  = (mem).alloc(K)
            *ptr = value
            drop :  : (ptr: ) {
                (Memory).drop(*ptr)
            }
            drop_impl :  = cast (if (!@is_trait(K) and @type_has_trait(K, Drop)) then drop else null)
            return Rc[T](data, cast (ptr), drop_impl, true)
        }
        // Polymorphic instances for new(value: $K) -> Rc[FileLogger]
            /* K = (type, FileLogger) */
            /*  */
            new(value: FileLogger) -> Rc[FileLogger] {
                data : ^RcData = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                *data = new RcData { count = 1, internal_count = 1 }
                ptr : ^FileLogger = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                *ptr = value
                drop :: drop(ptr: ^FileLogger) {
                    (Memory).drop(*ptr)
                }
                drop_impl : fn(^FileLogger) = cast (null)
                return new Rc[FileLogger] { data = data, value = ptr, drop_impl = drop_impl, owns_memory = true }
            }
        
        
        borrow(self: &Rc[FileLogger]) -> Ref[FileLogger] {
            (@tempvar_753(*data)).internal_count = ((@tempvar_753(*data)).internal_count + 1)
            return new Ref[FileLogger] { data = data, value = value, owns_memory = owns_memory }
        }
        
        count(self: &Rc[FileLogger]) -> i64 {
            @assert((cast(^void) (data) != null))
            return (*data).count
        }
        
        is_null(self: &Rc[FileLogger]) -> bool {
            return (cast(^void) (value) == null)
        }
        
        get(self: &Rc[FileLogger]) -> &FileLogger {
            @assert((cast(^void) (value) != null))
            return &*value
        }
        
        change_type(self: Self, $R: type) -> Rc[R] {
            result :  = Rc[R](data, null, cast (drop_impl), owns_memory)
            if (@is_trait(T) and !@is_trait(R)) {
                (result).value = cast (@ptr_of_trait(value))
            } else {
                (result).value = cast (value)
            }
            data = null
            value = null
            return result
        }
        // Polymorphic instances for change_type(self: Self, $R: type) -> Rc[R]
            /*  */
            /* R = Logger */
            change_type(self: Rc[FileLogger]) -> Rc[Logger] {
                result : Rc[Logger] = new Rc[Logger] { data = data, value = null, drop_impl = cast (drop_impl), owns_memory = owns_memory }
                #anonymous {
                    (result).value = cast (value)
                }
                data = null
                value = null
                @destruct(self);
                return result
            }
        
    }
    // T = (type, CodeRunner)
    impl(T: type) Rc[CodeRunner] {
        empty() -> Rc[CodeRunner] {
            return new Rc[CodeRunner] { data = null, value = null, drop_impl = cast(fn(^CodeRunner)) (null), owns_memory = false }
        }
        
        from_pointer(ptr: ^$K, owned: bool) -> Rc[CodeRunner] {
            data :  = (mem).alloc(RcData)
            *data = RcData(1, 1)
            drop_impl :  = cast (if (!@is_trait(K) and @type_has_trait(K, Drop)) then (ptr).drop else null)
            return Rc[T](data, cast (ptr), drop_impl, owned)
        }
        
        new(value: $K) -> Rc[CodeRunner] {
            data :  = (mem).alloc(RcData)
            *data = RcData(1, 1)
            ptr :  = (mem).alloc(K)
            *ptr = value
            drop :  : (ptr: ) {
                (Memory).drop(*ptr)
            }
            drop_impl :  = cast (if (!@is_trait(K) and @type_has_trait(K, Drop)) then drop else null)
            return Rc[T](data, cast (ptr), drop_impl, true)
        }
        // Polymorphic instances for new(value: $K) -> Rc[CodeRunner]
            /* K = (type, DefaultCodeRunner) */
            /*  */
            new(value: DefaultCodeRunner) -> Rc[CodeRunner] {
                data : ^RcData = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                *data = new RcData { count = 1, internal_count = 1 }
                ptr : ^DefaultCodeRunner = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                *ptr = value
                drop :: drop(ptr: ^DefaultCodeRunner) {
                    (Memory).drop(*ptr)
                }
                drop_impl : fn(^CodeRunner) = cast (null)
                return new Rc[CodeRunner] { data = data, value = cast (ptr), drop_impl = drop_impl, owns_memory = true }
            }
        
        
        borrow(self: &Rc[CodeRunner]) -> Ref[CodeRunner] {
            (@tempvar_778(*data)).internal_count = ((@tempvar_778(*data)).internal_count + 1)
            return new Ref[CodeRunner] { data = data, value = value, owns_memory = owns_memory }
        }
        
        count(self: &Rc[CodeRunner]) -> i64 {
            @assert((cast(^void) (data) != null))
            return (*data).count
        }
        
        is_null(self: &Rc[CodeRunner]) -> bool {
            return (cast(^void) (value) == null)
        }
        
        get(self: &Rc[CodeRunner]) -> &CodeRunner {
            @assert((cast(^void) (value) != null))
            return &*value
        }
        
        change_type(self: Self, $R: type) -> Rc[R] {
            result :  = Rc[R](data, null, cast (drop_impl), owns_memory)
            if (@is_trait(T) and !@is_trait(R)) {
                (result).value = cast (@ptr_of_trait(value))
            } else {
                (result).value = cast (value)
            }
            data = null
            value = null
            return result
        }
    }
    // T = (type, ByteCodeGenerator)
    impl(T: type) Rc[ByteCodeGenerator] {
        empty() -> Rc[ByteCodeGenerator] {
            return new Rc[ByteCodeGenerator] { data = null, value = null, drop_impl = cast(fn(^ByteCodeGenerator)) (null), owns_memory = false }
        }
        
        from_pointer(ptr: ^$K, owned: bool) -> Rc[ByteCodeGenerator] {
            data :  = (mem).alloc(RcData)
            *data = RcData(1, 1)
            drop_impl :  = cast (if (!@is_trait(K) and @type_has_trait(K, Drop)) then (ptr).drop else null)
            return Rc[T](data, cast (ptr), drop_impl, owned)
        }
        
        new(value: $K) -> Rc[ByteCodeGenerator] {
            data :  = (mem).alloc(RcData)
            *data = RcData(1, 1)
            ptr :  = (mem).alloc(K)
            *ptr = value
            drop :  : (ptr: ) {
                (Memory).drop(*ptr)
            }
            drop_impl :  = cast (if (!@is_trait(K) and @type_has_trait(K, Drop)) then drop else null)
            return Rc[T](data, cast (ptr), drop_impl, true)
        }
        // Polymorphic instances for new(value: $K) -> Rc[ByteCodeGenerator]
            /* K = (type, ByteCodeGenerator) */
            /*  */
            new(value: ByteCodeGenerator) -> Rc[ByteCodeGenerator] {
                data : ^RcData = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                *data = new RcData { count = 1, internal_count = 1 }
                ptr : ^ByteCodeGenerator = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                *ptr = value
                drop :: drop(ptr: ^ByteCodeGenerator) {
                    (Memory).drop(*ptr)
                }
                drop_impl : fn(^ByteCodeGenerator) = cast (null)
                return new Rc[ByteCodeGenerator] { data = data, value = ptr, drop_impl = drop_impl, owns_memory = true }
            }
        
        
        borrow(self: &Rc[ByteCodeGenerator]) -> Ref[ByteCodeGenerator] {
            (@tempvar_785(*data)).internal_count = ((@tempvar_785(*data)).internal_count + 1)
            return new Ref[ByteCodeGenerator] { data = data, value = value, owns_memory = owns_memory }
        }
        
        count(self: &Rc[ByteCodeGenerator]) -> i64 {
            @assert((cast(^void) (data) != null))
            return (*data).count
        }
        
        is_null(self: &Rc[ByteCodeGenerator]) -> bool {
            return (cast(^void) (value) == null)
        }
        
        get(self: &Rc[ByteCodeGenerator]) -> &ByteCodeGenerator {
            @assert((cast(^void) (value) != null))
            return &*value
        }
        
        change_type(self: Self, $R: type) -> Rc[R] {
            result :  = Rc[R](data, null, cast (drop_impl), owns_memory)
            if (@is_trait(T) and !@is_trait(R)) {
                (result).value = cast (@ptr_of_trait(value))
            } else {
                (result).value = cast (value)
            }
            data = null
            value = null
            return result
        }
    }


impl(T: type) Clone for Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(T: type) Clone for Cheez.Types.Abstract.GenericStructType
    // T = (type, Workspace)
    impl(T: type) Clone for Rc[Workspace] {
        clone(self: &Rc[Workspace]) -> Rc[Workspace] {
            (@tempvar_726(*data)).count = ((@tempvar_726(*data)).count + 1)
            (@tempvar_727(*data)).internal_count = ((@tempvar_727(*data)).internal_count + 1)
            return new Rc[Workspace] { data = data, value = value, drop_impl = drop_impl, owns_memory = owns_memory }
        }
    }
    // T = (type, Lexer)
    impl(T: type) Clone for Rc[Lexer] {
        clone(self: &Rc[Lexer]) -> Rc[Lexer] {
            (@tempvar_731(*data)).count = ((@tempvar_731(*data)).count + 1)
            (@tempvar_732(*data)).internal_count = ((@tempvar_732(*data)).internal_count + 1)
            return new Rc[Lexer] { data = data, value = value, drop_impl = drop_impl, owns_memory = owns_memory }
        }
    }
    // T = (type, Compiler)
    impl(T: type) Clone for Rc[Compiler] {
        clone(self: &Rc[Compiler]) -> Rc[Compiler] {
            (@tempvar_742(*data)).count = ((@tempvar_742(*data)).count + 1)
            (@tempvar_743(*data)).internal_count = ((@tempvar_743(*data)).internal_count + 1)
            return new Rc[Compiler] { data = data, value = value, drop_impl = drop_impl, owns_memory = owns_memory }
        }
    }
    // T = (type, FileLogger)
    impl(T: type) Clone for Rc[FileLogger] {
        clone(self: &Rc[FileLogger]) -> Rc[FileLogger] {
            (@tempvar_754(*data)).count = ((@tempvar_754(*data)).count + 1)
            (@tempvar_755(*data)).internal_count = ((@tempvar_755(*data)).internal_count + 1)
            return new Rc[FileLogger] { data = data, value = value, drop_impl = drop_impl, owns_memory = owns_memory }
        }
    }
    // T = (type, CodeRunner)
    impl(T: type) Clone for Rc[CodeRunner] {
        clone(self: &Rc[CodeRunner]) -> Rc[CodeRunner] {
            (@tempvar_779(*data)).count = ((@tempvar_779(*data)).count + 1)
            (@tempvar_780(*data)).internal_count = ((@tempvar_780(*data)).internal_count + 1)
            return new Rc[CodeRunner] { data = data, value = value, drop_impl = drop_impl, owns_memory = owns_memory }
        }
    }
    // T = (type, ByteCodeGenerator)
    impl(T: type) Clone for Rc[ByteCodeGenerator] {
        clone(self: &Rc[ByteCodeGenerator]) -> Rc[ByteCodeGenerator] {
            (@tempvar_786(*data)).count = ((@tempvar_786(*data)).count + 1)
            (@tempvar_787(*data)).internal_count = ((@tempvar_787(*data)).internal_count + 1)
            return new Rc[ByteCodeGenerator] { data = data, value = value, drop_impl = drop_impl, owns_memory = owns_memory }
        }
    }


impl(T: type) Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(T: type) Cheez.Types.Abstract.GenericStructType
    // T = (type, CodeRunner)
    impl(T: type) Ref[CodeRunner] {
        empty() -> Ref[CodeRunner] {
            return new Ref[CodeRunner] { data = null, value = null, owns_memory = false }
        }
        
        count(self: &Ref[CodeRunner]) -> i64 {
            @assert((cast(^void) (data) != null))
            return (*data).count
        }
        
        is_null(self: &Ref[CodeRunner]) -> bool {
            return (cast(^void) (value) == null)
        }
        
        try_get(self: &Ref[CodeRunner]) -> Option[&CodeRunner] {
            return if (cast(^void) (value) == null) then Option[&CodeRunner].None else Option[&CodeRunner].Some(&*value)
        }
        
        get(self: &Ref[CodeRunner]) -> &CodeRunner {
            @assert((cast(^void) (value) != null))
            return &*value
        }
        
        change_type(self: Self, $R: type) -> Ref[R] {
            result :  = Ref[R](data, null, owns_memory)
            if (@is_trait(T) and !@is_trait(R)) {
                (result).value = cast (@ptr_of_trait(value))
            } else {
                (result).value = cast (value)
            }
            data = null
            value = null
            return result
        }
    }
    // T = (type, Compiler)
    impl(T: type) Ref[Compiler] {
        empty() -> Ref[Compiler] {
            return new Ref[Compiler] { data = null, value = null, owns_memory = false }
        }
        
        count(self: &Ref[Compiler]) -> i64 {
            @assert((cast(^void) (data) != null))
            return (*data).count
        }
        
        is_null(self: &Ref[Compiler]) -> bool {
            return (cast(^void) (value) == null)
        }
        
        try_get(self: &Ref[Compiler]) -> Option[&Compiler] {
            return if (cast(^void) (value) == null) then Option[&Compiler].None else Option[&Compiler].Some(&*value)
        }
        
        get(self: &Ref[Compiler]) -> &Compiler {
            @assert((cast(^void) (value) != null))
            return &*value
        }
        
        change_type(self: Self, $R: type) -> Ref[R] {
            result :  = Ref[R](data, null, owns_memory)
            if (@is_trait(T) and !@is_trait(R)) {
                (result).value = cast (@ptr_of_trait(value))
            } else {
                (result).value = cast (value)
            }
            data = null
            value = null
            return result
        }
    }
    // T = (type, Workspace)
    impl(T: type) Ref[Workspace] {
        empty() -> Ref[Workspace] {
            return new Ref[Workspace] { data = null, value = null, owns_memory = false }
        }
        
        count(self: &Ref[Workspace]) -> i64 {
            @assert((cast(^void) (data) != null))
            return (*data).count
        }
        
        is_null(self: &Ref[Workspace]) -> bool {
            return (cast(^void) (value) == null)
        }
        
        try_get(self: &Ref[Workspace]) -> Option[&Workspace] {
            return if (cast(^void) (value) == null) then Option[&Workspace].None else Option[&Workspace].Some(&*value)
        }
        
        get(self: &Ref[Workspace]) -> &Workspace {
            @assert((cast(^void) (value) != null))
            return &*value
        }
        
        change_type(self: Self, $R: type) -> Ref[R] {
            result :  = Ref[R](data, null, owns_memory)
            if (@is_trait(T) and !@is_trait(R)) {
                (result).value = cast (@ptr_of_trait(value))
            } else {
                (result).value = cast (value)
            }
            data = null
            value = null
            return result
        }
    }
    // T = (type, Lexer)
    impl(T: type) Ref[Lexer] {
        empty() -> Ref[Lexer] {
            return new Ref[Lexer] { data = null, value = null, owns_memory = false }
        }
        
        count(self: &Ref[Lexer]) -> i64 {
            @assert((cast(^void) (data) != null))
            return (*data).count
        }
        
        is_null(self: &Ref[Lexer]) -> bool {
            return (cast(^void) (value) == null)
        }
        
        try_get(self: &Ref[Lexer]) -> Option[&Lexer] {
            return if (cast(^void) (value) == null) then Option[&Lexer].None else Option[&Lexer].Some(&*value)
        }
        
        get(self: &Ref[Lexer]) -> &Lexer {
            @assert((cast(^void) (value) != null))
            return &*value
        }
        
        change_type(self: Self, $R: type) -> Ref[R] {
            result :  = Ref[R](data, null, owns_memory)
            if (@is_trait(T) and !@is_trait(R)) {
                (result).value = cast (@ptr_of_trait(value))
            } else {
                (result).value = cast (value)
            }
            data = null
            value = null
            return result
        }
    }


impl(T: type) Clone for Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(T: type) Clone for Cheez.Types.Abstract.GenericStructType
    // T = (type, CodeRunner)
    impl(T: type) Clone for Ref[CodeRunner] {
        clone(self: &Ref[CodeRunner]) -> Ref[CodeRunner] {
            (@tempvar_852(*data)).internal_count = ((@tempvar_852(*data)).internal_count + 1)
            return new Ref[CodeRunner] { data = data, value = value, owns_memory = owns_memory }
        }
    }
    // T = (type, Compiler)
    impl(T: type) Clone for Ref[Compiler] {
        clone(self: &Ref[Compiler]) -> Ref[Compiler] {
            (@tempvar_856(*data)).internal_count = ((@tempvar_856(*data)).internal_count + 1)
            return new Ref[Compiler] { data = data, value = value, owns_memory = owns_memory }
        }
    }
    // T = (type, Workspace)
    impl(T: type) Clone for Ref[Workspace] {
        clone(self: &Ref[Workspace]) -> Ref[Workspace] {
            (@tempvar_858(*data)).internal_count = ((@tempvar_858(*data)).internal_count + 1)
            return new Ref[Workspace] { data = data, value = value, owns_memory = owns_memory }
        }
    }
    // T = (type, Lexer)
    impl(T: type) Clone for Ref[Lexer] {
        clone(self: &Ref[Lexer]) -> Ref[Lexer] {
            (@tempvar_860(*data)).internal_count = ((@tempvar_860(*data)).internal_count + 1)
            return new Ref[Lexer] { data = data, value = value, owns_memory = owns_memory }
        }
    }


impl(T: type) Drop for Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(T: type) Drop for Cheez.Types.Abstract.GenericStructType
    // T = (type, Workspace)
    impl(T: type) Drop for Rc[Workspace] {
        drop(self: &Rc[Workspace]) {
            if (cast(^void) (data) == null) {
                return
            } else {}
            @assert(((*data).count > 0))
            (@tempvar_728(*data)).count = ((@tempvar_728(*data)).count - 1)
            (@tempvar_729(*data)).internal_count = ((@tempvar_729(*data)).internal_count - 1)
            if (((*data).count == 0) and (drop_impl != null)) {
                drop_impl(value)
            } else {}
            if (owns_memory and ((*data).internal_count == 0)) {
                (mem).free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            } else {}
        }
    }
    // T = (type, Lexer)
    impl(T: type) Drop for Rc[Lexer] {
        drop(self: &Rc[Lexer]) {
            if (cast(^void) (data) == null) {
                return
            } else {}
            @assert(((*data).count > 0))
            (@tempvar_733(*data)).count = ((@tempvar_733(*data)).count - 1)
            (@tempvar_734(*data)).internal_count = ((@tempvar_734(*data)).internal_count - 1)
            if (((*data).count == 0) and (drop_impl != null)) {
                drop_impl(value)
            } else {}
            if (owns_memory and ((*data).internal_count == 0)) {
                (mem).free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            } else {}
        }
    }
    // T = (type, Compiler)
    impl(T: type) Drop for Rc[Compiler] {
        drop(self: &Rc[Compiler]) {
            if (cast(^void) (data) == null) {
                return
            } else {}
            @assert(((*data).count > 0))
            (@tempvar_744(*data)).count = ((@tempvar_744(*data)).count - 1)
            (@tempvar_745(*data)).internal_count = ((@tempvar_745(*data)).internal_count - 1)
            if (((*data).count == 0) and (drop_impl != null)) {
                drop_impl(value)
            } else {}
            if (owns_memory and ((*data).internal_count == 0)) {
                (mem).free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            } else {}
        }
    }
    // T = (type, FileLogger)
    impl(T: type) Drop for Rc[FileLogger] {
        drop(self: &Rc[FileLogger]) {
            if (cast(^void) (data) == null) {
                return
            } else {}
            @assert(((*data).count > 0))
            (@tempvar_756(*data)).count = ((@tempvar_756(*data)).count - 1)
            (@tempvar_757(*data)).internal_count = ((@tempvar_757(*data)).internal_count - 1)
            if (((*data).count == 0) and (drop_impl != null)) {
                drop_impl(value)
            } else {}
            if (owns_memory and ((*data).internal_count == 0)) {
                (mem).free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            } else {}
        }
    }
    // T = (type, CodeRunner)
    impl(T: type) Drop for Rc[CodeRunner] {
        drop(self: &Rc[CodeRunner]) {
            if (cast(^void) (data) == null) {
                return
            } else {}
            @assert(((*data).count > 0))
            (@tempvar_781(*data)).count = ((@tempvar_781(*data)).count - 1)
            (@tempvar_782(*data)).internal_count = ((@tempvar_782(*data)).internal_count - 1)
            if (((*data).count == 0) and (drop_impl != null)) {
                drop_impl(value)
            } else {}
            if (owns_memory and ((*data).internal_count == 0)) {
                (mem).free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            } else {}
        }
    }
    // T = (type, ByteCodeGenerator)
    impl(T: type) Drop for Rc[ByteCodeGenerator] {
        drop(self: &Rc[ByteCodeGenerator]) {
            if (cast(^void) (data) == null) {
                return
            } else {}
            @assert(((*data).count > 0))
            (@tempvar_788(*data)).count = ((@tempvar_788(*data)).count - 1)
            (@tempvar_789(*data)).internal_count = ((@tempvar_789(*data)).internal_count - 1)
            if (((*data).count == 0) and (drop_impl != null)) {
                drop_impl(value)
            } else {}
            if (owns_memory and ((*data).internal_count == 0)) {
                (mem).free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            } else {}
        }
    }


impl(T: type) Drop for Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(T: type) Drop for Cheez.Types.Abstract.GenericStructType
    // T = (type, CodeRunner)
    impl(T: type) Drop for Ref[CodeRunner] {
        drop(self: &Ref[CodeRunner]) {
            if (cast(^void) (data) == null) {
                return
            } else {}
            @assert(((*data).internal_count > 0))
            (@tempvar_853(*data)).internal_count = ((@tempvar_853(*data)).internal_count - 1)
            if (((*data).internal_count == 0) and owns_memory) {
                (mem).free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            } else {}
        }
    }
    // T = (type, Compiler)
    impl(T: type) Drop for Ref[Compiler] {
        drop(self: &Ref[Compiler]) {
            if (cast(^void) (data) == null) {
                return
            } else {}
            @assert(((*data).internal_count > 0))
            (@tempvar_857(*data)).internal_count = ((@tempvar_857(*data)).internal_count - 1)
            if (((*data).internal_count == 0) and owns_memory) {
                (mem).free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            } else {}
        }
    }
    // T = (type, Workspace)
    impl(T: type) Drop for Ref[Workspace] {
        drop(self: &Ref[Workspace]) {
            if (cast(^void) (data) == null) {
                return
            } else {}
            @assert(((*data).internal_count > 0))
            (@tempvar_859(*data)).internal_count = ((@tempvar_859(*data)).internal_count - 1)
            if (((*data).internal_count == 0) and owns_memory) {
                (mem).free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            } else {}
        }
    }
    // T = (type, Lexer)
    impl(T: type) Drop for Ref[Lexer] {
        drop(self: &Ref[Lexer]) {
            if (cast(^void) (data) == null) {
                return
            } else {}
            @assert(((*data).internal_count > 0))
            (@tempvar_861(*data)).internal_count = ((@tempvar_861(*data)).internal_count - 1)
            if (((*data).internal_count == 0) and owns_memory) {
                (mem).free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            } else {}
        }
    }


#file fiber.che
mem :  : import std.mem.allocator

util :  : import std.util

use import std.os.windows

use import std.os.windows_functions

use import std.os.windows_constants

use import std.os.windows_types

use import std.os.windows_macros

Fiber :: struct { // size: 40, alignment: 8
    ptr : ^void
    parent : ^Fiber = null
    func : Fn(^void)
    user_data : ^void
}

impl Drop for Fiber {
    drop(self: &Fiber) {
        #anonymous {
            DeleteFiber(ptr)
        }
    }
}

impl Fiber {
    init() {
        f : ^Fiber = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        #anonymous {
            *f = new Fiber { ptr = ConvertThreadToFiber(cast(^void) (f)), parent = null, func = cast(Fn(^void)) (null), user_data = null }
        }
        #anonymous {}
    }
    
    new(func: Fn(^$T), user_data: ^T, stack_size: int) -> ^Fiber {
        if @is_os("windows") {
            fiber_func :  : (param: ) #stdcall #nostacktrace {
                f :  = cast() (param)
                (f).func((f).user_data)
                loop {
                    if !true then break
                    (Fiber).yield()
                }
            }
            f :  = (mem).alloc(Fiber)
            (f).ptr = CreateFiber(cast (stack_size), fiber_func, cast (f))
            (f).func = cast (func)
            (f).parent = current()
            (f).user_data = user_data
            return f
        }
        if @is_os("linux") {
            fiber_func :  : (param: ) #nostacktrace {
                f :  = cast() (param)
                (f).func((f).user_data)
            }
            raw_mem :  = (mem).alloc_raw(u8, cast ((@sizeof(Fiber) + stack_size)))
            fiber :  = cast() (raw_mem)
            (fiber).parent = null
            (fiber).func = cast (func)
            (fiber).user_data = user_data
            stack_base :  = (util).pointer_add(raw_mem, cast ((@sizeof(Fiber) + stack_size)))
            stack_aligned :  = @bin_and(u64(stack_base), @bin_not(15u64))
            (fiber).rsp = (stack_aligned - 32)
            guard_var :  = __fiber_guard
            *cast() (((fiber).rsp + 8)) = *cast() (^guard_var)
            fiber_func_var :  = fiber_func
            *cast() ((fiber).rsp) = *cast() (^fiber_func_var)
            (fiber).rdi = u64(fiber)
            return fiber
        }
    }
    // Polymorphic instances for new(func: Fn(^$T), user_data: ^T, stack_size: int) -> ^Fiber
        /* T = (type, FiberContext) */
        /*  */
        new(func: Fn(^FiberContext), user_data: ^FiberContext = null, stack_size: i64 = (1024 * 1024)) -> ^Fiber {
            #anonymous {
                fiber_func :: fiber_func(param: ^void) #stdcall #nostacktrace {
                    f : ^Fiber = cast(^Fiber) (param)
                    (*f).func((*f).user_data)
                    loop {
                        if !true then break else {}
                        (Fiber).yield()
                    }
                }
                f : ^Fiber = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                (*f).ptr = CreateFiber(stack_size, fiber_func, cast (f))
                (*f).func = cast (func)
                (*f).parent = current()
                (*f).user_data = cast(^void) (user_data)
                return f
            }
            #anonymous {}
        }
    
    
    to_func(self: &Fiber) -> Fn() {
        return cast (self.resume)
    }
    
    resume(self: &Fiber) #nostacktrace {
        #anonymous {
            (*self).parent = current()
            SwitchToFiber((*self).ptr)
        }
        #anonymous {}
    }
    
    yield() #nostacktrace {
        #anonymous {
            f : ^Fiber = current()
            if (cast(^void) ((*f).parent) == null) {
                @panic("Can't yield from a fiber without parent")
            } else {
                SwitchToFiber((*(*f).parent).ptr)
            }
        }
        #anonymous {}
    }
    
    current() -> ^Fiber {
        #anonymous {
            return cast (GetFiberData())
        }
        #anonymous {}
    }
    
    user_data($T: type) -> ^T {
        return cast() (((Fiber).current()).user_data)
    }
    // Polymorphic instances for user_data($T: type) -> ^T
        /*  */
        /* T = FiberContext */
        user_data() -> ^FiberContext {
            return cast(^FiberContext) ((*(Fiber).current()).user_data)
        }
    
}

#file map.che
use import std.mem.allocator

use import std.mem.std_heap_allocator

use import std.hash

use import std.iterator

C :  : import std.c

io :  : import std.io

Map :: struct(K: type, V: type) {
    max_load : 
    _count : 
    entries : 
    allocator : 
}
// Polymorphic instances for struct(K: type, V: type)
    // K = i64, V = ^AstStruct
    struct { // size: 48, alignment: 8
        max_load : f64
        _count : u64
        entries : []Entry[i64, ^AstStruct]
        allocator : ^Allocator
    }
    // K = string, V = SourceFile
    struct { // size: 48, alignment: 8
        max_load : f64
        _count : u64
        entries : []Entry[string, SourceFile]
        allocator : ^Allocator
    }
    // K = FunctionTypeWrapper, V = fn(fn(), ^Interpreter)
    struct { // size: 48, alignment: 8
        max_load : f64
        _count : u64
        entries : []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]
        allocator : ^Allocator
    }
    // K = string, V = String
    struct { // size: 48, alignment: 8
        max_load : f64
        _count : u64
        entries : []Entry[string, String]
        allocator : ^Allocator
    }
    // K = string, V = Symbol
    struct { // size: 48, alignment: 8
        max_load : f64
        _count : u64
        entries : []Entry[string, Symbol]
        allocator : ^Allocator
    }
    // K = TypeId, V = Array[^AstImpl]
    struct { // size: 48, alignment: 8
        max_load : f64
        _count : u64
        entries : []Entry[TypeId, Array[^AstImpl]]
        allocator : ^Allocator
    }
    // K = i64, V = i64
    struct { // size: 48, alignment: 8
        max_load : f64
        _count : u64
        entries : []Entry[i64, i64]
        allocator : ^Allocator
    }


impl(K: type, V: type) Drop for Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(K: type, V: type) Drop for Cheez.Types.Abstract.GenericStructType
    // K = (type, i64), V = (type, ^AstStruct)
    impl(K: type, V: type) Drop for Map[i64, ^AstStruct] {
        drop(self: &Map[i64, ^AstStruct]) {
            if (cast(^void) ((entries).data) != null) {
                #macro {
                    local arr : []Entry[i64, ^AstStruct] = entries
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &Entry[i64, ^AstStruct] = get_index(arr, it_index)
                                #link #anonymous {
                                    e : &Entry[i64, ^AstStruct] = it
                                    _ : i64 = it_index
                                    {
                                        if (*e).filled then (Memory).drop((*e).value <- Option[^AstStruct].None) else {}
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
        }
    }
    // K = (type, string), V = (type, SourceFile)
    impl(K: type, V: type) Drop for Map[string, SourceFile] {
        drop(self: &Map[string, SourceFile]) {
            if (cast(^void) ((entries).data) != null) {
                #macro {
                    local arr : []Entry[string, SourceFile] = entries
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &Entry[string, SourceFile] = get_index(arr, it_index)
                                #link #anonymous {
                                    e : &Entry[string, SourceFile] = it
                                    _ : i64 = it_index
                                    {
                                        if (*e).filled then (Memory).drop((*e).value <- Option[SourceFile].None) else {}
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
        }
    }
    // K = (type, FunctionTypeWrapper), V = (type, fn(fn(), ^Interpreter))
    impl(K: type, V: type) Drop for Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)] {
        drop(self: &Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)]) {
            if (cast(^void) ((entries).data) != null) {
                #macro {
                    local arr : []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = entries
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = get_index(arr, it_index)
                                #link #anonymous {
                                    e : &Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = it
                                    _ : i64 = it_index
                                    {
                                        if (*e).filled then (Memory).drop((*e).value <- Option[fn(fn(), ^Interpreter)].None) else {}
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
        }
    }
    // K = (type, string), V = (type, String)
    impl(K: type, V: type) Drop for Map[string, String] {
        drop(self: &Map[string, String]) {
            if (cast(^void) ((entries).data) != null) {
                #macro {
                    local arr : []Entry[string, String] = entries
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &Entry[string, String] = get_index(arr, it_index)
                                #link #anonymous {
                                    e : &Entry[string, String] = it
                                    _ : i64 = it_index
                                    {
                                        if (*e).filled then (Memory).drop((*e).value <- Option[String].None) else {}
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
        }
    }
    // K = (type, string), V = (type, Symbol)
    impl(K: type, V: type) Drop for Map[string, Symbol] {
        drop(self: &Map[string, Symbol]) {
            if (cast(^void) ((entries).data) != null) {
                #macro {
                    local arr : []Entry[string, Symbol] = entries
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &Entry[string, Symbol] = get_index(arr, it_index)
                                #link #anonymous {
                                    e : &Entry[string, Symbol] = it
                                    _ : i64 = it_index
                                    {
                                        if (*e).filled then (Memory).drop((*e).value <- Option[Symbol].None) else {}
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
        }
    }
    // K = (type, i64), V = (type, i64)
    impl(K: type, V: type) Drop for Map[i64, i64] {
        drop(self: &Map[i64, i64]) {
            if (cast(^void) ((entries).data) != null) {
                #macro {
                    local arr : []Entry[i64, i64] = entries
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &Entry[i64, i64] = get_index(arr, it_index)
                                #link #anonymous {
                                    e : &Entry[i64, i64] = it
                                    _ : i64 = it_index
                                    {
                                        if (*e).filled then (Memory).drop((*e).value <- Option[i64].None) else {}
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
        }
    }
    // K = (type, TypeId), V = (type, Array[^AstImpl])
    impl(K: type, V: type) Drop for Map[TypeId, Array[^AstImpl]] {
        drop(self: &Map[TypeId, Array[^AstImpl]]) {
            if (cast(^void) ((entries).data) != null) {
                #macro {
                    local arr : []Entry[TypeId, Array[^AstImpl]] = entries
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &Entry[TypeId, Array[^AstImpl]] = get_index(arr, it_index)
                                #link #anonymous {
                                    e : &Entry[TypeId, Array[^AstImpl]] = it
                                    _ : i64 = it_index
                                    {
                                        if (*e).filled then (Memory).drop((*e).value <- Option[Array[^AstImpl]].None) else {}
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
        }
    }


impl(K: type, V: type) Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(K: type, V: type) Cheez.Types.Abstract.GenericStructType
    // K = (type, i64), V = (type, ^AstStruct)
    impl(K: type, V: type) Map[i64, ^AstStruct] {
        new(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Map[i64, ^AstStruct] {
            #anonymous {}
            return new Map[i64, ^AstStruct] { allocator = allocator, max_load = 0.75, _count = 0, entries = null }
        }
        
        clear(self: &Map[i64, ^AstStruct]) {
            #macro {
                local arr : []Entry[i64, ^AstStruct] = entries
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &Entry[i64, ^AstStruct] = get_index(arr, it_index)
                            #link #anonymous {
                                entry : &Entry[i64, ^AstStruct] = it
                                it_index : i64 = it_index
                                {
                                    (*entry).filled = false
                                    (*entry).is_tombstone = false
                                    (*entry).key = Option[i64].None
                                    (*entry).value = Option[^AstStruct].None
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            _count = 0
        }
        
        empty(self: &Map[i64, ^AstStruct]) -> bool {
            return (_count == 0)
        }
        
        count(self: &Map[i64, ^AstStruct]) -> i64 {
            return cast (_count)
        }
        
        get_entries(self: &Map[i64, ^AstStruct]) -> []Entry[i64, ^AstStruct] {
            return entries
        }
        
        contains(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return false
            }
            return true
        }
        
        find_entry(self: &Self, the_entries: []Entry[i64, ^AstStruct], key: &$K2) -> ^Entry[i64, ^AstStruct] {
            if !@type_has_trait(K, Equatable[K2]) {
                @static_assert(false, (("Key of map must implment Equatable[" + @typename(K2)) + "]"))
            }
            index :  = ((key).hash() % cast() ((the_entries).length))
            tombstone :  = null
            loop {
                if !true then break
                entry :  = the_entries[int(index)]
                if !(entry).filled {
                    if !(entry).is_tombstone {
                        if (tombstone != null) {
                            return tombstone
                        } else {
                            return ^*entry
                        }
                    } else if (tombstone == null) {
                        tombstone = ^*entry
                    }
                } else {
                    if (@impl(K, Equatable[K2])).equal(&((entry).key).Some, key) {
                        return ^*entry
                    }
                }
                index = ((index + 1) % cast() ((the_entries).length))
            }
            return null
        }
        // Polymorphic instances for find_entry(self: &Self, the_entries: []Entry[i64, ^AstStruct], key: &$K2) -> ^Entry[i64, ^AstStruct]
            /* K2 = (type, i64) */
            /*  */
            find_entry(self: &Map[i64, ^AstStruct], the_entries: []Entry[i64, ^AstStruct], key: &i64) -> ^Entry[i64, ^AstStruct] {
                #anonymous {}
                index : u64 = (key.hash() % cast(u64) ((the_entries).length))
                tombstone : ^Entry[i64, ^AstStruct] = null
                loop {
                    if !true then break else {}
                    entry : &Entry[i64, ^AstStruct] = get_index(the_entries, cast(i64) (index))
                    if !(*entry).filled {
                        if !(*entry).is_tombstone {
                            if (cast(^void) (tombstone) != null) {
                                return tombstone
                            } else {
                                return ^*entry
                            }
                        } else if (cast(^void) (tombstone) == null) {
                            tombstone = ^*entry
                        } else {}
                    } else {
                        if (@impl(i64, Equatable[i64])).equal(&((*entry).key).Some, key) {
                            return ^*entry
                        } else {}
                    }
                    index = ((index + 1) % cast(u64) ((the_entries).length))
                }
                return null
            }
        
        
        set(self: &Self, key: $K2, value: ^AstStruct) -> bool {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            if (cast() ((_count + 1)) > (cast() ((entries).length) * max_load)) {
                adjust_capacity(cast() (((entries).length * 2)))
            }
            entry :  = find_entry(entries, &key)
            is_new_key :  = !(entry).filled
            (entry).key = Some(convert(K, &key))
            (entry).value = Some(value)
            (entry).filled = true
            (entry).is_tombstone = false
            if is_new_key {
                _count = 1
            }
            return is_new_key
        }
        // Polymorphic instances for set(self: &Self, key: $K2, value: ^AstStruct) -> bool
            /* K2 = (type, i64) */
            /*  */
            set(self: &Map[i64, ^AstStruct], key: i64, value: ^AstStruct) -> bool #operator("set[]") {
                if (cast(^void) ((entries).data) == null) {
                    self.adjust_capacity(13)
                } else {}
                if (cast(f64) ((_count + 1)) > (cast(f64) ((entries).length) * max_load)) {
                    self.adjust_capacity(cast(u64) (((entries).length * 2)))
                } else {}
                entry : ^Entry[i64, ^AstStruct] = self.find_entry(entries, &key)
                is_new_key : bool = !(*entry).filled
                (*entry).key = Option[i64].Some(#macro {
                    local T :: i64 = i64
                    local c : &i64 = &key
                    *c
                })
                (*entry).value = Option[^AstStruct].Some(value)
                (*entry).filled = true
                (*entry).is_tombstone = false
                if is_new_key {
                    _count = (_count + 1)
                } else {}
                return is_new_key
            }
        
        
        get(self: &Self, key: $K2) -> Option[&^AstStruct] {
            if ((entries).data == null) {
                return None
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return None
            }
            return match &(entry).value {
                Some($val) -> Some(val)
                None -> None
            }
        }
        // Polymorphic instances for get(self: &Self, key: $K2) -> Option[&^AstStruct]
            /* K2 = (type, i64) */
            /*  */
            get(self: &Map[i64, ^AstStruct], key: i64) -> Option[&^AstStruct] {
                if (cast(^void) ((entries).data) == null) {
                    return Option[&^AstStruct].None
                } else {}
                entry : ^Entry[i64, ^AstStruct] = self.find_entry(entries, &key)
                if !(*entry).filled {
                    return Option[&^AstStruct].None
                } else {}
                return match @tempvar_775(&(*entry).value) {
                    Option[^AstStruct].Some($val) -> Option[&^AstStruct].Some(val)
                    Option[^AstStruct].None -> Option[&^AstStruct].None
                }
            }
        
        
        get_or_insert(self: &Self, key: $K2, value_creator: fn() -> ^AstStruct) -> &^AstStruct {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                (entry).key = Some(convert(K, &key))
                (entry).value = Some(value_creator())
                (entry).filled = true
                (entry).is_tombstone = false
                _count = 1
            }
            return match &(entry).value {
                Some($val) -> val
                None -> @assert(false)
            }
        }
        
        get_unchecked(self: &Self, key: $K2) -> &^AstStruct {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        
        at(self: &Self, key: $K2) -> &^AstStruct {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        
        delete(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, key)
            if !(entry).filled {
                return false
            }
            (entry).filled = false
            (entry).key = None
            (entry).value = None
            (entry).is_tombstone = true
            _count = 1
            return true
        }
        
        adjust_capacity(self: &Map[i64, ^AstStruct], cap: u64) {
            entries_new : []Entry[i64, ^AstStruct] = alloc_n(cap, allocator)
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = (entries_new).length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_311) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_311))[0]
                    it_index : i64 = @var(@id((it, it_index)_311))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                (*get_index(entries_new, i)).filled = false
                                (*get_index(entries_new, i)).is_tombstone = false
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            if (cast(^void) ((entries).data) != null) {
                _count = 0
                #macro {
                    local r : Range[i64] = new Range[i64] { start = 0, end = (entries).length }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_313) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_313))[0]
                        it_index : i64 = @var(@id((it, it_index)_313))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                i : i64 = it
                                it_index : i64 = it_index
                                {
                                    entry : &Entry[i64, ^AstStruct] = get_index(entries, i)
                                    if (*entry).filled {
                                        dest : ^Entry[i64, ^AstStruct] = self.find_entry(entries_new, &((*entry).key).Some)
                                        (*dest).key = (*entry).key <- Option[i64].None
                                        (*dest).value = (*entry).value <- Option[^AstStruct].None
                                        (*dest).filled = true
                                        _count = (_count + 1)
                                    } else {}
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
            entries = entries_new
        }
        
        iterator(self: &Map[i64, ^AstStruct]) -> MapIterator[i64, ^AstStruct] {
            return new MapIterator[i64, ^AstStruct] { table = self, index = 0 }
        }
    }
    // K = (type, string), V = (type, SourceFile)
    impl(K: type, V: type) Map[string, SourceFile] {
        new(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Map[string, SourceFile] {
            #anonymous {}
            return new Map[string, SourceFile] { allocator = allocator, max_load = 0.75, _count = 0, entries = null }
        }
        
        clear(self: &Map[string, SourceFile]) {
            #macro {
                local arr : []Entry[string, SourceFile] = entries
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &Entry[string, SourceFile] = get_index(arr, it_index)
                            #link #anonymous {
                                entry : &Entry[string, SourceFile] = it
                                it_index : i64 = it_index
                                {
                                    (*entry).filled = false
                                    (*entry).is_tombstone = false
                                    (*entry).key = Option[string].None
                                    @destruct((*entry).value);
                                    (*entry).value = Option[SourceFile].None
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            _count = 0
        }
        
        empty(self: &Map[string, SourceFile]) -> bool {
            return (_count == 0)
        }
        
        count(self: &Map[string, SourceFile]) -> i64 {
            return cast (_count)
        }
        
        get_entries(self: &Map[string, SourceFile]) -> []Entry[string, SourceFile] {
            return entries
        }
        
        contains(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return false
            }
            return true
        }
        
        find_entry(self: &Self, the_entries: []Entry[string, SourceFile], key: &$K2) -> ^Entry[string, SourceFile] {
            if !@type_has_trait(K, Equatable[K2]) {
                @static_assert(false, (("Key of map must implment Equatable[" + @typename(K2)) + "]"))
            }
            index :  = ((key).hash() % cast() ((the_entries).length))
            tombstone :  = null
            loop {
                if !true then break
                entry :  = the_entries[int(index)]
                if !(entry).filled {
                    if !(entry).is_tombstone {
                        if (tombstone != null) {
                            return tombstone
                        } else {
                            return ^*entry
                        }
                    } else if (tombstone == null) {
                        tombstone = ^*entry
                    }
                } else {
                    if (@impl(K, Equatable[K2])).equal(&((entry).key).Some, key) {
                        return ^*entry
                    }
                }
                index = ((index + 1) % cast() ((the_entries).length))
            }
            return null
        }
        // Polymorphic instances for find_entry(self: &Self, the_entries: []Entry[string, SourceFile], key: &$K2) -> ^Entry[string, SourceFile]
            /* K2 = (type, string) */
            /*  */
            find_entry(self: &Map[string, SourceFile], the_entries: []Entry[string, SourceFile], key: &string) -> ^Entry[string, SourceFile] {
                #anonymous {}
                index : u64 = (key.hash() % cast(u64) ((the_entries).length))
                tombstone : ^Entry[string, SourceFile] = null
                loop {
                    if !true then break else {}
                    entry : &Entry[string, SourceFile] = get_index(the_entries, cast(i64) (index))
                    if !(*entry).filled {
                        if !(*entry).is_tombstone {
                            if (cast(^void) (tombstone) != null) {
                                return tombstone
                            } else {
                                return ^*entry
                            }
                        } else if (cast(^void) (tombstone) == null) {
                            tombstone = ^*entry
                        } else {}
                    } else {
                        if (@impl(string, Equatable[string])).equal(&((*entry).key).Some, key) {
                            return ^*entry
                        } else {}
                    }
                    index = ((index + 1) % cast(u64) ((the_entries).length))
                }
                return null
            }
        
        
        set(self: &Self, key: $K2, value: SourceFile) -> bool {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            if (cast() ((_count + 1)) > (cast() ((entries).length) * max_load)) {
                adjust_capacity(cast() (((entries).length * 2)))
            }
            entry :  = find_entry(entries, &key)
            is_new_key :  = !(entry).filled
            (entry).key = Some(convert(K, &key))
            (entry).value = Some(value)
            (entry).filled = true
            (entry).is_tombstone = false
            if is_new_key {
                _count = 1
            }
            return is_new_key
        }
        // Polymorphic instances for set(self: &Self, key: $K2, value: SourceFile) -> bool
            /* K2 = (type, string) */
            /*  */
            set(self: &Map[string, SourceFile], key: string, value: SourceFile) -> bool #operator("set[]") {
                if (cast(^void) ((entries).data) == null) {
                    self.adjust_capacity(13)
                } else {}
                if (cast(f64) ((_count + 1)) > (cast(f64) ((entries).length) * max_load)) {
                    self.adjust_capacity(cast(u64) (((entries).length * 2)))
                } else {}
                entry : ^Entry[string, SourceFile] = self.find_entry(entries, &key)
                is_new_key : bool = !(*entry).filled
                (*entry).key = Option[string].Some(#macro {
                    local T :: string = string
                    local c : &string = &key
                    *c
                })
                @destruct((*entry).value);
                (*entry).value = Option[SourceFile].Some(value)
                (*entry).filled = true
                (*entry).is_tombstone = false
                if is_new_key {
                    _count = (_count + 1)
                } else {}
                return is_new_key
            }
        
        
        get(self: &Self, key: $K2) -> Option[&SourceFile] {
            if ((entries).data == null) {
                return None
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return None
            }
            return match &(entry).value {
                Some($val) -> Some(val)
                None -> None
            }
        }
        // Polymorphic instances for get(self: &Self, key: $K2) -> Option[&SourceFile]
            /* K2 = (type, string) */
            /*  */
            get(self: &Map[string, SourceFile], key: string) -> Option[&SourceFile] {
                if (cast(^void) ((entries).data) == null) {
                    return Option[&SourceFile].None
                } else {}
                entry : ^Entry[string, SourceFile] = self.find_entry(entries, &key)
                if !(*entry).filled {
                    return Option[&SourceFile].None
                } else {}
                return match @tempvar_768(&(*entry).value) {
                    Option[SourceFile].Some($val) -> Option[&SourceFile].Some(val)
                    Option[SourceFile].None -> Option[&SourceFile].None
                }
            }
        
        
        get_or_insert(self: &Self, key: $K2, value_creator: fn() -> SourceFile) -> &SourceFile {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                (entry).key = Some(convert(K, &key))
                (entry).value = Some(value_creator())
                (entry).filled = true
                (entry).is_tombstone = false
                _count = 1
            }
            return match &(entry).value {
                Some($val) -> val
                None -> @assert(false)
            }
        }
        
        get_unchecked(self: &Self, key: $K2) -> &SourceFile {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        
        at(self: &Self, key: $K2) -> &SourceFile {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        // Polymorphic instances for at(self: &Self, key: $K2) -> &SourceFile
            /* K2 = (type, string) */
            /*  */
            at(self: &Map[string, SourceFile], key: string) -> &SourceFile {
                entry : ^Entry[string, SourceFile] = self.find_entry(entries, &key)
                @assert((*entry).filled)
                return &((*entry).value).Some
            }
        
        
        delete(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, key)
            if !(entry).filled {
                return false
            }
            (entry).filled = false
            (entry).key = None
            (entry).value = None
            (entry).is_tombstone = true
            _count = 1
            return true
        }
        
        adjust_capacity(self: &Map[string, SourceFile], cap: u64) {
            entries_new : []Entry[string, SourceFile] = alloc_n(cap, allocator)
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = (entries_new).length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_317) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_317))[0]
                    it_index : i64 = @var(@id((it, it_index)_317))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                (*get_index(entries_new, i)).filled = false
                                (*get_index(entries_new, i)).is_tombstone = false
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            if (cast(^void) ((entries).data) != null) {
                _count = 0
                #macro {
                    local r : Range[i64] = new Range[i64] { start = 0, end = (entries).length }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_319) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_319))[0]
                        it_index : i64 = @var(@id((it, it_index)_319))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                i : i64 = it
                                it_index : i64 = it_index
                                {
                                    entry : &Entry[string, SourceFile] = get_index(entries, i)
                                    if (*entry).filled {
                                        dest : ^Entry[string, SourceFile] = self.find_entry(entries_new, &((*entry).key).Some)
                                        (*dest).key = (*entry).key <- Option[string].None
                                        @destruct((*dest).value);
                                        (*dest).value = (*entry).value <- Option[SourceFile].None
                                        (*dest).filled = true
                                        _count = (_count + 1)
                                    } else {}
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
            entries = entries_new
        }
        
        iterator(self: &Map[string, SourceFile]) -> MapIterator[string, SourceFile] {
            return new MapIterator[string, SourceFile] { table = self, index = 0 }
        }
    }
    // K = (type, FunctionTypeWrapper), V = (type, fn(fn(), ^Interpreter))
    impl(K: type, V: type) Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)] {
        new(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)] {
            #anonymous {}
            return new Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)] { allocator = allocator, max_load = 0.75, _count = 0, entries = null }
        }
        
        clear(self: &Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)]) {
            #macro {
                local arr : []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = entries
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = get_index(arr, it_index)
                            #link #anonymous {
                                entry : &Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = it
                                it_index : i64 = it_index
                                {
                                    (*entry).filled = false
                                    (*entry).is_tombstone = false
                                    (*entry).key = Option[FunctionTypeWrapper].None
                                    (*entry).value = Option[fn(fn(), ^Interpreter)].None
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            _count = 0
        }
        
        empty(self: &Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)]) -> bool {
            return (_count == 0)
        }
        
        count(self: &Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)]) -> i64 {
            return cast (_count)
        }
        
        get_entries(self: &Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)]) -> []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] {
            return entries
        }
        
        contains(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return false
            }
            return true
        }
        // Polymorphic instances for contains(self: &Self, key: $K2) -> bool
            /* K2 = (type, FunctionTypeWrapper) */
            /*  */
            contains(self: &Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)], key: FunctionTypeWrapper) -> bool {
                if ((_count == 0) or (cast(^void) ((entries).data) == null)) {
                    return false
                } else {}
                entry : ^Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = self.find_entry(entries, &key)
                if !(*entry).filled {
                    return false
                } else {}
                return true
            }
        
        
        find_entry(self: &Self, the_entries: []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], key: &$K2) -> ^Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] {
            if !@type_has_trait(K, Equatable[K2]) {
                @static_assert(false, (("Key of map must implment Equatable[" + @typename(K2)) + "]"))
            }
            index :  = ((key).hash() % cast() ((the_entries).length))
            tombstone :  = null
            loop {
                if !true then break
                entry :  = the_entries[int(index)]
                if !(entry).filled {
                    if !(entry).is_tombstone {
                        if (tombstone != null) {
                            return tombstone
                        } else {
                            return ^*entry
                        }
                    } else if (tombstone == null) {
                        tombstone = ^*entry
                    }
                } else {
                    if (@impl(K, Equatable[K2])).equal(&((entry).key).Some, key) {
                        return ^*entry
                    }
                }
                index = ((index + 1) % cast() ((the_entries).length))
            }
            return null
        }
        // Polymorphic instances for find_entry(self: &Self, the_entries: []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], key: &$K2) -> ^Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)]
            /* K2 = (type, FunctionTypeWrapper) */
            /*  */
            find_entry(self: &Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)], the_entries: []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)], key: &FunctionTypeWrapper) -> ^Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] {
                #anonymous {}
                index : u64 = (key.hash() % cast(u64) ((the_entries).length))
                tombstone : ^Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = null
                loop {
                    if !true then break else {}
                    entry : &Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = get_index(the_entries, cast(i64) (index))
                    if !(*entry).filled {
                        if !(*entry).is_tombstone {
                            if (cast(^void) (tombstone) != null) {
                                return tombstone
                            } else {
                                return ^*entry
                            }
                        } else if (cast(^void) (tombstone) == null) {
                            tombstone = ^*entry
                        } else {}
                    } else {
                        if (@impl(FunctionTypeWrapper, Equatable[FunctionTypeWrapper])).equal(&((*entry).key).Some, key) {
                            return ^*entry
                        } else {}
                    }
                    index = ((index + 1) % cast(u64) ((the_entries).length))
                }
                return null
            }
        
        
        set(self: &Self, key: $K2, value: fn(fn(), ^Interpreter)) -> bool {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            if (cast() ((_count + 1)) > (cast() ((entries).length) * max_load)) {
                adjust_capacity(cast() (((entries).length * 2)))
            }
            entry :  = find_entry(entries, &key)
            is_new_key :  = !(entry).filled
            (entry).key = Some(convert(K, &key))
            (entry).value = Some(value)
            (entry).filled = true
            (entry).is_tombstone = false
            if is_new_key {
                _count = 1
            }
            return is_new_key
        }
        // Polymorphic instances for set(self: &Self, key: $K2, value: fn(fn(), ^Interpreter)) -> bool
            /* K2 = (type, FunctionTypeWrapper) */
            /*  */
            set(self: &Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)], key: FunctionTypeWrapper, value: fn(fn(), ^Interpreter)) -> bool #operator("set[]") {
                if (cast(^void) ((entries).data) == null) {
                    self.adjust_capacity(13)
                } else {}
                if (cast(f64) ((_count + 1)) > (cast(f64) ((entries).length) * max_load)) {
                    self.adjust_capacity(cast(u64) (((entries).length * 2)))
                } else {}
                entry : ^Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = self.find_entry(entries, &key)
                is_new_key : bool = !(*entry).filled
                (*entry).key = Option[FunctionTypeWrapper].Some(#macro {
                    local T :: FunctionTypeWrapper = FunctionTypeWrapper
                    local c : &FunctionTypeWrapper = &key
                    *c
                })
                (*entry).value = Option[fn(fn(), ^Interpreter)].Some(value)
                (*entry).filled = true
                (*entry).is_tombstone = false
                if is_new_key {
                    _count = (_count + 1)
                } else {}
                return is_new_key
            }
        
        
        get(self: &Self, key: $K2) -> Option[&fn(fn(), ^Interpreter)] {
            if ((entries).data == null) {
                return None
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return None
            }
            return match &(entry).value {
                Some($val) -> Some(val)
                None -> None
            }
        }
        // Polymorphic instances for get(self: &Self, key: $K2) -> Option[&fn(fn(), ^Interpreter)]
            /* K2 = (type, FunctionTypeWrapper) */
            /*  */
            get(self: &Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)], key: FunctionTypeWrapper) -> Option[&fn(fn(), ^Interpreter)] {
                if (cast(^void) ((entries).data) == null) {
                    return Option[&fn(fn(), ^Interpreter)].None
                } else {}
                entry : ^Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = self.find_entry(entries, &key)
                if !(*entry).filled {
                    return Option[&fn(fn(), ^Interpreter)].None
                } else {}
                return match @tempvar_776(&(*entry).value) {
                    Option[fn(fn(), ^Interpreter)].Some($val) -> Option[&fn(fn(), ^Interpreter)].Some(val)
                    Option[fn(fn(), ^Interpreter)].None -> Option[&fn(fn(), ^Interpreter)].None
                }
            }
        
        
        get_or_insert(self: &Self, key: $K2, value_creator: fn() -> fn(fn(), ^Interpreter)) -> &fn(fn(), ^Interpreter) {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                (entry).key = Some(convert(K, &key))
                (entry).value = Some(value_creator())
                (entry).filled = true
                (entry).is_tombstone = false
                _count = 1
            }
            return match &(entry).value {
                Some($val) -> val
                None -> @assert(false)
            }
        }
        
        get_unchecked(self: &Self, key: $K2) -> &fn(fn(), ^Interpreter) {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        
        at(self: &Self, key: $K2) -> &fn(fn(), ^Interpreter) {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        
        delete(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, key)
            if !(entry).filled {
                return false
            }
            (entry).filled = false
            (entry).key = None
            (entry).value = None
            (entry).is_tombstone = true
            _count = 1
            return true
        }
        
        adjust_capacity(self: &Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)], cap: u64) {
            entries_new : []Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = alloc_n(cap, allocator)
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = (entries_new).length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_323) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_323))[0]
                    it_index : i64 = @var(@id((it, it_index)_323))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                (*get_index(entries_new, i)).filled = false
                                (*get_index(entries_new, i)).is_tombstone = false
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            if (cast(^void) ((entries).data) != null) {
                _count = 0
                #macro {
                    local r : Range[i64] = new Range[i64] { start = 0, end = (entries).length }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_325) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_325))[0]
                        it_index : i64 = @var(@id((it, it_index)_325))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                i : i64 = it
                                it_index : i64 = it_index
                                {
                                    entry : &Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = get_index(entries, i)
                                    if (*entry).filled {
                                        dest : ^Entry[FunctionTypeWrapper, fn(fn(), ^Interpreter)] = self.find_entry(entries_new, &((*entry).key).Some)
                                        (*dest).key = (*entry).key <- Option[FunctionTypeWrapper].None
                                        (*dest).value = (*entry).value <- Option[fn(fn(), ^Interpreter)].None
                                        (*dest).filled = true
                                        _count = (_count + 1)
                                    } else {}
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
            entries = entries_new
        }
        
        iterator(self: &Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)]) -> MapIterator[FunctionTypeWrapper, fn(fn(), ^Interpreter)] {
            return new MapIterator[FunctionTypeWrapper, fn(fn(), ^Interpreter)] { table = self, index = 0 }
        }
    }
    // K = (type, string), V = (type, String)
    impl(K: type, V: type) Map[string, String] {
        new(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Map[string, String] {
            #anonymous {}
            return new Map[string, String] { allocator = allocator, max_load = 0.75, _count = 0, entries = null }
        }
        
        clear(self: &Map[string, String]) {
            #macro {
                local arr : []Entry[string, String] = entries
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &Entry[string, String] = get_index(arr, it_index)
                            #link #anonymous {
                                entry : &Entry[string, String] = it
                                it_index : i64 = it_index
                                {
                                    (*entry).filled = false
                                    (*entry).is_tombstone = false
                                    (*entry).key = Option[string].None
                                    @destruct((*entry).value);
                                    (*entry).value = Option[String].None
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            _count = 0
        }
        
        empty(self: &Map[string, String]) -> bool {
            return (_count == 0)
        }
        
        count(self: &Map[string, String]) -> i64 {
            return cast (_count)
        }
        
        get_entries(self: &Map[string, String]) -> []Entry[string, String] {
            return entries
        }
        
        contains(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return false
            }
            return true
        }
        // Polymorphic instances for contains(self: &Self, key: $K2) -> bool
            /* K2 = (type, string) */
            /*  */
            contains(self: &Map[string, String], key: string) -> bool {
                if ((_count == 0) or (cast(^void) ((entries).data) == null)) {
                    return false
                } else {}
                entry : ^Entry[string, String] = self.find_entry(entries, &key)
                if !(*entry).filled {
                    return false
                } else {}
                return true
            }
        
        
        find_entry(self: &Self, the_entries: []Entry[string, String], key: &$K2) -> ^Entry[string, String] {
            if !@type_has_trait(K, Equatable[K2]) {
                @static_assert(false, (("Key of map must implment Equatable[" + @typename(K2)) + "]"))
            }
            index :  = ((key).hash() % cast() ((the_entries).length))
            tombstone :  = null
            loop {
                if !true then break
                entry :  = the_entries[int(index)]
                if !(entry).filled {
                    if !(entry).is_tombstone {
                        if (tombstone != null) {
                            return tombstone
                        } else {
                            return ^*entry
                        }
                    } else if (tombstone == null) {
                        tombstone = ^*entry
                    }
                } else {
                    if (@impl(K, Equatable[K2])).equal(&((entry).key).Some, key) {
                        return ^*entry
                    }
                }
                index = ((index + 1) % cast() ((the_entries).length))
            }
            return null
        }
        // Polymorphic instances for find_entry(self: &Self, the_entries: []Entry[string, String], key: &$K2) -> ^Entry[string, String]
            /* K2 = (type, string) */
            /*  */
            find_entry(self: &Map[string, String], the_entries: []Entry[string, String], key: &string) -> ^Entry[string, String] {
                #anonymous {}
                index : u64 = (key.hash() % cast(u64) ((the_entries).length))
                tombstone : ^Entry[string, String] = null
                loop {
                    if !true then break else {}
                    entry : &Entry[string, String] = get_index(the_entries, cast(i64) (index))
                    if !(*entry).filled {
                        if !(*entry).is_tombstone {
                            if (cast(^void) (tombstone) != null) {
                                return tombstone
                            } else {
                                return ^*entry
                            }
                        } else if (cast(^void) (tombstone) == null) {
                            tombstone = ^*entry
                        } else {}
                    } else {
                        if (@impl(string, Equatable[string])).equal(&((*entry).key).Some, key) {
                            return ^*entry
                        } else {}
                    }
                    index = ((index + 1) % cast(u64) ((the_entries).length))
                }
                return null
            }
        
        
        set(self: &Self, key: $K2, value: String) -> bool {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            if (cast() ((_count + 1)) > (cast() ((entries).length) * max_load)) {
                adjust_capacity(cast() (((entries).length * 2)))
            }
            entry :  = find_entry(entries, &key)
            is_new_key :  = !(entry).filled
            (entry).key = Some(convert(K, &key))
            (entry).value = Some(value)
            (entry).filled = true
            (entry).is_tombstone = false
            if is_new_key {
                _count = 1
            }
            return is_new_key
        }
        // Polymorphic instances for set(self: &Self, key: $K2, value: String) -> bool
            /* K2 = (type, string) */
            /*  */
            set(self: &Map[string, String], key: string, value: String) -> bool #operator("set[]") {
                if (cast(^void) ((entries).data) == null) {
                    self.adjust_capacity(13)
                } else {}
                if (cast(f64) ((_count + 1)) > (cast(f64) ((entries).length) * max_load)) {
                    self.adjust_capacity(cast(u64) (((entries).length * 2)))
                } else {}
                entry : ^Entry[string, String] = self.find_entry(entries, &key)
                is_new_key : bool = !(*entry).filled
                (*entry).key = Option[string].Some(#macro {
                    local T :: string = string
                    local c : &string = &key
                    *c
                })
                @destruct((*entry).value);
                (*entry).value = Option[String].Some(value)
                (*entry).filled = true
                (*entry).is_tombstone = false
                if is_new_key {
                    _count = (_count + 1)
                } else {}
                return is_new_key
            }
        
        
        get(self: &Self, key: $K2) -> Option[&String] {
            if ((entries).data == null) {
                return None
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return None
            }
            return match &(entry).value {
                Some($val) -> Some(val)
                None -> None
            }
        }
        // Polymorphic instances for get(self: &Self, key: $K2) -> Option[&String]
            /* K2 = (type, string) */
            /*  */
            get(self: &Map[string, String], key: string) -> Option[&String] {
                if (cast(^void) ((entries).data) == null) {
                    return Option[&String].None
                } else {}
                entry : ^Entry[string, String] = self.find_entry(entries, &key)
                if !(*entry).filled {
                    return Option[&String].None
                } else {}
                return match @tempvar_777(&(*entry).value) {
                    Option[String].Some($val) -> Option[&String].Some(val)
                    Option[String].None -> Option[&String].None
                }
            }
        
        
        get_or_insert(self: &Self, key: $K2, value_creator: fn() -> String) -> &String {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                (entry).key = Some(convert(K, &key))
                (entry).value = Some(value_creator())
                (entry).filled = true
                (entry).is_tombstone = false
                _count = 1
            }
            return match &(entry).value {
                Some($val) -> val
                None -> @assert(false)
            }
        }
        
        get_unchecked(self: &Self, key: $K2) -> &String {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        // Polymorphic instances for get_unchecked(self: &Self, key: $K2) -> &String
            /* K2 = (type, string) */
            /*  */
            get_unchecked(self: &Map[string, String], key: string) -> &String #operator("[]") {
                entry : ^Entry[string, String] = self.find_entry(entries, &key)
                @assert((*entry).filled)
                return &((*entry).value).Some
            }
        
        
        at(self: &Self, key: $K2) -> &String {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        
        delete(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, key)
            if !(entry).filled {
                return false
            }
            (entry).filled = false
            (entry).key = None
            (entry).value = None
            (entry).is_tombstone = true
            _count = 1
            return true
        }
        
        adjust_capacity(self: &Map[string, String], cap: u64) {
            entries_new : []Entry[string, String] = alloc_n(cap, allocator)
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = (entries_new).length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_352) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_352))[0]
                    it_index : i64 = @var(@id((it, it_index)_352))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                (*get_index(entries_new, i)).filled = false
                                (*get_index(entries_new, i)).is_tombstone = false
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            if (cast(^void) ((entries).data) != null) {
                _count = 0
                #macro {
                    local r : Range[i64] = new Range[i64] { start = 0, end = (entries).length }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_354) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_354))[0]
                        it_index : i64 = @var(@id((it, it_index)_354))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                i : i64 = it
                                it_index : i64 = it_index
                                {
                                    entry : &Entry[string, String] = get_index(entries, i)
                                    if (*entry).filled {
                                        dest : ^Entry[string, String] = self.find_entry(entries_new, &((*entry).key).Some)
                                        (*dest).key = (*entry).key <- Option[string].None
                                        @destruct((*dest).value);
                                        (*dest).value = (*entry).value <- Option[String].None
                                        (*dest).filled = true
                                        _count = (_count + 1)
                                    } else {}
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
            entries = entries_new
        }
        
        iterator(self: &Map[string, String]) -> MapIterator[string, String] {
            return new MapIterator[string, String] { table = self, index = 0 }
        }
    }
    // K = (type, string), V = (type, Symbol)
    impl(K: type, V: type) Map[string, Symbol] {
        new(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Map[string, Symbol] {
            #anonymous {}
            return new Map[string, Symbol] { allocator = allocator, max_load = 0.75, _count = 0, entries = null }
        }
        
        clear(self: &Map[string, Symbol]) {
            #macro {
                local arr : []Entry[string, Symbol] = entries
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &Entry[string, Symbol] = get_index(arr, it_index)
                            #link #anonymous {
                                entry : &Entry[string, Symbol] = it
                                it_index : i64 = it_index
                                {
                                    (*entry).filled = false
                                    (*entry).is_tombstone = false
                                    (*entry).key = Option[string].None
                                    (*entry).value = Option[Symbol].None
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            _count = 0
        }
        
        empty(self: &Map[string, Symbol]) -> bool {
            return (_count == 0)
        }
        
        count(self: &Map[string, Symbol]) -> i64 {
            return cast (_count)
        }
        
        get_entries(self: &Map[string, Symbol]) -> []Entry[string, Symbol] {
            return entries
        }
        
        contains(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return false
            }
            return true
        }
        // Polymorphic instances for contains(self: &Self, key: $K2) -> bool
            /* K2 = (type, string) */
            /*  */
            contains(self: &Map[string, Symbol], key: string) -> bool {
                if ((_count == 0) or (cast(^void) ((entries).data) == null)) {
                    return false
                } else {}
                entry : ^Entry[string, Symbol] = self.find_entry(entries, &key)
                if !(*entry).filled {
                    return false
                } else {}
                return true
            }
        
        
        find_entry(self: &Self, the_entries: []Entry[string, Symbol], key: &$K2) -> ^Entry[string, Symbol] {
            if !@type_has_trait(K, Equatable[K2]) {
                @static_assert(false, (("Key of map must implment Equatable[" + @typename(K2)) + "]"))
            }
            index :  = ((key).hash() % cast() ((the_entries).length))
            tombstone :  = null
            loop {
                if !true then break
                entry :  = the_entries[int(index)]
                if !(entry).filled {
                    if !(entry).is_tombstone {
                        if (tombstone != null) {
                            return tombstone
                        } else {
                            return ^*entry
                        }
                    } else if (tombstone == null) {
                        tombstone = ^*entry
                    }
                } else {
                    if (@impl(K, Equatable[K2])).equal(&((entry).key).Some, key) {
                        return ^*entry
                    }
                }
                index = ((index + 1) % cast() ((the_entries).length))
            }
            return null
        }
        // Polymorphic instances for find_entry(self: &Self, the_entries: []Entry[string, Symbol], key: &$K2) -> ^Entry[string, Symbol]
            /* K2 = (type, string) */
            /*  */
            find_entry(self: &Map[string, Symbol], the_entries: []Entry[string, Symbol], key: &string) -> ^Entry[string, Symbol] {
                #anonymous {}
                index : u64 = (key.hash() % cast(u64) ((the_entries).length))
                tombstone : ^Entry[string, Symbol] = null
                loop {
                    if !true then break else {}
                    entry : &Entry[string, Symbol] = get_index(the_entries, cast(i64) (index))
                    if !(*entry).filled {
                        if !(*entry).is_tombstone {
                            if (cast(^void) (tombstone) != null) {
                                return tombstone
                            } else {
                                return ^*entry
                            }
                        } else if (cast(^void) (tombstone) == null) {
                            tombstone = ^*entry
                        } else {}
                    } else {
                        if (@impl(string, Equatable[string])).equal(&((*entry).key).Some, key) {
                            return ^*entry
                        } else {}
                    }
                    index = ((index + 1) % cast(u64) ((the_entries).length))
                }
                return null
            }
        
        
        set(self: &Self, key: $K2, value: Symbol) -> bool {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            if (cast() ((_count + 1)) > (cast() ((entries).length) * max_load)) {
                adjust_capacity(cast() (((entries).length * 2)))
            }
            entry :  = find_entry(entries, &key)
            is_new_key :  = !(entry).filled
            (entry).key = Some(convert(K, &key))
            (entry).value = Some(value)
            (entry).filled = true
            (entry).is_tombstone = false
            if is_new_key {
                _count = 1
            }
            return is_new_key
        }
        // Polymorphic instances for set(self: &Self, key: $K2, value: Symbol) -> bool
            /* K2 = (type, string) */
            /*  */
            set(self: &Map[string, Symbol], key: string, value: Symbol) -> bool #operator("set[]") {
                if (cast(^void) ((entries).data) == null) {
                    self.adjust_capacity(13)
                } else {}
                if (cast(f64) ((_count + 1)) > (cast(f64) ((entries).length) * max_load)) {
                    self.adjust_capacity(cast(u64) (((entries).length * 2)))
                } else {}
                entry : ^Entry[string, Symbol] = self.find_entry(entries, &key)
                is_new_key : bool = !(*entry).filled
                (*entry).key = Option[string].Some(#macro {
                    local T :: string = string
                    local c : &string = &key
                    *c
                })
                (*entry).value = Option[Symbol].Some(value)
                (*entry).filled = true
                (*entry).is_tombstone = false
                if is_new_key {
                    _count = (_count + 1)
                } else {}
                return is_new_key
            }
        
        
        get(self: &Self, key: $K2) -> Option[&Symbol] {
            if ((entries).data == null) {
                return None
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return None
            }
            return match &(entry).value {
                Some($val) -> Some(val)
                None -> None
            }
        }
        // Polymorphic instances for get(self: &Self, key: $K2) -> Option[&Symbol]
            /* K2 = (type, string) */
            /*  */
            get(self: &Map[string, Symbol], key: string) -> Option[&Symbol] {
                if (cast(^void) ((entries).data) == null) {
                    return Option[&Symbol].None
                } else {}
                entry : ^Entry[string, Symbol] = self.find_entry(entries, &key)
                if !(*entry).filled {
                    return Option[&Symbol].None
                } else {}
                return match @tempvar_796(&(*entry).value) {
                    Option[Symbol].Some($val) -> Option[&Symbol].Some(val)
                    Option[Symbol].None -> Option[&Symbol].None
                }
            }
        
        
        get_or_insert(self: &Self, key: $K2, value_creator: fn() -> Symbol) -> &Symbol {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                (entry).key = Some(convert(K, &key))
                (entry).value = Some(value_creator())
                (entry).filled = true
                (entry).is_tombstone = false
                _count = 1
            }
            return match &(entry).value {
                Some($val) -> val
                None -> @assert(false)
            }
        }
        
        get_unchecked(self: &Self, key: $K2) -> &Symbol {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        
        at(self: &Self, key: $K2) -> &Symbol {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        // Polymorphic instances for at(self: &Self, key: $K2) -> &Symbol
            /* K2 = (type, string) */
            /*  */
            at(self: &Map[string, Symbol], key: string) -> &Symbol {
                entry : ^Entry[string, Symbol] = self.find_entry(entries, &key)
                @assert((*entry).filled)
                return &((*entry).value).Some
            }
        
        
        delete(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, key)
            if !(entry).filled {
                return false
            }
            (entry).filled = false
            (entry).key = None
            (entry).value = None
            (entry).is_tombstone = true
            _count = 1
            return true
        }
        
        adjust_capacity(self: &Map[string, Symbol], cap: u64) {
            entries_new : []Entry[string, Symbol] = alloc_n(cap, allocator)
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = (entries_new).length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_366) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_366))[0]
                    it_index : i64 = @var(@id((it, it_index)_366))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                (*get_index(entries_new, i)).filled = false
                                (*get_index(entries_new, i)).is_tombstone = false
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            if (cast(^void) ((entries).data) != null) {
                _count = 0
                #macro {
                    local r : Range[i64] = new Range[i64] { start = 0, end = (entries).length }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_368) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_368))[0]
                        it_index : i64 = @var(@id((it, it_index)_368))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                i : i64 = it
                                it_index : i64 = it_index
                                {
                                    entry : &Entry[string, Symbol] = get_index(entries, i)
                                    if (*entry).filled {
                                        dest : ^Entry[string, Symbol] = self.find_entry(entries_new, &((*entry).key).Some)
                                        (*dest).key = (*entry).key <- Option[string].None
                                        (*dest).value = (*entry).value <- Option[Symbol].None
                                        (*dest).filled = true
                                        _count = (_count + 1)
                                    } else {}
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
            entries = entries_new
        }
        
        iterator(self: &Map[string, Symbol]) -> MapIterator[string, Symbol] {
            return new MapIterator[string, Symbol] { table = self, index = 0 }
        }
    }
    // K = (type, i64), V = (type, i64)
    impl(K: type, V: type) Map[i64, i64] {
        new(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Map[i64, i64] {
            #anonymous {}
            return new Map[i64, i64] { allocator = allocator, max_load = 0.75, _count = 0, entries = null }
        }
        
        clear(self: &Map[i64, i64]) {
            #macro {
                local arr : []Entry[i64, i64] = entries
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &Entry[i64, i64] = get_index(arr, it_index)
                            #link #anonymous {
                                entry : &Entry[i64, i64] = it
                                it_index : i64 = it_index
                                {
                                    (*entry).filled = false
                                    (*entry).is_tombstone = false
                                    (*entry).key = Option[i64].None
                                    (*entry).value = Option[i64].None
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            _count = 0
        }
        
        empty(self: &Map[i64, i64]) -> bool {
            return (_count == 0)
        }
        
        count(self: &Map[i64, i64]) -> i64 {
            return cast (_count)
        }
        
        get_entries(self: &Map[i64, i64]) -> []Entry[i64, i64] {
            return entries
        }
        
        contains(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return false
            }
            return true
        }
        
        find_entry(self: &Self, the_entries: []Entry[i64, i64], key: &$K2) -> ^Entry[i64, i64] {
            if !@type_has_trait(K, Equatable[K2]) {
                @static_assert(false, (("Key of map must implment Equatable[" + @typename(K2)) + "]"))
            }
            index :  = ((key).hash() % cast() ((the_entries).length))
            tombstone :  = null
            loop {
                if !true then break
                entry :  = the_entries[int(index)]
                if !(entry).filled {
                    if !(entry).is_tombstone {
                        if (tombstone != null) {
                            return tombstone
                        } else {
                            return ^*entry
                        }
                    } else if (tombstone == null) {
                        tombstone = ^*entry
                    }
                } else {
                    if (@impl(K, Equatable[K2])).equal(&((entry).key).Some, key) {
                        return ^*entry
                    }
                }
                index = ((index + 1) % cast() ((the_entries).length))
            }
            return null
        }
        // Polymorphic instances for find_entry(self: &Self, the_entries: []Entry[i64, i64], key: &$K2) -> ^Entry[i64, i64]
            /* K2 = (type, i64) */
            /*  */
            find_entry(self: &Map[i64, i64], the_entries: []Entry[i64, i64], key: &i64) -> ^Entry[i64, i64] {
                #anonymous {}
                index : u64 = (key.hash() % cast(u64) ((the_entries).length))
                tombstone : ^Entry[i64, i64] = null
                loop {
                    if !true then break else {}
                    entry : &Entry[i64, i64] = get_index(the_entries, cast(i64) (index))
                    if !(*entry).filled {
                        if !(*entry).is_tombstone {
                            if (cast(^void) (tombstone) != null) {
                                return tombstone
                            } else {
                                return ^*entry
                            }
                        } else if (cast(^void) (tombstone) == null) {
                            tombstone = ^*entry
                        } else {}
                    } else {
                        if (@impl(i64, Equatable[i64])).equal(&((*entry).key).Some, key) {
                            return ^*entry
                        } else {}
                    }
                    index = ((index + 1) % cast(u64) ((the_entries).length))
                }
                return null
            }
        
        
        set(self: &Self, key: $K2, value: i64) -> bool {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            if (cast() ((_count + 1)) > (cast() ((entries).length) * max_load)) {
                adjust_capacity(cast() (((entries).length * 2)))
            }
            entry :  = find_entry(entries, &key)
            is_new_key :  = !(entry).filled
            (entry).key = Some(convert(K, &key))
            (entry).value = Some(value)
            (entry).filled = true
            (entry).is_tombstone = false
            if is_new_key {
                _count = 1
            }
            return is_new_key
        }
        // Polymorphic instances for set(self: &Self, key: $K2, value: i64) -> bool
            /* K2 = (type, i64) */
            /*  */
            set(self: &Map[i64, i64], key: i64, value: i64) -> bool #operator("set[]") {
                if (cast(^void) ((entries).data) == null) {
                    self.adjust_capacity(13)
                } else {}
                if (cast(f64) ((_count + 1)) > (cast(f64) ((entries).length) * max_load)) {
                    self.adjust_capacity(cast(u64) (((entries).length * 2)))
                } else {}
                entry : ^Entry[i64, i64] = self.find_entry(entries, &key)
                is_new_key : bool = !(*entry).filled
                (*entry).key = Option[i64].Some(#macro {
                    local T :: i64 = i64
                    local c : &i64 = &key
                    *c
                })
                (*entry).value = Option[i64].Some(value)
                (*entry).filled = true
                (*entry).is_tombstone = false
                if is_new_key {
                    _count = (_count + 1)
                } else {}
                return is_new_key
            }
        
        
        get(self: &Self, key: $K2) -> Option[&i64] {
            if ((entries).data == null) {
                return None
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return None
            }
            return match &(entry).value {
                Some($val) -> Some(val)
                None -> None
            }
        }
        // Polymorphic instances for get(self: &Self, key: $K2) -> Option[&i64]
            /* K2 = (type, i64) */
            /*  */
            get(self: &Map[i64, i64], key: i64) -> Option[&i64] {
                if (cast(^void) ((entries).data) == null) {
                    return Option[&i64].None
                } else {}
                entry : ^Entry[i64, i64] = self.find_entry(entries, &key)
                if !(*entry).filled {
                    return Option[&i64].None
                } else {}
                return match @tempvar_801(&(*entry).value) {
                    Option[i64].Some($val) -> Option[&i64].Some(val)
                    Option[i64].None -> Option[&i64].None
                }
            }
        
        
        get_or_insert(self: &Self, key: $K2, value_creator: fn() -> i64) -> &i64 {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                (entry).key = Some(convert(K, &key))
                (entry).value = Some(value_creator())
                (entry).filled = true
                (entry).is_tombstone = false
                _count = 1
            }
            return match &(entry).value {
                Some($val) -> val
                None -> @assert(false)
            }
        }
        
        get_unchecked(self: &Self, key: $K2) -> &i64 {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        // Polymorphic instances for get_unchecked(self: &Self, key: $K2) -> &i64
            /* K2 = (type, i64) */
            /*  */
            get_unchecked(self: &Map[i64, i64], key: i64) -> &i64 #operator("[]") {
                entry : ^Entry[i64, i64] = self.find_entry(entries, &key)
                @assert((*entry).filled)
                return &((*entry).value).Some
            }
        
        
        at(self: &Self, key: $K2) -> &i64 {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        
        delete(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, key)
            if !(entry).filled {
                return false
            }
            (entry).filled = false
            (entry).key = None
            (entry).value = None
            (entry).is_tombstone = true
            _count = 1
            return true
        }
        
        adjust_capacity(self: &Map[i64, i64], cap: u64) {
            entries_new : []Entry[i64, i64] = alloc_n(cap, allocator)
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = (entries_new).length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_390) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_390))[0]
                    it_index : i64 = @var(@id((it, it_index)_390))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                (*get_index(entries_new, i)).filled = false
                                (*get_index(entries_new, i)).is_tombstone = false
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            if (cast(^void) ((entries).data) != null) {
                _count = 0
                #macro {
                    local r : Range[i64] = new Range[i64] { start = 0, end = (entries).length }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_392) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_392))[0]
                        it_index : i64 = @var(@id((it, it_index)_392))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                i : i64 = it
                                it_index : i64 = it_index
                                {
                                    entry : &Entry[i64, i64] = get_index(entries, i)
                                    if (*entry).filled {
                                        dest : ^Entry[i64, i64] = self.find_entry(entries_new, &((*entry).key).Some)
                                        (*dest).key = (*entry).key <- Option[i64].None
                                        (*dest).value = (*entry).value <- Option[i64].None
                                        (*dest).filled = true
                                        _count = (_count + 1)
                                    } else {}
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
            entries = entries_new
        }
        
        iterator(self: &Map[i64, i64]) -> MapIterator[i64, i64] {
            return new MapIterator[i64, i64] { table = self, index = 0 }
        }
    }
    // K = (type, TypeId), V = (type, Array[^AstImpl])
    impl(K: type, V: type) Map[TypeId, Array[^AstImpl]] {
        new(allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Map[TypeId, Array[^AstImpl]] {
            #anonymous {}
            return new Map[TypeId, Array[^AstImpl]] { allocator = allocator, max_load = 0.75, _count = 0, entries = null }
        }
        
        clear(self: &Map[TypeId, Array[^AstImpl]]) {
            #macro {
                local arr : []Entry[TypeId, Array[^AstImpl]] = entries
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &Entry[TypeId, Array[^AstImpl]] = get_index(arr, it_index)
                            #link #anonymous {
                                entry : &Entry[TypeId, Array[^AstImpl]] = it
                                it_index : i64 = it_index
                                {
                                    (*entry).filled = false
                                    (*entry).is_tombstone = false
                                    (*entry).key = Option[TypeId].None
                                    @destruct((*entry).value);
                                    (*entry).value = Option[Array[^AstImpl]].None
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            _count = 0
        }
        
        empty(self: &Map[TypeId, Array[^AstImpl]]) -> bool {
            return (_count == 0)
        }
        
        count(self: &Map[TypeId, Array[^AstImpl]]) -> i64 {
            return cast (_count)
        }
        
        get_entries(self: &Map[TypeId, Array[^AstImpl]]) -> []Entry[TypeId, Array[^AstImpl]] {
            return entries
        }
        
        contains(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return false
            }
            return true
        }
        
        find_entry(self: &Self, the_entries: []Entry[TypeId, Array[^AstImpl]], key: &$K2) -> ^Entry[TypeId, Array[^AstImpl]] {
            if !@type_has_trait(K, Equatable[K2]) {
                @static_assert(false, (("Key of map must implment Equatable[" + @typename(K2)) + "]"))
            }
            index :  = ((key).hash() % cast() ((the_entries).length))
            tombstone :  = null
            loop {
                if !true then break
                entry :  = the_entries[int(index)]
                if !(entry).filled {
                    if !(entry).is_tombstone {
                        if (tombstone != null) {
                            return tombstone
                        } else {
                            return ^*entry
                        }
                    } else if (tombstone == null) {
                        tombstone = ^*entry
                    }
                } else {
                    if (@impl(K, Equatable[K2])).equal(&((entry).key).Some, key) {
                        return ^*entry
                    }
                }
                index = ((index + 1) % cast() ((the_entries).length))
            }
            return null
        }
        // Polymorphic instances for find_entry(self: &Self, the_entries: []Entry[TypeId, Array[^AstImpl]], key: &$K2) -> ^Entry[TypeId, Array[^AstImpl]]
            /* K2 = (type, TypeId) */
            /*  */
            find_entry(self: &Map[TypeId, Array[^AstImpl]], the_entries: []Entry[TypeId, Array[^AstImpl]], key: &TypeId) -> ^Entry[TypeId, Array[^AstImpl]] {
                #anonymous {}
                index : u64 = (key.hash() % cast(u64) ((the_entries).length))
                tombstone : ^Entry[TypeId, Array[^AstImpl]] = null
                loop {
                    if !true then break else {}
                    entry : &Entry[TypeId, Array[^AstImpl]] = get_index(the_entries, cast(i64) (index))
                    if !(*entry).filled {
                        if !(*entry).is_tombstone {
                            if (cast(^void) (tombstone) != null) {
                                return tombstone
                            } else {
                                return ^*entry
                            }
                        } else if (cast(^void) (tombstone) == null) {
                            tombstone = ^*entry
                        } else {}
                    } else {
                        if (@impl(TypeId, Equatable[TypeId])).equal(&((*entry).key).Some, key) {
                            return ^*entry
                        } else {}
                    }
                    index = ((index + 1) % cast(u64) ((the_entries).length))
                }
                return null
            }
        
        
        set(self: &Self, key: $K2, value: Array[^AstImpl]) -> bool {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            if (cast() ((_count + 1)) > (cast() ((entries).length) * max_load)) {
                adjust_capacity(cast() (((entries).length * 2)))
            }
            entry :  = find_entry(entries, &key)
            is_new_key :  = !(entry).filled
            (entry).key = Some(convert(K, &key))
            (entry).value = Some(value)
            (entry).filled = true
            (entry).is_tombstone = false
            if is_new_key {
                _count = 1
            }
            return is_new_key
        }
        
        get(self: &Self, key: $K2) -> Option[&Array[^AstImpl]] {
            if ((entries).data == null) {
                return None
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                return None
            }
            return match &(entry).value {
                Some($val) -> Some(val)
                None -> None
            }
        }
        
        get_or_insert(self: &Self, key: $K2, value_creator: fn() -> Array[^AstImpl]) -> &Array[^AstImpl] {
            if ((entries).data == null) {
                adjust_capacity(13)
            }
            entry :  = find_entry(entries, &key)
            if !(entry).filled {
                (entry).key = Some(convert(K, &key))
                (entry).value = Some(value_creator())
                (entry).filled = true
                (entry).is_tombstone = false
                _count = 1
            }
            return match &(entry).value {
                Some($val) -> val
                None -> @assert(false)
            }
        }
        // Polymorphic instances for get_or_insert(self: &Self, key: $K2, value_creator: fn() -> Array[^AstImpl]) -> &Array[^AstImpl]
            /* K2 = (type, TypeId) */
            /*  */
            get_or_insert(self: &Map[TypeId, Array[^AstImpl]], key: TypeId, value_creator: fn() -> Array[^AstImpl]) -> &Array[^AstImpl] {
                if (cast(^void) ((entries).data) == null) {
                    self.adjust_capacity(13)
                } else {}
                entry : ^Entry[TypeId, Array[^AstImpl]] = self.find_entry(entries, &key)
                if !(*entry).filled {
                    (*entry).key = Option[TypeId].Some(#macro {
                        local T :: TypeId = TypeId
                        local c : &TypeId = &key
                        *c
                    })
                    @destruct((*entry).value);
                    (*entry).value = Option[Array[^AstImpl]].Some(value_creator())
                    (*entry).filled = true
                    (*entry).is_tombstone = false
                    _count = (_count + 1)
                } else {}
                return match @tempvar_800(&(*entry).value) {
                    Option[Array[^AstImpl]].Some($val) -> val
                    Option[Array[^AstImpl]].None -> @assert(false)
                }
            }
        
        
        get_unchecked(self: &Self, key: $K2) -> &Array[^AstImpl] {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        
        at(self: &Self, key: $K2) -> &Array[^AstImpl] {
            entry :  = find_entry(entries, &key)
            @assert((entry).filled)
            return &((entry).value).Some
        }
        
        delete(self: &Self, key: $K2) -> bool {
            if ((_count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, key)
            if !(entry).filled {
                return false
            }
            (entry).filled = false
            (entry).key = None
            (entry).value = None
            (entry).is_tombstone = true
            _count = 1
            return true
        }
        
        adjust_capacity(self: &Map[TypeId, Array[^AstImpl]], cap: u64) {
            entries_new : []Entry[TypeId, Array[^AstImpl]] = alloc_n(cap, allocator)
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = (entries_new).length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_568) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_568))[0]
                    it_index : i64 = @var(@id((it, it_index)_568))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                (*get_index(entries_new, i)).filled = false
                                (*get_index(entries_new, i)).is_tombstone = false
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            if (cast(^void) ((entries).data) != null) {
                _count = 0
                #macro {
                    local r : Range[i64] = new Range[i64] { start = 0, end = (entries).length }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_570) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_570))[0]
                        it_index : i64 = @var(@id((it, it_index)_570))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                i : i64 = it
                                it_index : i64 = it_index
                                {
                                    entry : &Entry[TypeId, Array[^AstImpl]] = get_index(entries, i)
                                    if (*entry).filled {
                                        dest : ^Entry[TypeId, Array[^AstImpl]] = self.find_entry(entries_new, &((*entry).key).Some)
                                        (*dest).key = (*entry).key <- Option[TypeId].None
                                        @destruct((*dest).value);
                                        (*dest).value = (*entry).value <- Option[Array[^AstImpl]].None
                                        (*dest).filled = true
                                        _count = (_count + 1)
                                    } else {}
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
            entries = entries_new
        }
        
        iterator(self: &Map[TypeId, Array[^AstImpl]]) -> MapIterator[TypeId, Array[^AstImpl]] {
            return new MapIterator[TypeId, Array[^AstImpl]] { table = self, index = 0 }
        }
    }


impl(K: type, V: type) Clone for Cheez.Types.Abstract.GenericStructType if K : Clone, V : Clone {
    
}
// Polymorphic instances for impl(K: type, V: type) Clone for Cheez.Types.Abstract.GenericStructType if K : Clone, V : Clone
    // K = (type, string), V = (type, String)
    impl(K: type, V: type) Clone for Map[string, String] {
        clone(self: &Map[string, String]) -> Map[string, String] {
            result : Map[string, String] = (Map[string, String]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            &result.adjust_capacity(cast (((*self).entries).length))
            #macro {
                local r : &Map[string, String] = self
                
                it_index : i64 = 0
                #macro {
                    local arr : []Entry[string, String] = r.get_entries()
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &Entry[string, String] = get_index(arr, it_index)
                                #link #anonymous {
                                    e : &Entry[string, String] = it
                                    _ : i64 = it_index
                                    {
                                        if !(*e).filled then it_index = (it_index + 1);
                                        continue else {}
                                        it : (key: &string, value: &String) = (&((*e).key).Some, &((*e).value).Some)
                                        #link #anonymous {
                                            kv : (key: &string, value: &String) = it
                                            it_index : i64 = it_index
                                            {
                                                &result.set((kv).key.clone(), (kv).value.clone())
                                            }
                                        }
                                        it_index = (it_index + 1)
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            }
            return result
        }
    }


for_extension_map : (r: &Map[$K, $V], code: Code) : for_extension_map(r: &Map[$K, $V], code: Code) {
    it_index :  = 0
    for(by_ref = true) e, _ : (r).get_entries() {
        if !(e).filled then continue
        it :  = (&((e).key).Some, &((e).value).Some)
        @insert(code, _break = @link(break), _continue = @link(continue))
        it_index = 1
    }
}
// Polymorphic instances for for_extension_map(r: &Map[$K, $V], code: Code)
    /* K = (type, TypeId), V = (type, Array[^AstImpl]) */
    /*  */
    for_extension_map(r: &Map[TypeId, Array[^AstImpl]], code: Code) #for {
        it_index :  = 0
        for(by_ref = true) e, _ : (r).get_entries() {
            if !(e).filled then continue
            it :  = (&((e).key).Some, &((e).value).Some)
            @insert(code, _break = @link(break), _continue = @link(continue))
            it_index = 1
        }
    }
    /* K = (type, string), V = (type, String) */
    /*  */
    for_extension_map(r: &Map[string, String], code: Code) #for {
        it_index :  = 0
        for(by_ref = true) e, _ : (r).get_entries() {
            if !(e).filled then continue
            it :  = (&((e).key).Some, &((e).value).Some)
            @insert(code, _break = @link(break), _continue = @link(continue))
            it_index = 1
        }
    }


MapIterator :: struct(K: type, V: type) {
    table : 
    index : 
}
// Polymorphic instances for struct(K: type, V: type)
    // K = i64, V = ^AstStruct
    struct { // size: 16, alignment: 8
        table : &Map[i64, ^AstStruct]
        index : i64
    }
    // K = string, V = SourceFile
    struct { // size: 16, alignment: 8
        table : &Map[string, SourceFile]
        index : i64
    }
    // K = FunctionTypeWrapper, V = fn(fn(), ^Interpreter)
    struct { // size: 16, alignment: 8
        table : &Map[FunctionTypeWrapper, fn(fn(), ^Interpreter)]
        index : i64
    }
    // K = string, V = String
    struct { // size: 16, alignment: 8
        table : &Map[string, String]
        index : i64
    }
    // K = string, V = Symbol
    struct { // size: 16, alignment: 8
        table : &Map[string, Symbol]
        index : i64
    }
    // K = i64, V = i64
    struct { // size: 16, alignment: 8
        table : &Map[i64, i64]
        index : i64
    }
    // K = TypeId, V = Array[^AstImpl]
    struct { // size: 16, alignment: 8
        table : &Map[TypeId, Array[^AstImpl]]
        index : i64
    }


Entry :: struct(K: type, V: type) {
    key : 
    value : 
    filled : 
    is_tombstone : 
}
// Polymorphic instances for struct(K: type, V: type)
    // K = i64, V = ^AstStruct
    struct { // size: 40, alignment: 8
        key : Option[i64]
        value : Option[^AstStruct]
        filled : bool
        is_tombstone : bool
    }
    // K = string, V = SourceFile
    struct { // size: 120, alignment: 8
        key : Option[string]
        value : Option[SourceFile]
        filled : bool
        is_tombstone : bool
    }
    // K = FunctionTypeWrapper, V = fn(fn(), ^Interpreter)
    struct { // size: 40, alignment: 8
        key : Option[FunctionTypeWrapper]
        value : Option[fn(fn(), ^Interpreter)]
        filled : bool
        is_tombstone : bool
    }
    // K = string, V = String
    struct { // size: 80, alignment: 8
        key : Option[string]
        value : Option[String]
        filled : bool
        is_tombstone : bool
    }
    // K = string, V = Symbol
    struct { // size: 88, alignment: 8
        key : Option[string]
        value : Option[Symbol]
        filled : bool
        is_tombstone : bool
    }
    // K = TypeId, V = Array[^AstImpl]
    struct { // size: 80, alignment: 8
        key : Option[TypeId]
        value : Option[Array[^AstImpl]]
        filled : bool
        is_tombstone : bool
    }
    // K = i64, V = i64
    struct { // size: 40, alignment: 8
        key : Option[i64]
        value : Option[i64]
        filled : bool
        is_tombstone : bool
    }


#file bump_allocator.che
use import std.mem.allocator

use import std.mem.std_heap_allocator

use import std.array

use import std.printable

util :  : import std.util

io :  : import std.io

C :  : import std.c

BumpAllocator :: struct { // size: 64, alignment: 8
    parent : ^Allocator
    bucket_size : u64
    buckets : Array[BumpBucket]
}

impl Drop for BumpAllocator {
    drop(self: &BumpAllocator) {
        #macro {
            local arr : &Array[BumpBucket] = &buckets
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &BumpBucket = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            it : &BumpBucket = it
                            it_index : i64 = it_index
                            {
                                parent.free(cast(^void) (((*it).memory).data))
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
    }
}

impl BumpAllocator {
    new(size: u64, alloc: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> BumpAllocator {
        a : BumpAllocator = new BumpAllocator { parent = alloc, bucket_size = size, buckets = (Array[BumpBucket]).create(10, allocator = alloc) }
        return a
    }
    
    dump(self: &BumpAllocator, dump_buckets: bool = false) {
        (io).printfln("BumpAllocator ({} buckets)", (buckets).length)
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = (buckets).length }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_218) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_218))[0]
                it_index : i64 = @var(@id((it, it_index)_218))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            bucket : &BumpBucket = access(&buckets, i)
                            (io).printfln("  BumpBucket {}: {}/{} bytes", (i, (*bucket).filled, ((*bucket).memory).length))
                            if dump_buckets {
                                current : u64 = 0
                                loop {
                                    if !(current < (*bucket).filled) then break else {}
                                    len : u64 = *cast(^u64) ((util).pointer_add(((*bucket).memory).data, cast(i64) (current)))
                                    if (len == 0) {
                                        current = (current + 8)
                                        continue
                                    } else {}
                                    (io).printfln("    {}: {} bytes", (current, len))
                                    current = (current + (len + 8))
                                    current = align(current, 8)
                                }
                            } else {}
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
    }
}

impl Allocator for BumpAllocator {
    allocate(self: &BumpAllocator, count: u64, elementSize: u64, alignment: u64) -> ^void {
        required_size : u64 = ((count * elementSize) + 8)
        if (alignment < 8) {
            alignment = 8
        } else {}
        free_bucket : ^BumpBucket = if ((&buckets.count() > 0) and &buckets.peek_last().can_store(required_size, alignment)) {
            ^*&buckets.peek_last()
        } else {
            null
        }
        if (cast(^void) (free_bucket) == null) {
            new_bucket_size : u64 = (required_size * 2)
            if (new_bucket_size < bucket_size) {
                new_bucket_size = bucket_size
            } else {}
            new_mem : []u8 = cast([]u8) (cast(^u8) (parent.allocate(new_bucket_size, @sizeof(u8), alignment)))
            (new_mem).length = cast (new_bucket_size)
            &buckets.add(new BumpBucket { memory = new_mem, filled = 0 })
            free_bucket = ^*access(&buckets, ((buckets).length - 1))
        } else {}
        ptr : ^u8 = &*free_bucket.allocate(required_size, alignment)
        len_ptr : ^u64 = cast(^u64) (ptr)
        *len_ptr = (count * elementSize)
        return cast(^void) ((util).pointer_add(ptr, 8))
    }
    
    reallocate(self: &BumpAllocator, mem: ^void, count: u64, elementSize: u64, alignment: u64) -> ^void {
        if (mem == null) {
            return self.allocate(count, elementSize, alignment)
        } else {
            len : u64 = *cast(^u64) ((util).pointer_add(mem, -8))
            if (len >= (count * elementSize)) {
                return mem
            } else {}
            new_mem : ^void = self.allocate(count, elementSize, alignment)
            (C).memcpy(new_mem, mem, len)
            return new_mem
        }
    }
    
    free(self: &BumpAllocator, mem: ^void) {}
}

align :: align(add: u64, align: u64) -> u64 {
    mul : u64 = ((add + align) - 1)
    mul = (mul - (mul % align))
    return mul
}

BumpBucket :: struct { // size: 24, alignment: 8
    memory : []u8
    filled : u64
}

impl BumpBucket {
    can_store(self: &BumpBucket, size: u64, align: u64) -> bool {
        next_address : ^u8 = (util).next_aligned((util).pointer_add((memory).data, cast(i64) (filled)), align)
        next_offset : u64 = (cast(u64) (next_address) - cast(u64) ((memory).data))
        free : u64 = (cast(u64) ((memory).length) - next_offset)
        return (free >= size)
    }
    
    allocate(self: &BumpBucket, size: u64, align: u64) -> ^u8 {
        next_address : ^u8 = (util).next_aligned((util).pointer_add((memory).data, cast(i64) (filled)), align)
        next_offset : u64 = (cast(u64) (next_address) - cast(u64) ((memory).data))
        filled = (next_offset + size)
        return next_address
    }
}

#file ring_queue.che
use import std.mem.allocator

use import std.mem.std_heap_allocator

use import std.util

C :  : import std.c

RingQueue :: struct(T: type) {
    data : 
    capacity : 
    first : 
    last : 
    allocator : 
}
// Polymorphic instances for struct(T: type)
    // T = ^CompilationJob
    struct { // size: 48, alignment: 8
        data : ^^CompilationJob
        capacity : i64
        first : i64
        last : i64
        allocator : ^Allocator
    }
    // T = ^FiberContext
    struct { // size: 48, alignment: 8
        data : ^^FiberContext
        capacity : i64
        first : i64
        last : i64
        allocator : ^Allocator
    }


impl(T: type) Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(T: type) Cheez.Types.Abstract.GenericStructType
    // T = (type, ^CompilationJob)
    impl(T: type) RingQueue[^CompilationJob] {
        new(init_size: i64 = 10, allocator: ^Allocator = null) -> RingQueue[^CompilationJob] {
            if (cast(^void) (allocator) == null) {
                allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)
            } else {}
            data : ^^CompilationJob = alloc_raw(cast (init_size), allocator)
            return new RingQueue[^CompilationJob] {
                data = data
                capacity = init_size
                first = 0
                last = 0
                allocator = allocator
            }
        }
        
        get_capacity(self: &RingQueue[^CompilationJob]) -> i64 {
            return capacity
        }
        
        get_length(self: &RingQueue[^CompilationJob]) -> i64 {
            return (((last - first) + capacity) % capacity)
        }
        
        count(self: &RingQueue[^CompilationJob]) -> i64 {
            return (((last - first) + capacity) % capacity)
        }
        
        reserve(self: &RingQueue[^CompilationJob], size: i64) {
            if (capacity > size) {
                return
            } else {}
            if (last >= first) {
                data = realloc_raw(data, cast (size), allocator)
                last = (last - first)
                first = 0
            } else {
                data_new : ^^CompilationJob = alloc_raw(cast (size), allocator)
                l1 : i64 = (capacity - first)
                l2 : i64 = last
                (C).memcpy(cast (data_new), cast (pointer_add_sized(data, first)), cast(u64) ((l1 * @sizeof(^CompilationJob))))
                (C).memcpy(cast (pointer_add_sized(data_new, l1)), cast (data), cast(u64) ((l2 * @sizeof(^CompilationJob))))
                free(data, allocator)
                data = data_new
                last = (l1 + l2)
                first = 0
            }
            capacity = size
            if (size > self.get_length()) {
                (C).memset(cast (^data[self.get_length()]), 0, cast(u64) (((size - self.get_length()) * @sizeof(^CompilationJob))))
            } else {}
        }
        
        push(self: &RingQueue[^CompilationJob], val: ^CompilationJob) {
            if (self.get_length() == (capacity - 1)) {
                self.reserve((capacity * 2))
            } else {}
            data[last] = val
            last = ((last + 1) % capacity)
        }
        
        pop(self: &RingQueue[^CompilationJob]) -> ^CompilationJob {
            @assert((first != last))
            val : ^CompilationJob = data[first]
            (C).memset(cast(^void) (^data[first]), 0, @sizeof(^CompilationJob))
            first = ((first + 1) % capacity)
            return val
        }
        
        at(self: &RingQueue[^CompilationJob], index: i64) -> &^CompilationJob #operator("[]") {
            @assert(((index >= 0) and (index < self.count())))
            index = ((first + index) % capacity)
            return &data[index]
        }
    }
    // T = (type, ^FiberContext)
    impl(T: type) RingQueue[^FiberContext] {
        new(init_size: i64 = 10, allocator: ^Allocator = null) -> RingQueue[^FiberContext] {
            if (cast(^void) (allocator) == null) {
                allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)
            } else {}
            data : ^^FiberContext = alloc_raw(cast (init_size), allocator)
            return new RingQueue[^FiberContext] {
                data = data
                capacity = init_size
                first = 0
                last = 0
                allocator = allocator
            }
        }
        
        get_capacity(self: &RingQueue[^FiberContext]) -> i64 {
            return capacity
        }
        
        get_length(self: &RingQueue[^FiberContext]) -> i64 {
            return (((last - first) + capacity) % capacity)
        }
        
        count(self: &RingQueue[^FiberContext]) -> i64 {
            return (((last - first) + capacity) % capacity)
        }
        
        reserve(self: &RingQueue[^FiberContext], size: i64) {
            if (capacity > size) {
                return
            } else {}
            if (last >= first) {
                data = realloc_raw(data, cast (size), allocator)
                last = (last - first)
                first = 0
            } else {
                data_new : ^^FiberContext = alloc_raw(cast (size), allocator)
                l1 : i64 = (capacity - first)
                l2 : i64 = last
                (C).memcpy(cast (data_new), cast (pointer_add_sized(data, first)), cast(u64) ((l1 * @sizeof(^FiberContext))))
                (C).memcpy(cast (pointer_add_sized(data_new, l1)), cast (data), cast(u64) ((l2 * @sizeof(^FiberContext))))
                free(data, allocator)
                data = data_new
                last = (l1 + l2)
                first = 0
            }
            capacity = size
            if (size > self.get_length()) {
                (C).memset(cast (^data[self.get_length()]), 0, cast(u64) (((size - self.get_length()) * @sizeof(^FiberContext))))
            } else {}
        }
        
        push(self: &RingQueue[^FiberContext], val: ^FiberContext) {
            if (self.get_length() == (capacity - 1)) {
                self.reserve((capacity * 2))
            } else {}
            data[last] = val
            last = ((last + 1) % capacity)
        }
        
        pop(self: &RingQueue[^FiberContext]) -> ^FiberContext {
            @assert((first != last))
            val : ^FiberContext = data[first]
            (C).memset(cast(^void) (^data[first]), 0, @sizeof(^FiberContext))
            first = ((first + 1) % capacity)
            return val
        }
        
        at(self: &RingQueue[^FiberContext], index: i64) -> &^FiberContext #operator("[]") {
            @assert(((index >= 0) and (index < self.count())))
            index = ((first + index) % capacity)
            return &data[index]
        }
    }


impl(T: type) Drop for Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(T: type) Drop for Cheez.Types.Abstract.GenericStructType
    // T = (type, ^CompilationJob)
    impl(T: type) Drop for RingQueue[^CompilationJob] {
        drop(self: &RingQueue[^CompilationJob]) {
            if (first <= last) {
                #macro {
                    local r : Range[i64] = new Range[i64] { start = first, end = last }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_303) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_303))[0]
                        it_index : i64 = @var(@id((it, it_index)_303))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                it : i64 = it
                                it_index : i64 = it_index
                                {
                                    (Memory).drop(data[it])
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
            } else {
                #macro {
                    local r : Range[i64] = new Range[i64] { start = first, end = capacity }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_305) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_305))[0]
                        it_index : i64 = @var(@id((it, it_index)_305))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                it : i64 = it
                                it_index : i64 = it_index
                                {
                                    (Memory).drop(data[it])
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
                #macro {
                    local r : Range[i64] = new Range[i64] { start = 0, end = last }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_307) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_307))[0]
                        it_index : i64 = @var(@id((it, it_index)_307))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                it : i64 = it
                                it_index : i64 = it_index
                                {
                                    (Memory).drop(data[it])
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
            }
            if (cast(^void) (allocator) != null) {
                free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            } else {}
        }
    }
    // T = (type, ^FiberContext)
    impl(T: type) Drop for RingQueue[^FiberContext] {
        drop(self: &RingQueue[^FiberContext]) {
            if (first <= last) {
                #macro {
                    local r : Range[i64] = new Range[i64] { start = first, end = last }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_344) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_344))[0]
                        it_index : i64 = @var(@id((it, it_index)_344))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                it : i64 = it
                                it_index : i64 = it_index
                                {
                                    (Memory).drop(data[it])
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
            } else {
                #macro {
                    local r : Range[i64] = new Range[i64] { start = first, end = capacity }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_346) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_346))[0]
                        it_index : i64 = @var(@id((it, it_index)_346))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                it : i64 = it
                                it_index : i64 = it_index
                                {
                                    (Memory).drop(data[it])
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
                #macro {
                    local r : Range[i64] = new Range[i64] { start = 0, end = last }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_348) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_348))[0]
                        it_index : i64 = @var(@id((it, it_index)_348))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                it : i64 = it
                                it_index : i64 = it_index
                                {
                                    (Memory).drop(data[it])
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
            }
            if (cast(^void) (allocator) != null) {
                free(data, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            } else {}
        }
    }


for_extension_ring_queue_T : (que: &RingQueue[$T], code: Code, reverse: bool = false, by_ref: bool = true) : for_extension_ring_queue_T(que: &RingQueue[$T], code: Code, reverse: bool, by_ref: bool) {
    {
        it_index :  = 0
        loop {
            if !(it_index < (que).count()) then break
            defer it_index = 1
            if reverse {
                it_index_rev :  = (((que).count() - it_index) - 1)
                if by_ref {
                    it :  = que[it_index_rev]
                } else {
                    it :  = *que[it_index_rev]
                }
                @insert(code, link = [it_index_rev], _break = break, _continue = continue)
            } else {
                if by_ref {
                    it :  = que[it_index]
                } else {
                    it :  = *que[it_index]
                }
                @insert(code, _break = break, _continue = continue)
            }
        }
    }
}
// Polymorphic instances for for_extension_ring_queue_T(que: &RingQueue[$T], code: Code, reverse: bool, by_ref: bool)
    /* T = (type, ^FiberContext) */
    /*  */
    for_extension_ring_queue_T(que: &RingQueue[^FiberContext], code: Code, reverse: bool = false, by_ref: bool = true) #for {
        {
            it_index :  = 0
            loop {
                if !(it_index < (que).count()) then break
                defer it_index = 1
                if reverse {
                    it_index_rev :  = (((que).count() - it_index) - 1)
                    if by_ref {
                        it :  = que[it_index_rev]
                    } else {
                        it :  = *que[it_index_rev]
                    }
                    @insert(code, link = [it_index_rev], _break = break, _continue = continue)
                } else {
                    if by_ref {
                        it :  = que[it_index]
                    } else {
                        it :  = *que[it_index]
                    }
                    @insert(code, _break = break, _continue = continue)
                }
            }
        }
    }


#file ast.che
use import std.printable

use import std.string

use import std.array

use import interpreter

use import lexer

use import scope

use import types

use import value

AstNodeFlags :: enum<i64> { // size: 0, alignment: 1
    None = 0
    LValue = 1
    IsDefinedInScope = 2
    AllowPubModifier = 4
    OnlyPubDeclarations = 8
}

__uiaeuiaeuiae : ^TypeInfo = @type_info(AstNodeFlags)

AstNode :: trait {
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = (Value).None
    flags : i64 = 0
}

impl AstNode {
    set_flags(self: &AstNode, flags: AstNodeFlags) {
        (*self).flags = @bin_or((*self).flags, cast(i64) (flags))
    }
    
    clear_flags(self: &AstNode, flags: AstNodeFlags) {
        (*self).flags = @bin_and((*self).flags, @bin_not(cast(i64) (flags)))
    }
    
    has_flags(self: &AstNode, flags: AstNodeFlags) -> bool {
        return (@bin_and((*self).flags, cast(i64) (flags)) == cast(i64) (flags))
    }
}

AstConstDecl :: struct type { // size: 200, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    pattern : &AstNode
    type_expr : ^AstNode
    value_expr : &AstNode
    public : bool = false
    var_type : ^TypeInfo = null
}

impl AstNode for AstConstDecl {
    
}

AstDecl :: struct type { // size: 216, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    pattern : ^AstNode
    type_expr : ^AstNode
    value_expr : ^AstNode
    mutable : bool = false
    public : bool = false
    name : string = "_"
    var_type : ^TypeInfo = null
}

impl AstNode for AstDecl {
    
}

AstImport :: struct type { // size: 144, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    path : &AstNode
}

impl AstNode for AstImport {
    
}

AstUse :: struct type { // size: 144, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    value_expr : &AstNode
}

impl AstNode for AstUse {
    
}

AstImpl :: struct type { // size: 200, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    target_expr : &AstNode
    trait_expr : ^AstNode
    children : Array[^AstNode]
}

impl AstNode for AstImpl {
    
}

AstStruct :: struct type { // size: 312, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    name : string = "#anonymous"
    trait_expr : ^AstNode
    children : Array[^AstNode]
    sub_scope : ^Scope = null
    struct_type : ^TypeInfo = null
    members : Array[^AstDecl] = (Array[^AstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    constants : Array[^AstConstDecl] = (Array[^AstConstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    members_done : bool = false
}

impl AstNode for AstStruct {
    
}

AstTrait :: struct type { // size: 296, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    name : string = "#anonymous"
    children : Array[^AstNode]
    sub_scope : ^Scope = null
    trait_type : ^TypeInfo = null
    members : Array[^AstDecl] = (Array[^AstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    functions : Array[^AstConstDecl] = (Array[^AstConstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    members_done : bool = false
}

impl AstNode for AstTrait {
    
}

AstEnum :: struct type { // size: 256, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    name : string = "#anonymous"
    children : Array[^AstNode]
    sub_scope : ^Scope = null
    enum_type : ^TypeInfo = null
    members : Array[^AstDecl] = (Array[^AstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    members_done : bool = false
}

impl AstNode for AstEnum {
    
}

AstFunction :: struct type { // size: 248, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    params : Array[^AstDecl]
    body : ^AstNode
    return_type_expr : ^AstNode
    param_scope : ^Scope
    name : string = "#anonymous"
    return_type : ^TypeInfo = null
    bytecode : ^CBCFunction = null
}

impl AstNode for AstFunction {
    
}

AstPoly :: struct type { // size: 208, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    params : Array[^AstDecl]
    value_expr : &AstNode
    param_scope : ^Scope
    name : string = "#anonymous"
}

impl AstNode for AstPoly {
    
}

AstArgument :: struct type { // size: 152, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    name : ^AstIdentifier
    value_expr : &AstNode
}

impl AstNode for AstArgument {
    
}

AstBlock :: struct type { // size: 176, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    sub_scope : ^Scope
    children : Array[^AstNode]
}

impl AstNode for AstBlock {
    
}

AstCast :: struct type { // size: 160, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    type_expr : ^AstNode
    value_expr : &AstNode
}

impl AstNode for AstCast {
    
}

AstCall :: struct type { // size: 192, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    function : &AstNode
    arguments : Array[^AstArgument]
    ast_function : ^AstFunction = null
}

impl AstNode for AstCall {
    
}

AstIdentifier :: struct type { // size: 192, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    name : string
    symbol : Symbol = Symbol.NotFound
}

impl AstNode for AstIdentifier {
    
}

AstNumberLiteral :: struct type { // size: 128, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
}

impl AstNode for AstNumberLiteral {
    
}

AstString :: struct type { // size: 144, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    string_value : string
}

impl AstNode for AstString {
    
}

AstBool :: struct type { // size: 136, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    bool_value : bool
}

impl AstNode for AstBool {
    
}

AstNull :: struct type { // size: 128, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
}

impl AstNode for AstNull {
    
}

AstBinary :: struct type { // size: 168, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    operator : BinOp
    left : &AstNode
    right : &AstNode
}

impl AstNode for AstBinary {
    
}

AstUnary :: struct type { // size: 152, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    operator : UnOp
    sub : &AstNode
}

impl AstNode for AstUnary {
    
}

AstAssignment :: struct type { // size: 160, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    pattern : &AstNode
    value_expr : &AstNode
}

impl AstNode for AstAssignment {
    
}

AstIf :: struct type { // size: 176, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    condition : &AstNode
    true_case : &AstNode
    false_case : ^AstNode
}

impl AstNode for AstIf {
    
}

AstFor :: struct type { // size: 184, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    it_pattern : ^AstNode
    index_name : ^AstIdentifier
    collection : &AstNode
    body : &AstNode
}

impl AstNode for AstFor {
    
}

AstLoop :: struct type { // size: 144, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    body : &AstNode
}

impl AstNode for AstLoop {
    
}

AstMatch :: struct type { // size: 184, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    value_expr : ^AstNode
    cases : Array[^AstMatchCase]
}

impl AstNode for AstMatch {
    
}

AstMatchCase :: struct { // size: 48, alignment: 8
    pattern : &AstNode
    condition : ^AstNode
    body : &AstNode
}

AstBreak :: struct type { // size: 152, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    label : ^AstIdentifier
    value_expr : ^AstNode
}

impl AstNode for AstBreak {
    
}

AstContinue :: struct type { // size: 136, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    label : ^AstIdentifier
}

impl AstNode for AstContinue {
    
}

AstReturn :: struct type { // size: 144, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    value_expr : ^AstNode
}

impl AstNode for AstReturn {
    
}

AstDefer :: struct type { // size: 144, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    sub : &AstNode
}

impl AstNode for AstDefer {
    
}

AstTuple :: struct type { // size: 168, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    values : Array[^AstNode]
}

impl AstNode for AstTuple {
    
}

AstArray :: struct type { // size: 168, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    values : Array[^AstNode]
}

impl AstNode for AstArray {
    
}

AstArrayType :: struct type { // size: 160, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    count : ^AstNode
    target : &AstNode
}

impl AstNode for AstArrayType {
    
}

AstDot :: struct type { // size: 200, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    sub : ^AstNode
    name : &AstIdentifier
    symbol : Symbol = Symbol.NotFound
}

impl AstNode for AstDot {
    
}

AstIndex :: struct type { // size: 200, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    sub : &AstNode
    arguments : Array[^AstArgument]
    index : ^AstNode
}

impl AstNode for AstIndex {
    
}

AstUfc :: struct type { // size: 192, alignment: 8
    id : i64 = -1
    location : Location
    scope : ^Scope = null
    typ : ^TypeInfo = null
    value : Value = Value.None
    flags : i64 = 0
    value_expr : &AstNode
    symbol : Symbol
}

impl BinOp {
    lexeme(self: BinOp) -> string {
        return match @tempvar_501(self) {
            BinOp.Add -> "+"
            BinOp.Sub -> "-"
            BinOp.Mul -> "*"
            BinOp.Div -> "/"
            BinOp.Mod -> "%"
            BinOp.And -> "and"
            BinOp.Or -> "or"
            BinOp.Less -> "<"
            BinOp.LessEq -> "<="
            BinOp.Greater -> ">"
            BinOp.GreaterEq -> ">="
            BinOp.Equal -> "=="
            BinOp.NotEqual -> "!="
            BinOp.Move -> "<-"
            BinOp.Pipe -> "|"
            BinOp.Range -> ".."
            BinOp.RangeIncl -> "..="
            _ -> @assert(false)
        }
    }
}

impl UnOp {
    lexeme(self: UnOp) -> string {
        return match @tempvar_502(self) {
            UnOp.Neg -> "-"
            UnOp.Not -> "!"
            UnOp.Ref -> "&"
            UnOp.RefMut -> "&mut "
            UnOp.Ptr -> "^"
            UnOp.PtrMut -> "^mut "
            UnOp.Deref -> "*"
            _ -> @assert(false)
        }
    }
}

#file ast_dumper.che
use import std.string

use import std.array

fmt :  : import std.fmt

use import ast

dump_ast :: dump_ast(node: &AstNode, recurse: bool = true) -> String {
    result : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    dump_ast_helper(&result, node, recurse, 0)
    return result
}

dump_ast_helper :: dump_ast_helper(result: &String, node: &AstNode, recurse: bool, indent: i64) {
    print :: print(msg: string, amount: i64) #macro {
        for : 0..amount {
            result = "  "
        }
        @link(result) = msg
    }
    #macro {
        local msg : string : ""
        local amount : i64 = indent
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = amount }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_34) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_34))[0]
                it_index : i64 = @var(@id((it, it_index)_34))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        it : i64 = it
                        it_index : i64 = it_index
                        {
                            append_string(result, "  ")
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        append_string(result, msg)
    }
    match @tempvar_58(node) {
        AstArgument($arg) -> {
            (fmt).format_into(result, "AstArgument #{} ({})`n", cast([]^any) ([cast(^any) ((*arg).id), cast(^any) ((*arg).location)]))
            if recurse {
                if (cast(^void) ((*arg).name) != null) then dump_ast_helper(result, cast(&AstNode) (&*(*arg).name), recurse, (indent + 1)) else {}
                dump_ast_helper(result, (*arg).value_expr, recurse, (indent + 1))
            } else {}
        }
        AstAssignment($ass) -> {
            (fmt).format_into(result, "AstAssignment #{} ({})`n", cast([]^any) ([cast(^any) ((*ass).id), cast(^any) ((*ass).location)]))
            if recurse {
                dump_ast_helper(result, (*ass).pattern, recurse, (indent + 1))
                dump_ast_helper(result, (*ass).value_expr, recurse, (indent + 1))
            } else {}
        }
        AstArray($array) -> {
            (fmt).format_into(result, "AstArray #{} ({})`n", cast([]^any) ([cast(^any) ((*array).id), cast(^any) ((*array).location)]))
            if recurse {
                #macro {
                    local arr : &Array[^AstNode] = &(*array).values
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstNode = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    val : &^AstNode = it
                                    it_index : i64 = it_index
                                    {
                                        dump_ast_helper(result, &**val, recurse, (indent + 1))
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            } else {}
        }
        AstArrayType($array) -> {
            (fmt).format_into(result, "AstArrayType #{} ({})`n", cast([]^any) ([cast(^any) ((*array).id), cast(^any) ((*array).location)]))
            if recurse {
                if (cast(^void) ((*array).count) != null) then dump_ast_helper(result, &*(*array).count, recurse, (indent + 1)) else {}
                dump_ast_helper(result, (*array).target, recurse, (indent + 1))
            } else {}
        }
        AstBinary($bin) -> {
            (fmt).format_into(result, "AstBinary #{} {} ({})`n", cast([]^any) ([cast(^any) ((*bin).id), cast(^any) ((*bin).operator), cast(^any) ((*bin).location)]))
            if recurse {
                dump_ast_helper(result, (*bin).left, recurse, (indent + 1))
                dump_ast_helper(result, (*bin).right, recurse, (indent + 1))
            } else {}
        }
        AstBlock($block) -> {
            (fmt).format_into(result, "AstBlock #{} ({})`n", cast([]^any) ([cast(^any) ((*block).id), cast(^any) ((*block).location)]))
            if recurse {
                #macro {
                    local arr : &Array[^AstNode] = &(*block).children
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstNode = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    child : &^AstNode = it
                                    it_index : i64 = it_index
                                    {
                                        dump_ast_helper(result, &**child, recurse, (indent + 1))
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            } else {}
        }
        AstBool($num) -> {
            (fmt).format_into(result, "AstBool #{} {} ({})`n", cast([]^any) ([cast(^any) ((*num).id), cast(^any) ((*num).bool_value), cast(^any) ((*num).location)]))
        }
        AstBreak($brake) -> {
            (fmt).format_into(result, "AstBreak #{} ({})`n", cast([]^any) ([cast(^any) ((*brake).id), cast(^any) ((*brake).location)]))
            if recurse {
                if (cast(^void) ((*brake).label) != null) then dump_ast_helper(result, cast(&AstNode) (&*(*brake).label), recurse, (indent + 1)) else {}
                if (cast(^void) ((*brake).value_expr) != null) then dump_ast_helper(result, &*(*brake).value_expr, recurse, (indent + 1)) else {}
            } else {}
        }
        AstCall($call) -> {
            (fmt).format_into(result, "AstCall #{} ({})`n", cast([]^any) ([cast(^any) ((*call).id), cast(^any) ((*call).location)]))
            if recurse {
                dump_ast_helper(result, (*call).function, recurse, (indent + 1))
                #macro {
                    local arr : &Array[^AstArgument] = &(*call).arguments
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstArgument = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    arg : &^AstArgument = it
                                    it_index : i64 = it_index
                                    {
                                        dump_ast_helper(result, cast(&AstNode) (&**arg), recurse, (indent + 1))
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            } else {}
        }
        AstCast($cst) -> {
            (fmt).format_into(result, "AstCast #{} ({})`n", cast([]^any) ([cast(^any) ((*cst).id), cast(^any) ((*cst).location)]))
            if recurse {
                if (cast(^void) ((*cst).type_expr) != null) then dump_ast_helper(result, &*(*cst).type_expr, recurse, (indent + 1)) else {}
                dump_ast_helper(result, (*cst).value_expr, recurse, (indent + 1))
            } else {}
        }
        AstConstDecl($decl) -> {
            (fmt).format_into(result, "AstConstDecl #{} ({})`n", cast([]^any) ([cast(^any) ((*decl).id), cast(^any) ((*decl).location)]))
            if recurse {
                dump_ast_helper(result, (*decl).pattern, recurse, (indent + 1))
                if (cast(^void) ((*decl).type_expr) != null) then dump_ast_helper(result, &*(*decl).type_expr, recurse, (indent + 1)) else {}
                dump_ast_helper(result, (*decl).value_expr, recurse, (indent + 1))
            } else {}
        }
        AstContinue($cont) -> {
            (fmt).format_into(result, "AstContinue #{} ({})`n", cast([]^any) ([cast(^any) ((*cont).id), cast(^any) ((*cont).location)]))
            if recurse {
                if (cast(^void) ((*cont).label) != null) then dump_ast_helper(result, cast(&AstNode) (&*(*cont).label), recurse, (indent + 1)) else {}
            } else {}
        }
        AstDecl($decl) -> {
            (fmt).format_into(result, "AstDecl #{} ({}) {}`n", cast([]^any) ([cast(^any) ((*decl).id), cast(^any) ((*decl).location), cast(^any) (if (*decl).mutable then "mut" else "")]))
            if recurse {
                if (cast(^void) ((*decl).pattern) != null) then dump_ast_helper(result, &*(*decl).pattern, recurse, (indent + 1)) else {}
                if (cast(^void) ((*decl).type_expr) != null) then dump_ast_helper(result, &*(*decl).type_expr, recurse, (indent + 1)) else {}
                if (cast(^void) ((*decl).value_expr) != null) then dump_ast_helper(result, &*(*decl).value_expr, recurse, (indent + 1)) else {}
            } else {}
        }
        AstDefer($def) -> {
            (fmt).format_into(result, "AstDefer #{} ({})`n", cast([]^any) ([cast(^any) ((*def).id), cast(^any) ((*def).location)]))
            if recurse {
                dump_ast_helper(result, (*def).sub, recurse, (indent + 1))
            } else {}
        }
        AstDot($dot) -> {
            (fmt).format_into(result, "AstDot #{} ({})`n", cast([]^any) ([cast(^any) ((*dot).id), cast(^any) ((*dot).location)]))
            if recurse {
                if (cast(^void) ((*dot).sub) != null) then dump_ast_helper(result, &*(*dot).sub, recurse, (indent + 1)) else {}
                dump_ast_helper(result, cast(&AstNode) ((*dot).name), recurse, (indent + 1))
            } else {}
        }
        AstEnum($str) -> {
            (fmt).format_into(result, "AstEnum #{} ({})`n", cast([]^any) ([cast(^any) ((*str).id), cast(^any) ((*str).location)]))
            if recurse {
                #macro {
                    local arr : &Array[^AstNode] = &(*str).children
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstNode = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    child : &^AstNode = it
                                    it_index : i64 = it_index
                                    {
                                        dump_ast_helper(result, &**child, recurse, (indent + 1))
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            } else {}
        }
        AstFor($forr) -> {
            (fmt).format_into(result, "AstFor #{} ({})`n", cast([]^any) ([cast(^any) ((*forr).id), cast(^any) ((*forr).location)]))
            if recurse {
                if (cast(^void) ((*forr).it_pattern) != null) then dump_ast_helper(result, &*(*forr).it_pattern, recurse, (indent + 1)) else {}
                if (cast(^void) ((*forr).index_name) != null) then dump_ast_helper(result, cast(&AstNode) (&*(*forr).index_name), recurse, (indent + 1)) else {}
                dump_ast_helper(result, (*forr).collection, recurse, (indent + 1))
                dump_ast_helper(result, (*forr).body, recurse, (indent + 1))
            } else {}
        }
        AstFunction($func) -> {
            (fmt).format_into(result, "AstFunction #{} ({})`n", cast([]^any) ([cast(^any) ((*func).id), cast(^any) ((*func).location)]))
            if recurse {
                #macro {
                    local msg : string : "params:`n"
                    local amount : i64 = (indent + 1)
                    #macro {
                        local r : Range[i64] = new Range[i64] { start = 0, end = amount }
                        
                        rev : bool = ((r).end < (r).start)
                        inc : i64 = if rev then -1 else 1
                        
                        {
                            @id((it, it_index)_40) : (i64, i64) = ((r).start, 0)
                            it : i64 = @var(@id((it, it_index)_40))[0]
                            it_index : i64 = @var(@id((it, it_index)_40))[1]
                            loop {
                                if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                                defer #anonymous {
                                    it_index = (it_index + 1)
                                    it = (it + inc)
                                }
                                #link #anonymous {
                                    it : i64 = it
                                    it_index : i64 = it_index
                                    {
                                        append_string(result, "  ")
                                    }
                                }
                                #anonymous {
                                    it_index = (it_index + 1)
                                    it = (it + inc)
                                }
                            }
                        }
                    }
                    append_string(result, msg)
                }
                #macro {
                    local arr : &Array[^AstDecl] = &(*func).params
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstDecl = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    param : &^AstDecl = it
                                    it_index : i64 = it_index
                                    {
                                        dump_ast_helper(result, cast(&AstNode) (&**param), recurse, (indent + 2))
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                if (cast(^void) ((*func).return_type_expr) != null) {
                    #macro {
                        local msg : string : "return_type_expr:`n"
                        local amount : i64 = (indent + 1)
                        #macro {
                            local r : Range[i64] = new Range[i64] { start = 0, end = amount }
                            
                            rev : bool = ((r).end < (r).start)
                            inc : i64 = if rev then -1 else 1
                            
                            {
                                @id((it, it_index)_43) : (i64, i64) = ((r).start, 0)
                                it : i64 = @var(@id((it, it_index)_43))[0]
                                it_index : i64 = @var(@id((it, it_index)_43))[1]
                                loop {
                                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                                    defer #anonymous {
                                        it_index = (it_index + 1)
                                        it = (it + inc)
                                    }
                                    #link #anonymous {
                                        it : i64 = it
                                        it_index : i64 = it_index
                                        {
                                            append_string(result, "  ")
                                        }
                                    }
                                    #anonymous {
                                        it_index = (it_index + 1)
                                        it = (it + inc)
                                    }
                                }
                            }
                        }
                        append_string(result, msg)
                    }
                    dump_ast_helper(result, &*(*func).return_type_expr, recurse, (indent + 2))
                } else {}
                if (cast(^void) ((*func).body) != null) {
                    #macro {
                        local msg : string : "body:`n"
                        local amount : i64 = (indent + 1)
                        #macro {
                            local r : Range[i64] = new Range[i64] { start = 0, end = amount }
                            
                            rev : bool = ((r).end < (r).start)
                            inc : i64 = if rev then -1 else 1
                            
                            {
                                @id((it, it_index)_45) : (i64, i64) = ((r).start, 0)
                                it : i64 = @var(@id((it, it_index)_45))[0]
                                it_index : i64 = @var(@id((it, it_index)_45))[1]
                                loop {
                                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                                    defer #anonymous {
                                        it_index = (it_index + 1)
                                        it = (it + inc)
                                    }
                                    #link #anonymous {
                                        it : i64 = it
                                        it_index : i64 = it_index
                                        {
                                            append_string(result, "  ")
                                        }
                                    }
                                    #anonymous {
                                        it_index = (it_index + 1)
                                        it = (it + inc)
                                    }
                                }
                            }
                        }
                        append_string(result, msg)
                    }
                    dump_ast_helper(result, &*(*func).body, recurse, (indent + 2))
                } else {}
            } else {}
        }
        AstIdentifier($id) -> {
            (fmt).format_into(result, "AstIdentifier #{} '{}' ({})`n", cast([]^any) ([cast(^any) ((*id).id), cast(^any) ((*id).name), cast(^any) ((*id).location)]))
        }
        AstIf($iff) -> {
            (fmt).format_into(result, "AstIf #{} ({})`n", cast([]^any) ([cast(^any) ((*iff).id), cast(^any) ((*iff).location)]))
            if recurse {
                dump_ast_helper(result, (*iff).condition, recurse, (indent + 1))
                dump_ast_helper(result, (*iff).true_case, recurse, (indent + 1))
                if (cast(^void) ((*iff).false_case) != null) then dump_ast_helper(result, &*(*iff).false_case, recurse, (indent + 1)) else {}
            } else {}
        }
        AstImpl($imp) -> {
            (fmt).format_into(result, "AstImpl #{} ({})`n", cast([]^any) ([cast(^any) ((*imp).id), cast(^any) ((*imp).location)]))
            if recurse {
                if (cast(^void) ((*imp).trait_expr) != null) then dump_ast_helper(result, &*(*imp).trait_expr, recurse, (indent + 1)) else {}
                dump_ast_helper(result, (*imp).target_expr, recurse, (indent + 1))
                #macro {
                    local arr : &Array[^AstNode] = &(*imp).children
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstNode = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    child : &^AstNode = it
                                    it_index : i64 = it_index
                                    {
                                        dump_ast_helper(result, &**child, recurse, (indent + 2))
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            } else {}
        }
        AstImport($imp) -> {
            (fmt).format_into(result, "AstImport #{} ({})`n", cast([]^any) ([cast(^any) ((*imp).id), cast(^any) ((*imp).location)]))
            if recurse {
                dump_ast_helper(result, (*imp).path, recurse, (indent + 1))
            } else {}
        }
        AstIndex($node) -> {
            (fmt).format_into(result, "AstIndex #{} ({})`n", cast([]^any) ([cast(^any) ((*node).id), cast(^any) ((*node).location)]))
            if recurse {
                dump_ast_helper(result, (*node).sub, recurse, (indent + 1))
                #macro {
                    local arr : &Array[^AstArgument] = &(*node).arguments
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstArgument = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    arg : &^AstArgument = it
                                    it_index : i64 = it_index
                                    {
                                        dump_ast_helper(result, cast(&AstNode) (&**arg), recurse, (indent + 1))
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            } else {}
        }
        AstLoop($lop) -> {
            (fmt).format_into(result, "AstLoop #{} ({})`n", cast([]^any) ([cast(^any) ((*lop).id), cast(^any) ((*lop).location)]))
            if recurse {
                dump_ast_helper(result, (*lop).body, recurse, (indent + 1))
            } else {}
        }
        AstMatch($mat) -> {
            (fmt).format_into(result, "AstMatch #{} ({})`n", cast([]^any) ([cast(^any) ((*mat).id), cast(^any) ((*mat).location)]))
            if recurse {
                if (cast(^void) ((*mat).value_expr) != null) then dump_ast_helper(result, &*(*mat).value_expr, recurse, (indent + 1)) else {}
                #macro {
                    local msg : string : "cases:`n"
                    local amount : i64 = (indent + 1)
                    #macro {
                        local r : Range[i64] = new Range[i64] { start = 0, end = amount }
                        
                        rev : bool = ((r).end < (r).start)
                        inc : i64 = if rev then -1 else 1
                        
                        {
                            @id((it, it_index)_49) : (i64, i64) = ((r).start, 0)
                            it : i64 = @var(@id((it, it_index)_49))[0]
                            it_index : i64 = @var(@id((it, it_index)_49))[1]
                            loop {
                                if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                                defer #anonymous {
                                    it_index = (it_index + 1)
                                    it = (it + inc)
                                }
                                #link #anonymous {
                                    it : i64 = it
                                    it_index : i64 = it_index
                                    {
                                        append_string(result, "  ")
                                    }
                                }
                                #anonymous {
                                    it_index = (it_index + 1)
                                    it = (it + inc)
                                }
                            }
                        }
                    }
                    append_string(result, msg)
                }
                #macro {
                    local arr : &Array[^AstMatchCase] = &(*mat).cases
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstMatchCase = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    case : &^AstMatchCase = it
                                    it_index : i64 = it_index
                                    {
                                        #macro {
                                            local msg : string : "pattern:`n"
                                            local amount : i64 = (indent + 2)
                                            #macro {
                                                local r : Range[i64] = new Range[i64] { start = 0, end = amount }
                                                
                                                rev : bool = ((r).end < (r).start)
                                                inc : i64 = if rev then -1 else 1
                                                
                                                {
                                                    @id((it, it_index)_52) : (i64, i64) = ((r).start, 0)
                                                    it : i64 = @var(@id((it, it_index)_52))[0]
                                                    it_index : i64 = @var(@id((it, it_index)_52))[1]
                                                    loop {
                                                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                                                        defer #anonymous {
                                                            it_index = (it_index + 1)
                                                            it = (it + inc)
                                                        }
                                                        #link #anonymous {
                                                            it : i64 = it
                                                            it_index : i64 = it_index
                                                            {
                                                                append_string(result, "  ")
                                                            }
                                                        }
                                                        #anonymous {
                                                            it_index = (it_index + 1)
                                                            it = (it + inc)
                                                        }
                                                    }
                                                }
                                            }
                                            append_string(result, msg)
                                        }
                                        dump_ast_helper(result, (**case).pattern, recurse, (indent + 3))
                                        if (cast(^void) ((**case).condition) != null) {
                                            #macro {
                                                local msg : string : "condition:`n"
                                                local amount : i64 = (indent + 2)
                                                #macro {
                                                    local r : Range[i64] = new Range[i64] { start = 0, end = amount }
                                                    
                                                    rev : bool = ((r).end < (r).start)
                                                    inc : i64 = if rev then -1 else 1
                                                    
                                                    {
                                                        @id((it, it_index)_54) : (i64, i64) = ((r).start, 0)
                                                        it : i64 = @var(@id((it, it_index)_54))[0]
                                                        it_index : i64 = @var(@id((it, it_index)_54))[1]
                                                        loop {
                                                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                                                            defer #anonymous {
                                                                it_index = (it_index + 1)
                                                                it = (it + inc)
                                                            }
                                                            #link #anonymous {
                                                                it : i64 = it
                                                                it_index : i64 = it_index
                                                                {
                                                                    append_string(result, "  ")
                                                                }
                                                            }
                                                            #anonymous {
                                                                it_index = (it_index + 1)
                                                                it = (it + inc)
                                                            }
                                                        }
                                                    }
                                                }
                                                append_string(result, msg)
                                            }
                                            dump_ast_helper(result, &*(**case).condition, recurse, (indent + 3))
                                        } else {}
                                        #macro {
                                            local msg : string : "body:`n"
                                            local amount : i64 = (indent + 2)
                                            #macro {
                                                local r : Range[i64] = new Range[i64] { start = 0, end = amount }
                                                
                                                rev : bool = ((r).end < (r).start)
                                                inc : i64 = if rev then -1 else 1
                                                
                                                {
                                                    @id((it, it_index)_56) : (i64, i64) = ((r).start, 0)
                                                    it : i64 = @var(@id((it, it_index)_56))[0]
                                                    it_index : i64 = @var(@id((it, it_index)_56))[1]
                                                    loop {
                                                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                                                        defer #anonymous {
                                                            it_index = (it_index + 1)
                                                            it = (it + inc)
                                                        }
                                                        #link #anonymous {
                                                            it : i64 = it
                                                            it_index : i64 = it_index
                                                            {
                                                                append_string(result, "  ")
                                                            }
                                                        }
                                                        #anonymous {
                                                            it_index = (it_index + 1)
                                                            it = (it + inc)
                                                        }
                                                    }
                                                }
                                            }
                                            append_string(result, msg)
                                        }
                                        dump_ast_helper(result, (**case).body, recurse, (indent + 3))
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            } else {}
        }
        AstNull($num) -> {
            (fmt).format_into(result, "AstNull #{} ({})`n", cast([]^any) ([cast(^any) ((*num).id), cast(^any) ((*num).location)]))
        }
        AstNumberLiteral($num) -> {
            (fmt).format_into(result, "AstNumberLiteral #{} {} ({})`n", cast([]^any) ([cast(^any) ((*num).id), cast(^any) ((*num).value), cast(^any) ((*num).location)]))
        }
        AstPoly($poly) -> {
            (fmt).format_into(result, "AstPoly #{} ({})`n", cast([]^any) ([cast(^any) ((*poly).id), cast(^any) ((*poly).location)]))
            if recurse {
                #macro {
                    local arr : &Array[^AstDecl] = &(*poly).params
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstDecl = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    param : &^AstDecl = it
                                    it_index : i64 = it_index
                                    {
                                        dump_ast_helper(result, cast(&AstNode) (&**param), recurse, (indent + 2))
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                dump_ast_helper(result, (*poly).value_expr, recurse, (indent + 1))
            } else {}
        }
        AstReturn($ret) -> {
            (fmt).format_into(result, "AstReturn #{} ({})`n", cast([]^any) ([cast(^any) ((*ret).id), cast(^any) ((*ret).location)]))
            if recurse {
                if (cast(^void) ((*ret).value_expr) != null) then dump_ast_helper(result, &*(*ret).value_expr, recurse, (indent + 1)) else {}
            } else {}
        }
        AstString($num) -> {
            (fmt).format_into(result, "AstString #{} '{}' ({})`n", cast([]^any) ([cast(^any) ((*num).id), cast(^any) ((*num).string_value), cast(^any) ((*num).location)]))
        }
        AstStruct($str) -> {
            (fmt).format_into(result, "AstStruct #{} ({})`n", cast([]^any) ([cast(^any) ((*str).id), cast(^any) ((*str).location)]))
            if recurse {
                if (cast(^void) ((*str).trait_expr) != null) then dump_ast_helper(result, &*(*str).trait_expr, recurse, (indent + 2)) else {}
                #macro {
                    local msg : string : "children:"
                    local amount : i64 = (indent + 1)
                    #macro {
                        local r : Range[i64] = new Range[i64] { start = 0, end = amount }
                        
                        rev : bool = ((r).end < (r).start)
                        inc : i64 = if rev then -1 else 1
                        
                        {
                            @id((it, it_index)_59) : (i64, i64) = ((r).start, 0)
                            it : i64 = @var(@id((it, it_index)_59))[0]
                            it_index : i64 = @var(@id((it, it_index)_59))[1]
                            loop {
                                if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                                defer #anonymous {
                                    it_index = (it_index + 1)
                                    it = (it + inc)
                                }
                                #link #anonymous {
                                    it : i64 = it
                                    it_index : i64 = it_index
                                    {
                                        append_string(result, "  ")
                                    }
                                }
                                #anonymous {
                                    it_index = (it_index + 1)
                                    it = (it + inc)
                                }
                            }
                        }
                    }
                    append_string(result, msg)
                }
                #macro {
                    local arr : &Array[^AstNode] = &(*str).children
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstNode = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    child : &^AstNode = it
                                    it_index : i64 = it_index
                                    {
                                        dump_ast_helper(result, &**child, recurse, (indent + 2))
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            } else {}
        }
        AstTrait($str) -> {
            (fmt).format_into(result, "AstTrait #{} ({})`n", cast([]^any) ([cast(^any) ((*str).id), cast(^any) ((*str).location)]))
            if recurse {
                #macro {
                    local arr : &Array[^AstNode] = &(*str).children
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstNode = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    child : &^AstNode = it
                                    it_index : i64 = it_index
                                    {
                                        dump_ast_helper(result, &**child, recurse, (indent + 1))
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            } else {}
        }
        AstTuple($tuple) -> {
            (fmt).format_into(result, "AstTuple #{} ({})`n", cast([]^any) ([cast(^any) ((*tuple).id), cast(^any) ((*tuple).location)]))
            if recurse {
                #macro {
                    local arr : &Array[^AstNode] = &(*tuple).values
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstNode = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    val : &^AstNode = it
                                    it_index : i64 = it_index
                                    {
                                        dump_ast_helper(result, &**val, recurse, (indent + 1))
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            } else {}
        }
        AstUfc($ufc) -> {
            (fmt).format_into(result, "AstUfc #{} ({})`n", cast([]^any) ([cast(^any) ((*ufc).id), cast(^any) ((*ufc).location)]))
            if recurse {
                dump_ast_helper(result, (*ufc).value_expr, recurse, (indent + 1))
            } else {}
        }
        AstUnary($un) -> {
            (fmt).format_into(result, "AstUnary #{} {} ({})`n", cast([]^any) ([cast(^any) ((*un).id), cast(^any) ((*un).operator), cast(^any) ((*un).location)]))
            if recurse {
                dump_ast_helper(result, (*un).sub, recurse, (indent + 1))
            } else {}
        }
        AstUse($us) -> {
            (fmt).format_into(result, "AstUse #{} ({})`n", cast([]^any) ([cast(^any) ((*us).id), cast(^any) ((*us).location)]))
            if recurse {
                dump_ast_helper(result, (*us).value_expr, recurse, (indent + 1))
            } else {}
        }
        $node -> {
            (fmt).format_into(result, "[ERROR] {}: node type not implemented`n", cast([]^any) ([cast(^any) (0)]))
        }
    }
}

#file bytecode_generator.che
use import std.array

use import std.map

use import std.rc

use import std.string

mem :  : import std.mem.allocator

io :  : import std.io

fmt :  : import std.fmt

use import logging.logger

use import ast

use import ast_dumper

use import error_handler

use import interpreter

use import lexer

use import string_database

use import types

use import value

CodeGenerator :: trait {
    generate_code_for_function :: f.Accept(this)
}

ByteCodeGenerator :: struct { // size: 184, alignment: 8
    strings : &StringDatabase
    error_handler : &ErrorHandler
    allocator : ^Allocator
    builder : InstructionBuilder
    variables : Map[i64, i64] = (Map[int, int]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    function : ^AstFunction = null
    build_range_checks : bool = true
    build_null_checks : bool = true
}

impl ByteCodeGenerator {
    new(strings: &StringDatabase, error_handler: &ErrorHandler, allocator: ^Allocator) -> Rc[ByteCodeGenerator] {
        return (Rc[ByteCodeGenerator]).new(new ByteCodeGenerator {
            strings = strings
            error_handler = error_handler
            allocator = allocator
            builder = (InstructionBuilder).new(strings)
            variables = (Map[int, int]).new(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            function = null
            build_range_checks = true
            build_null_checks = true
        })
    }
    
    allocate_function(self: &ByteCodeGenerator, name: string, path: string) -> ^CBCFunction {
        func : ^CBCFunction = (mem).alloc(allocator)
        *func = new CBCFunction {
            ast_function = function
            debug_info = new CBCDebugInfo { path = path.to_owned(), locations = (Array[LineInfo]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)), locals = (Array[VariableInfo]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)), params = (Array[VariableInfo]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) }
            instructions = (Array[u64]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            parameter_indices = (Array[int]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            parameter_slots = 0
            local_slots = 0
        }
        return func
    }
}

impl CodeGenerator for ByteCodeGenerator {
    generate_code_for_function(self: &ByteCodeGenerator, func: ^AstFunction) {
        if (cast(^void) (function) != null) {
            error_handler.report_error_at((*func).location, "Failed to generate code for this function because we're already generating code for another function at {}", cast([]^any) ([cast(^any) ((*function).location)]), "", cast([](fmt: string, args: []^any)) ([]))
            return
        } else {}
        function = func
        defer function <- null
        file_path : string = ((*func).location).file
        cbc_func : ^CBCFunction = self.allocate_function((*func).name, file_path)
        &builder.begin_function(cbc_func)
        slot_index : i64 = 0
        #macro {
            local arr : &Array[^AstDecl] = &(*func).params
            
            local reverse : bool : true
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it_index_rev : i64 = (((*arr).length - it_index) - 1)
                        #anonymous {
                            it : &^AstDecl = access(&*arr, it_index_rev)
                        }
                        #link #anonymous {
                            param : &^AstDecl = it
                            it_index : i64 = it_index
                            {
                                slot_index = (slot_index - slots_for_size((*(**param).var_type).size))
                                &variables.set((**param).id, slot_index)
                                &((*cbc_func).debug_info).params.add(new VariableInfo { id = (**param).id, name = (**param).name, index = slot_index, type_info = (**param).var_type })
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        (*cbc_func).parameter_slots = -slot_index
        self.generate_expression(&*(*func).body, true)
        &builder.set_location((*(*func).body).location.end())
        &builder.build_return_void()
        &builder.end_function()
        (*func).bytecode = cbc_func
        function <- null
    }
    
    generate_code_for_expression(self: &ByteCodeGenerator, node: &AstNode) -> ^CBCFunction {
        file_path : string = ((*node).location).file
        cbc_func : ^CBCFunction = self.allocate_function("$expr", file_path)
        &builder.begin_function(cbc_func)
        self.generate_expression(node, true)
        &builder.build_store_stack(0, slots_for_size((*(*node).typ).size))
        &builder.build_halt()
        &builder.end_function()
        return cbc_func
    }
    
    generate_expression(self: &ByteCodeGenerator, node: &AstNode, deref: bool = true) {
        &builder.set_location((*node).location)
        match @tempvar_503(node) {
            AstArgument($arg) -> self.generate_argument(arg)
            AstArray($arr) -> self.generate_array(arr)
            AstAssignment($ass) -> self.generate_assignment(ass)
            AstBinary($bin) -> self.generate_binary(bin)
            AstBlock($block) -> self.generate_block(block)
            AstBool($bol) -> self.generate_bool(bol)
            AstBreak($brake) -> self.generate_break(brake)
            AstCall($call) -> self.generate_call(call)
            AstCast($cst) -> self.generate_cast(cst)
            AstConstDecl($decl) -> self.generate_const_decl(decl)
            AstContinue($cont) -> self.generate_continue(cont)
            AstDecl($decl) -> self.generate_decl(decl)
            AstDefer($def) -> self.generate_defer(def)
            AstDot($dot) -> self.generate_dot(dot, deref)
            AstFor($forr) -> self.generate_for(forr)
            AstIdentifier($id) -> self.generate_identifier(id, deref)
            AstIf($iff) -> self.generate_if(iff)
            AstIndex($index) -> self.generate_index(index)
            AstLoop($lop) -> self.generate_loop(lop)
            AstNumberLiteral($num) -> self.generate_number_literal(num)
            AstReturn($ret) -> self.generate_return(ret)
            AstString($str) -> self.generate_string(str)
            AstUnary($un) -> self.generate_unary(un)
            _ -> {
                dump : String = dump_ast(node, recurse = false)
                error_handler.report_error("generate_expression: not implemented: {}", cast([]^any) ([cast(^any) (dump)]), "", cast([](fmt: string, args: []^any)) ([]))
                @destruct(dump)
            }
        }
    }
    
    generate_const_decl(self: &ByteCodeGenerator, decl: &AstConstDecl) {}
    
    generate_assignment(self: &ByteCodeGenerator, ass: &AstAssignment) {
        match @tempvar_527((*ass).pattern) {
            AstIdentifier($id) -> match @tempvar_529((*id).symbol) {
                Symbol.Decl($decl) -> {
                    self.generate_expression((*ass).value_expr, true)
                    &builder.set_location((*ass).location)
                    &builder.build_store_local(*get_unchecked(&(*self).variables, (*decl).id), slots_for_size((*(*(*ass).value_expr).typ).size))
                }
                _ -> {
                    error_handler.report_error_at((*(*ass).pattern).location, "generate_assignment: symbol not implemented: {}", cast([]^any) ([cast(^any) ((*id).symbol)]), "", cast([](fmt: string, args: []^any)) ([]))
                }
            }
            AstIndex($node) -> {
                match @tempvar_531((*(*node).sub).typ) {
                    TypeInfoArray($ti) -> match @tempvar_533((*(*node).index).typ) {
                        TypeInfoInt(_) -> {
                            self.generate_expression((*node).sub, deref = false)
                            self.generate_expression(&*(*node).index, true)
                            if (*self).build_range_checks {
                                &builder.build_const_int(0)
                                &builder.build_const_int((*ti).count)
                                &builder.build_check_range()
                            } else {}
                            &builder.build_const_int((*(*ti).target).size)
                            &builder.build_mul(InstNumTyp.I64)
                            &builder.build_add(InstNumTyp.I64)
                            self.generate_expression((*ass).value_expr, true)
                            &builder.build_store(slots_for_size((*(*ti).target).size))
                        }
                        _ -> {
                            error_handler.report_error_at((*(*node).index).location, "generate_assignment not implemented for index: ({})[{}]", cast([]^any) ([cast(^any) ((*(*node).sub).typ), cast(^any) ((*(*node).index).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                        }
                    }
                    _ -> {
                        error_handler.report_error_at((*(*node).sub).location, "generate_assignment not implemented for index: '{}'", cast([]^any) ([cast(^any) ((*(*node).sub).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                    }
                }
            }
            AstDot($dot) if ((*dot).symbol == Symbol.StructMember) -> {
                member : ^TypeInfoStructMember = ((*dot).symbol).StructMember
                self.generate_expression(&*(*dot).sub, deref = false)
                &builder.build_const_int((*member).offset)
                &builder.build_add(InstNumTyp.I64)
                self.generate_expression((*ass).value_expr, true)
                &builder.build_store(slots_for_size((*(*dot).typ).size))
            }
            AstUnary($un) if ((*un).operator == UnOp.Deref) -> {
                self.generate_expression((*un).sub, true)
                self.generate_expression((*ass).value_expr, true)
                &builder.build_store(slots_for_size((*(*un).typ).size))
            }
            _ -> {
                error_handler.report_error_at((*(*ass).pattern).location, "generate_assignment: pattern not implemented", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
            }
        }
    }
    
    generate_array(self: &ByteCodeGenerator, arr: &AstArray) {
        &builder.set_location((*arr).location)
        &builder.build_push(slots_for_size((*(*arr).typ).size))
        &builder.build_load_address()
        #macro {
            local arr : &Array[^AstNode] = &(*arr).values
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &^AstNode = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            val : &^AstNode = it
                            it_index : i64 = it_index
                            {
                                &builder.build_dup(1)
                                self.generate_expression(&**val, true)
                                &builder.build_store(slots_for_size((*(**val).typ).size))
                                &builder.build_const_int((slots_for_size((*(**val).typ).size) * @sizeof(u64)))
                                &builder.build_add(InstNumTyp.U64)
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        &builder.build_pop(1)
    }
    
    generate_decl(self: &ByteCodeGenerator, decl: &AstDecl) {
        &builder.set_location((*decl).location)
        &builder.build_noop()
        index : i64 = &builder.add_local((*decl).id, (*decl).name, (*decl).var_type)
        &variables.set((*decl).id, index)
        if (cast(^void) ((*decl).value_expr) != null) {
            self.generate_expression(&*(*decl).value_expr, true)
            &builder.build_store_local(index, slots_for_size((*(*decl).var_type).size))
        } else {}
    }
    
    generate_unary(self: &ByteCodeGenerator, un: &AstUnary) {
        match @tempvar_537((*un).operator) {
            UnOp.Not -> {
                self.generate_expression((*un).sub, true)
                &builder.set_location((*un).location)
                &builder.build_not()
            }
            UnOp.Neg -> {
                self.generate_expression((*un).sub, true)
                &builder.set_location((*un).location)
                &builder.build_neg(type_info_to_inst_number_type((*(*un).sub).typ))
            }
            UnOp.Ptr -> {
                self.generate_expression((*un).sub, deref = false)
            }
            UnOp.PtrMut -> {
                self.generate_expression((*un).sub, deref = false)
            }
            UnOp.Ref -> {
                self.generate_expression((*un).sub, deref = false)
            }
            UnOp.RefMut -> {
                self.generate_expression((*un).sub, deref = false)
            }
            UnOp.Deref -> {
                self.generate_expression((*un).sub, true)
                &builder.build_load(slots_for_size((*(*un).typ).size))
            }
            _ -> error_handler.report_error_at((*un).location, "Code gen for unary not implemented", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
        }
    }
    
    generate_binary(self: &ByteCodeGenerator, bin: &AstBinary) {
        self.generate_expression((*bin).left, true)
        self.generate_expression((*bin).right, true)
        &builder.set_location((*bin).location)
        match @tempvar_538((*bin).operator) {
            BinOp.Add -> &builder.build_add(type_info_to_inst_number_type((*bin).typ))
            BinOp.Sub -> &builder.build_sub(type_info_to_inst_number_type((*bin).typ))
            BinOp.Mul -> &builder.build_mul(type_info_to_inst_number_type((*bin).typ))
            BinOp.Div -> &builder.build_div(type_info_to_inst_number_type((*bin).typ))
            BinOp.Mod -> &builder.build_mod(type_info_to_inst_number_type((*bin).typ))
            BinOp.Equal -> &builder.build_ieq(type_info_to_inst_number_type((*(*bin).left).typ))
            BinOp.NotEqual -> &builder.build_ine(type_info_to_inst_number_type((*(*bin).left).typ))
            BinOp.Less -> &builder.build_ilt(type_info_to_inst_number_type((*(*bin).left).typ))
            BinOp.LessEq -> &builder.build_ile(type_info_to_inst_number_type((*(*bin).left).typ))
            BinOp.Greater -> &builder.build_igt(type_info_to_inst_number_type((*(*bin).left).typ))
            BinOp.GreaterEq -> &builder.build_ige(type_info_to_inst_number_type((*(*bin).left).typ))
            BinOp.And -> &builder.build_and()
            BinOp.Or -> &builder.build_or()
            BinOp.Move -> {
                error_handler.report_error_at((*bin).location, "Binary operator {} implemented", cast([]^any) ([cast(^any) ((*bin).operator)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
            BinOp.Pipe -> {
                error_handler.report_error_at((*bin).location, "Binary operator {} implemented", cast([]^any) ([cast(^any) ((*bin).operator)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
            BinOp.Range -> {
                error_handler.report_error_at((*bin).location, "Binary operator {} implemented", cast([]^any) ([cast(^any) ((*bin).operator)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
            BinOp.RangeIncl -> {
                error_handler.report_error_at((*bin).location, "Binary operator {} implemented", cast([]^any) ([cast(^any) ((*bin).operator)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
        }
    }
    
    generate_if(self: &ByteCodeGenerator, iff: &AstIf) {
        &builder.set_location((*iff).location)
        self.generate_expression((*iff).condition, true)
        br_true : i64 = &builder.build_branch_if(0)
        if (cast(^void) ((*iff).false_case) != null) {
            self.generate_expression(&*(*iff).false_case, true)
        } else {
            &builder.set_location((*iff).location)
            &builder.build_const_int(0)
        }
        br_end : i64 = &builder.build_branch(0)
        l_true : i64 = &builder.next()
        self.generate_expression((*iff).true_case, true)
        l_end : i64 = &builder.next()
        &builder.fix_branch(br_true, l_true)
        &builder.fix_branch(br_end, l_end)
    }
    
    generate_index(self: &ByteCodeGenerator, node: &AstIndex) {
        match @tempvar_539((*(*node).sub).typ) {
            TypeInfoArray($ti) -> match @tempvar_541((*(*node).index).typ) {
                TypeInfoInt(_) -> {
                    self.generate_expression((*node).sub, deref = false)
                    self.generate_expression(&*(*node).index, true)
                    if (*self).build_range_checks {
                        &builder.build_const_int(0)
                        &builder.build_const_int((*ti).count)
                        &builder.build_check_range()
                    } else {}
                    &builder.build_const_int((*(*ti).target).size)
                    &builder.build_mul(InstNumTyp.I64)
                    &builder.build_add(InstNumTyp.I64)
                    &builder.build_load(slots_for_size((*(*ti).target).size))
                }
                _ -> {
                    error_handler.report_error_at((*(*node).index).location, "generate_index not implemented for: ({})[{}]", cast([]^any) ([cast(^any) ((*(*node).sub).typ), cast(^any) ((*(*node).index).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
                }
            }
            _ -> {
                error_handler.report_error_at((*(*node).sub).location, "generate_index not implemented for: '{}'", cast([]^any) ([cast(^any) ((*(*node).sub).typ)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
        }
    }
    
    generate_loop(self: &ByteCodeGenerator, lop: &AstLoop) {
        &builder.set_location((*lop).location)
        loop_start : i64 = &builder.next()
        self.generate_expression((*lop).body, true)
        &builder.build_pop(slots_for_size((*(*(*lop).body).typ).size))
        &builder.build_branch(loop_start)
    }
    
    generate_for(self: &ByteCodeGenerator, forr: &AstFor) {
        &builder.set_location((*forr).location)
        &builder.build_const_int(0)
    }
    
    generate_break(self: &ByteCodeGenerator, brake: &AstBreak) {
        &builder.set_location((*brake).location)
        &builder.build_const_int(0)
    }
    
    generate_continue(self: &ByteCodeGenerator, cont: &AstContinue) {
        &builder.set_location((*cont).location)
        &builder.build_const_int(0)
    }
    
    generate_return(self: &ByteCodeGenerator, ret: &AstReturn) {
        &builder.set_location((*ret).location)
        if (cast(^void) ((*ret).value_expr) != null) {
            self.generate_expression(&*(*ret).value_expr, true)
            &builder.set_location((*ret).location)
            &builder.build_return()
        } else {
            &builder.build_return_void()
        }
    }
    
    generate_dot(self: &ByteCodeGenerator, dot: &AstDot, deref: bool) {
        &builder.set_location((*dot).location)
        name : string = (*(*dot).name).name
        match @tempvar_543((*(*dot).sub).typ) {
            TypeInfoArray($ti) -> {
                if (strings_equal(name, "length") or strings_equal(name, "count")) {
                    &builder.build_const_int((*ti).count)
                } else if strings_equal(name, "data") {
                    error_handler.report_error_at((*dot).location, "generate_dot: not implemented: {}.{}", cast([]^any) ([cast(^any) ((*(*dot).sub).typ), cast(^any) ((*(*dot).name).name)]), "", cast([](fmt: string, args: []^any)) ([]))
                } else {
                    @assert(false)
                }
            }
            TypeInfoStruct($ti) -> {
                member : ^TypeInfoStructMember = ((*dot).symbol).StructMember
                self.generate_expression(&*(*dot).sub, deref = false)
                &builder.build_const_int((*member).offset)
                &builder.build_add(InstNumTyp.I64)
                if deref {
                    &builder.build_load(slots_for_size((*(*dot).typ).size))
                } else {}
            }
            _ -> {
                error_handler.report_error_at((*dot).location, "generate_dot: not implemented: {}.{}", cast([]^any) ([cast(^any) ((*(*dot).sub).typ), cast(^any) ((*(*dot).name).name)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
        }
    }
    
    generate_defer(self: &ByteCodeGenerator, def: &AstDefer) {
        error_handler.report_error_at((*def).location, "generate_defer: not implemented", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
        &builder.set_location((*def).location)
        &builder.build_const_int(0)
    }
    
    generate_bool(self: &ByteCodeGenerator, bol: &AstBool) {
        &builder.set_location((*bol).location)
        &builder.build_const_int(if (*bol).bool_value then 1 else 0)
    }
    
    generate_string(self: &ByteCodeGenerator, str: &AstString) {
        &builder.set_location((*str).location)
        &builder.build_const_int((((*str).string_value).bytes).length)
        &builder.build_const_int(cast ((((*str).string_value).bytes).data))
    }
    
    generate_argument(self: &ByteCodeGenerator, arg: &AstArgument) {
        self.generate_expression((*arg).value_expr, true)
    }
    
    generate_block(self: &ByteCodeGenerator, block: &AstBlock) {
        &builder.set_location((*block).location)
        #macro {
            local arr : &Array[^AstNode] = &(*block).children
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &^AstNode = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            child : &^AstNode = it
                            it_index : i64 = it_index
                            {
                                self.generate_expression(&**child, true)
                                if ((it_index < (&(*block).children.count() - 1)) and (cast(^void) ((**child).typ) != cast(^void) (@type_info(void)))) {
                                    &builder.build_pop(slots_for_size((*(**child).typ).size))
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        &builder.set_location((*block).location.end())
        &builder.build_noop()
    }
    
    generate_cast(self: &ByteCodeGenerator, cst: &AstCast) {
        from : ^TypeInfo = (*(*cst).value_expr).typ
        to : ^TypeInfo = (*cst).typ
        self.generate_expression((*cst).value_expr, true)
        &builder.set_location((*cst).location)
        match @tempvar_546((from, to)) {
            (TypeInfoFloat($from), TypeInfoFloat($to)) -> {
                if ((*from).size < (*to).size) {
                    &builder.build_cast_float_to_double()
                } else if ((*from).size > (*to).size) {
                    &builder.build_cast_double_to_float()
                } else {}
            }
            (TypeInfoInt($from), TypeInfoInt($to)) -> {
                match @tempvar_551(((*from).signed, (*to).signed)) {
                    (true, true) -> &builder.build_cast_signed(type_info_to_inst_number_type(cast(^TypeInfo) (from)), type_info_to_inst_number_type(cast(^TypeInfo) (to)))
                    (false, false) -> &builder.build_cast_unsigned(type_info_to_inst_number_type(cast(^TypeInfo) (from)), type_info_to_inst_number_type(cast(^TypeInfo) (to)))
                    (true, false) -> {
                        &builder.build_cast_signed(type_info_to_inst_number_type(cast(^TypeInfo) (from)), InstNumTyp.I64)
                        &builder.build_cast_signed_to_unsigned()
                        &builder.build_cast_unsigned(InstNumTyp.U64, type_info_to_inst_number_type(cast(^TypeInfo) (to)))
                    }
                    (false, true) -> {
                        &builder.build_cast_unsigned(type_info_to_inst_number_type(cast(^TypeInfo) (from)), InstNumTyp.U64)
                        &builder.build_cast_unsigned_to_signed()
                        &builder.build_cast_signed(InstNumTyp.I64, type_info_to_inst_number_type(cast(^TypeInfo) (to)))
                    }
                }
            }
            (TypeInfoFloat($from), TypeInfoInt($to)) -> {
                if ((*from).size != 8) then &builder.build_cast_float_to_double() else {}
                if (*to).signed then &builder.build_cast_double_to_signed() else &builder.build_cast_double_to_unsigned()
                if ((*to).size != 8) {
                    if (*to).signed then &builder.build_cast_signed(InstNumTyp.I64, type_info_to_inst_number_type(cast(^TypeInfo) (to))) else &builder.build_cast_unsigned(InstNumTyp.U64, type_info_to_inst_number_type(cast(^TypeInfo) (to)))
                } else {}
            }
            (TypeInfoInt($from), TypeInfoFloat($to)) -> {
                if ((*from).size != 8) {
                    if (*from).signed then &builder.build_cast_signed(type_info_to_inst_number_type(cast(^TypeInfo) (from)), InstNumTyp.I64) else &builder.build_cast_unsigned(type_info_to_inst_number_type(cast(^TypeInfo) (from)), InstNumTyp.U64)
                } else {}
                if (*from).signed then &builder.build_cast_signed_to_double() else &builder.build_cast_unsigned_to_double()
                if ((*to).size != 8) {
                    &builder.build_cast_double_to_float()
                } else {}
            }
            _ -> {
                error_handler.report_error_at((*cst).location, "generate_cast: not implemented: ({}) to ({})", cast([]^any) ([cast(^any) (from), cast(^any) (to)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
        }
    }
    
    generate_call(self: &ByteCodeGenerator, call: &AstCall) {
        &builder.set_location((*call).location)
        &builder.build_noop()
        match @tempvar_556((*(*call).function).value) {
            Value.Function($func) -> {
                #macro {
                    local arr : &Array[^AstArgument] = &(*call).arguments
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstArgument = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    arg : &^AstArgument = it
                                    it_index : i64 = it_index
                                    {
                                        self.generate_expression(cast(&AstNode) (&**arg), true)
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                &builder.set_location((*call).location)
                &builder.build_comp_call((*call).ast_function)
            }
            Value.NativeFunc($func) -> {
                #macro {
                    local arr : &Array[^AstArgument] = &(*call).arguments
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstArgument = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    arg : &^AstArgument = it
                                    it_index : i64 = it_index
                                    {
                                        self.generate_expression(cast(&AstNode) (&**arg), true)
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                &builder.set_location((*call).location)
                &builder.build_native_call(func)
            }
            Value.NativeFunc2($func) -> {
                #macro {
                    local arr : &Array[^AstArgument] = &(*call).arguments
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < arr.get_length()) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                #anonymous {
                                    it : &^AstArgument = access(&*arr, it_index)
                                }
                                #link #anonymous {
                                    arg : &^AstArgument = it
                                    it_index : i64 = it_index
                                    {
                                        self.generate_expression(cast(&AstNode) (&**arg), true)
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                &builder.set_location((*call).location)
                &builder.build_native_call2((func).wrapper, (func).func, (NativeFunctionWrapper).slots_for_type(cast ((*(*call).function).typ)))
            }
            _ -> {
                error_handler.report_error_at((*(*call).function).location, "generate_call: Can't call {}", cast([]^any) ([cast(^any) ((*(*call).function).value)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
        }
    }
    
    generate_number_literal(self: &ByteCodeGenerator, num: &AstNumberLiteral) {
        &builder.set_location((*num).location)
        match @tempvar_557((*num).value) {
            Value.Int($i) -> &builder.build_const_int(i)
            Value.Float($f) -> &builder.build_const_float(f)
        }
    }
    
    generate_identifier(self: &ByteCodeGenerator, id: &AstIdentifier, deref: bool) {
        &builder.set_location((*id).location)
        match @tempvar_558((*id).symbol) {
            Symbol.Decl($decl) -> match @tempvar_559(&(*self).variables.get((*decl).id)) {
                Option[&i64].Some($index) -> {
                    if deref {
                        &builder.build_load_local(*index, slots_for_size((*(*decl).var_type).size))
                    } else {
                        &builder.build_address_of(*index)
                    }
                }
                Option[&i64].None -> {
                    msg : string_literal : "[FATAL] Failed to get index of declaration"
                    &builder.build_panic(msg)
                    error_handler.report_error_at((*id).location, msg, cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
                }
            }
            Symbol.ConstDecl($decl) -> match @tempvar_560((*decl).value) {
                Value.Int($i) -> &builder.build_const_int(i)
                Value.Float($f) -> &builder.build_const_float(f)
                Value.Bool($b) -> &builder.build_const_int(if b then 1 else 0)
                Value.String($s) -> {
                    &builder.build_const_int(((s).bytes).length)
                    &builder.build_const_int(cast (((s).bytes).data))
                }
            }
            Symbol.Val($val) -> match @tempvar_561((val).value) {
                Value.Int($i) -> &builder.build_const_int(i)
                Value.Float($f) -> &builder.build_const_float(f)
                Value.Bool($b) -> &builder.build_const_int(if b then 1 else 0)
                Value.String($s) -> {
                    &builder.build_const_int(((s).bytes).length)
                    &builder.build_const_int(cast (((s).bytes).data))
                }
            }
            _ -> {
                error_handler.report_error_at((*id).location, "generate_identifier: not implemented: {}", cast([]^any) ([cast(^any) ((*id).symbol)]), "", cast([](fmt: string, args: []^any)) ([]))
            }
        }
    }
}

InstructionBuilder :: struct { // size: 80, alignment: 8
    function : ^CBCFunction
    current_location : Location
    strings : &StringDatabase
}

impl InstructionBuilder {
    new(strings: &StringDatabase) -> InstructionBuilder {
        return new InstructionBuilder { function = null, current_location = new Location {
            line = -1
            column = -1
            file = default
            byte_index = default
            byte_length = default
            end_column = default
            end_line = default
        }, strings = strings }
    }
    
    begin_function(self: &InstructionBuilder, func: ^CBCFunction) {
        current_location = new Location {
            line = -1
            column = -1
            file = default
            byte_index = default
            byte_length = default
            end_column = default
            end_line = default
        }
        function = func
    }
    
    end_function(self: &InstructionBuilder) {
        function = null
    }
    
    code_view(self: &InstructionBuilder) -> []u64 {
        return &(*function).instructions.slice()
    }
    
    fix_branch(self: &InstructionBuilder, branch: i64, address: i64) {
        *access(&(*function).instructions, branch) = cast(u64) (address)
    }
    
    set_location(self: &InstructionBuilder, location: Location) {
        locations : &Array[LineInfo] = &((*function).debug_info).locations
        if ((locations.count() > 0) and ((*locations.peek_last()).count == 0)) {
            (*locations.peek_last()).location = location
        } else if (((current_location).line != (location).line) or ((current_location).column != (location).column)) {
            &((*function).debug_info).locations.add(new LineInfo { location = location, count = 0 })
        } else {}
        current_location = location
    }
    
    add_local(self: &InstructionBuilder, id: i64, name: string, type_info: ^TypeInfo) -> i64 {
        &((*function).debug_info).locals.add(new VariableInfo { id = id, name = name, index = (*function).local_slots, type_info = type_info })
        current_size : i64 = (*function).local_slots
        (@tempvar_562(*function)).local_slots = ((@tempvar_562(*function)).local_slots + slots_for_size((*type_info).size))
        return current_size
    }
    
    next(self: &InstructionBuilder) -> i64 {
        return &(*function).instructions.get_length()
    }
    
    add_debug_info_line() #macro #transparent {
        @assert(((((function).debug_info).locations).count() > 0))
        current_instruction_count :  = ((function).instructions).count()
        defer {
            new_instruction_count :  = ((function).instructions).count()
            ((((function).debug_info).locations).peek_last()).count = (new_instruction_count - current_instruction_count)
        }
    }
    
    build_noop(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_563(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_563(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Noop))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_563(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_563(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_push(self: &InstructionBuilder, slots: i64) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_564(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_564(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Push))
        &(*function).instructions.add(cast (slots))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_564(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_564(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_pop(self: &InstructionBuilder, slots: i64) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_565(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_565(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Pop))
        &(*function).instructions.add(cast (slots))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_565(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_565(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_dup(self: &InstructionBuilder, slots: i64) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_566(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_566(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Dup))
        &(*function).instructions.add(cast (slots))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_566(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_566(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_const_int(self: &InstructionBuilder, value: i64) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_567(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_567(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.ConstInt))
        &(*function).instructions.add(cast (value))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_567(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_567(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_const_float(self: &InstructionBuilder, value: f64) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_568(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_568(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.ConstFloat))
        &(*function).instructions.add(*cast(^u64) (^value))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_568(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_568(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_load_address(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_569(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_569(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.LoadAddress))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_569(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_569(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_address_of(self: &InstructionBuilder, index: i64) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_570(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_570(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.AddressOf))
        &(*function).instructions.add(*cast(^u64) (^index))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_570(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_570(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_load(self: &InstructionBuilder, slots: i64) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_571(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_571(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Load))
        &(*function).instructions.add(cast (slots))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_571(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_571(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_store(self: &InstructionBuilder, slots: i64) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_572(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_572(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Store))
        &(*function).instructions.add(cast (slots))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_572(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_572(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_load_local(self: &InstructionBuilder, index: i64, slots: i64) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_573(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_573(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.LoadLocal))
        &(*function).instructions.add(*cast(^u64) (^index))
        &(*function).instructions.add(cast (slots))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_573(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_573(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_store_local(self: &InstructionBuilder, index: i64, slots: i64) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_574(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_574(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.StoreLocal))
        &(*function).instructions.add(*cast(^u64) (^index))
        &(*function).instructions.add(cast (slots))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_574(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_574(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_store_stack(self: &InstructionBuilder, index: i64, slots: i64) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_575(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_575(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.StoreStack))
        &(*function).instructions.add(cast (index))
        &(*function).instructions.add(cast (slots))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_575(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_575(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_cast_float_to_double(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_576(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_576(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CastFD))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_576(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_576(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_cast_double_to_float(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_577(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_577(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CastDF))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_577(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_577(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_cast_double_to_signed(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_578(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_578(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CastDS))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_578(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_578(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_cast_double_to_unsigned(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_579(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_579(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CastDU))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_579(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_579(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_cast_signed_to_double(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_580(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_580(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CastSD))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_580(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_580(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_cast_unsigned_to_double(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_581(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_581(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CastUD))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_581(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_581(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_cast_signed(self: &InstructionBuilder, from: InstNumTyp, to: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_582(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_582(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CastSigned))
        &(*function).instructions.add(cast (from))
        &(*function).instructions.add(cast (to))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_582(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_582(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_cast_unsigned(self: &InstructionBuilder, from: InstNumTyp, to: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_583(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_583(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CastUnsigned))
        &(*function).instructions.add(cast (from))
        &(*function).instructions.add(cast (to))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_583(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_583(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_cast_signed_to_unsigned(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_584(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_584(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CastSU))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_584(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_584(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_cast_unsigned_to_signed(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_585(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_585(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CastUS))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_585(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_585(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_add(self: &InstructionBuilder, typ: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_586(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_586(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Add))
        &(*function).instructions.add(cast (typ))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_586(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_586(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_sub(self: &InstructionBuilder, typ: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_587(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_587(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Sub))
        &(*function).instructions.add(cast (typ))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_587(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_587(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_mul(self: &InstructionBuilder, typ: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_588(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_588(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Mul))
        &(*function).instructions.add(cast (typ))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_588(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_588(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_div(self: &InstructionBuilder, typ: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_589(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_589(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Div))
        &(*function).instructions.add(cast (typ))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_589(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_589(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_mod(self: &InstructionBuilder, typ: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_590(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_590(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Mod))
        &(*function).instructions.add(cast (typ))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_590(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_590(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_and(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_591(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_591(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.And))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_591(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_591(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_or(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_592(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_592(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Or))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_592(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_592(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_neg(self: &InstructionBuilder, typ: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_593(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_593(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Neg))
        &(*function).instructions.add(cast (typ))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_593(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_593(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_not(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_594(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_594(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Not))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_594(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_594(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_ieq(self: &InstructionBuilder, typ: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_595(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_595(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Ieq))
        &(*function).instructions.add(cast (typ))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_595(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_595(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_ine(self: &InstructionBuilder, typ: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_596(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_596(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Ine))
        &(*function).instructions.add(cast (typ))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_596(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_596(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_ilt(self: &InstructionBuilder, typ: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_597(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_597(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Ilt))
        &(*function).instructions.add(cast (typ))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_597(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_597(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_ile(self: &InstructionBuilder, typ: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_598(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_598(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Ile))
        &(*function).instructions.add(cast (typ))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_598(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_598(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_igt(self: &InstructionBuilder, typ: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_599(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_599(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Igt))
        &(*function).instructions.add(cast (typ))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_599(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_599(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_ige(self: &InstructionBuilder, typ: InstNumTyp) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_600(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_600(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Ige))
        &(*function).instructions.add(cast (typ))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_600(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_600(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_branch(self: &InstructionBuilder, address: i64) -> i64 {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_601(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_601(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Branch))
        &(*function).instructions.add(cast (address))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_601(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_601(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        };
        return (&(*function).instructions.count() - 1)
    }
    
    build_branch_if(self: &InstructionBuilder, address: i64) -> i64 {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_602(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_602(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.BranchIf))
        &(*function).instructions.add(cast (address))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_602(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_602(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        };
        return (&(*function).instructions.count() - 1)
    }
    
    build_call(self: &InstructionBuilder, name: string, arity: i64 = 0) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_603(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_603(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        name = strings.intern(name)
        &(*function).instructions.add(cast (Instruction.Call))
        &(*function).instructions.add(cast (((name).bytes).data))
        &(*function).instructions.add(cast (((name).bytes).length))
        &(*function).instructions.add(cast (arity))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_603(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_603(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_native_call(self: &InstructionBuilder, func: ^NativeFunctionWrapper) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_604(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_604(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.NativeCall))
        &(*function).instructions.add(cast (func))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_604(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_604(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_native_call2(self: &InstructionBuilder, wrapper: fn(fn(), ^Interpreter), func: fn(), arg_slots: i64) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_605(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_605(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.NativeCall2))
        &(*function).instructions.add(*cast(^u64) (^wrapper))
        &(*function).instructions.add(*cast(^u64) (^func))
        &(*function).instructions.add(cast (arg_slots))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_605(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_605(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_comp_call(self: &InstructionBuilder, ast_func: ^AstFunction) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_606(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_606(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CompCall))
        &(*function).instructions.add(cast (ast_func))
        &(*function).instructions.add(0)
        &(*function).instructions.add(0)
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_606(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_606(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_return(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_607(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_607(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Return))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_607(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_607(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_return_void(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_608(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_608(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.ReturnVoid))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_608(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_608(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_halt(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_609(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_609(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.Halt))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_609(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_609(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_check_range(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_610(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_610(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CheckRange))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_610(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_610(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_check_null(self: &InstructionBuilder) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_611(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_611(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        &(*function).instructions.add(cast (Instruction.CheckNull))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_611(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_611(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
    
    build_panic(self: &InstructionBuilder, msg: string) {
        #macro {
            @assert((&((*function).debug_info).locations.count() > 0))
            current_instruction_count : i64 = &(*function).instructions.count()
            defer {
                new_instruction_count : i64 = &(*function).instructions.count()
                (@tempvar_612(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_612(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
            }
        }
        msg = strings.intern(msg)
        &(*function).instructions.add(cast (Instruction.Panic))
        &(*function).instructions.add(cast (((msg).bytes).data))
        &(*function).instructions.add(cast (((msg).bytes).length))
        {
            new_instruction_count : i64 = &(*function).instructions.count()
            (@tempvar_612(*&((*function).debug_info).locations.peek_last())).count = ((@tempvar_612(*&((*function).debug_info).locations.peek_last())).count + (new_instruction_count - current_instruction_count))
        }
    }
}

slots_for_size :: slots_for_size(size_in_bytes: i64) -> i64 {
    return ((size_in_bytes + 7) / 8)
}

type_info_to_inst_number_type :: type_info_to_inst_number_type(type_info: ^TypeInfo) -> InstNumTyp {
    return match @tempvar_95(&*type_info) {
        TypeInfoInt($ti) -> match @tempvar_97(((*ti).size, (*ti).signed)) {
            (1, true) -> InstNumTyp.I8
            (2, true) -> InstNumTyp.I16
            (4, true) -> InstNumTyp.I32
            (8, true) -> InstNumTyp.I64
            (1, false) -> InstNumTyp.U8
            (2, false) -> InstNumTyp.U16
            (4, false) -> InstNumTyp.U32
            (8, false) -> InstNumTyp.U64
            _ -> @assert(false)
        }
        TypeInfoFloat($ti) -> match @tempvar_99((*ti).size) {
            4 -> InstNumTyp.F32
            8 -> InstNumTyp.F64
            _ -> @assert(false)
        }
        _ -> @assert(false)
    }
}

#file interpreter.che
use import std.array

use import std.hash_table

use import std.map

use import std.math

use import std.string

C :  : import std.c

fmt :  : import std.fmt

fs :  : import std.io.fs

io :  : import std.io

mem :  : import std.mem.allocator

use import logging.logger

use import ast

use import bytecode_generator

use import compiler

use import config

use import error_handler

use import lexer

use import string_database

use import value

CodeRunner :: trait {
    run :: f.Accept(this)
}

DefaultCodeRunner :: struct type { // size: 0, alignment: 1
    
}

impl CodeRunner for DefaultCodeRunner {
    run(self: &DefaultCodeRunner, interp: &Interpreter) -> InterpStepResult {
        return interp.run()
    }
}

LineInfo :: struct { // size: 72, alignment: 8
    location : Location
    count : i64
}

VariableInfo :: struct { // size: 48, alignment: 8
    id : i64
    name : string
    index : i64
    type_info : ^TypeInfo
}

CBCDebugInfo :: struct { // size: 160, alignment: 8
    path : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    locations : Array[LineInfo] = (Array[LineInfo]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    locals : Array[VariableInfo] = (Array[VariableInfo]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    params : Array[VariableInfo] = (Array[VariableInfo]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
}

impl CBCDebugInfo {
    get_location_for_ip(self: &CBCDebugInfo, ip: i64) -> Location {
        i : i64 = 0
        #macro {
            local arr : &Array[LineInfo] = &(*self).locations
            
            local reverse : bool : false
            local by_ref : bool : true
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < arr.get_length()) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        #anonymous {
                            it : &LineInfo = access(&*arr, it_index)
                        }
                        #link #anonymous {
                            it : &LineInfo = it
                            it_index : i64 = it_index
                            {
                                if ((*it).count == 0) then it_index = (it_index + 1);
                                continue else {}
                                i = (i + (*it).count)
                                if (i > ip) {
                                    it_index = (it_index + 1);
                                    return (*it).location
                                } else {}
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return new Location {
            line = -1
            column = -1
            file = default
            byte_index = default
            byte_length = default
            end_column = default
            end_line = default
        }
    }
}

CBCFunction :: struct { // size: 264, alignment: 8
    ast_function : ^AstFunction = null
    instructions : Array[u64] = (Array[u64]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    parameter_indices : Array[i64] = (Array[int]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    parameter_slots : i64 = 0
    local_slots : i64 = 0
    debug_info : CBCDebugInfo = new CBCDebugInfo { path = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)), locations = (Array[LineInfo]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)), locals = (Array[VariableInfo]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)), params = (Array[VariableInfo]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) }
}

StackFrame :: struct { // size: 96, alignment: 8
    ip_prev : i64 = default
    ip : i64 = default
    sp : i64 = default
    bp : i64 = default
    code : []u64 = default
    stack : []i64 = default
    func : ^CBCFunction = null
    return_value_slots : i64 = 0
    parameter_indices : []i64 = default
}

impl StackFrame {
    push_int(self: &StackFrame, val: i64) {
        *get_index(stack, sp) = val
        sp = (sp + 1)
    }
    
    pop_int(self: &StackFrame) -> i64 {
        @assert((sp > 0))
        sp = (sp - 1)
        return *get_index(stack, sp)
    }
    
    get(&StackFrame, index: int, $T: type) -> T {
        return *cast() (^*stack[index])
    }
    // Polymorphic instances for get(&StackFrame, index: int, $T: type) -> T
        /*  */
        /* T = ^String */
        get(self: &StackFrame, index: i64) -> ^String {
            return *cast(^^String) (^*get_index(stack, index))
        }
        /*  */
        /* T = string */
        get(self: &StackFrame, index: i64) -> string {
            return *cast(^string) (^*get_index(stack, index))
        }
        /*  */
        /* T = ^Compiler */
        get(self: &StackFrame, index: i64) -> ^Compiler {
            return *cast(^^Compiler) (^*get_index(stack, index))
        }
        /*  */
        /* T = ^Workspace */
        get(self: &StackFrame, index: i64) -> ^Workspace {
            return *cast(^^Workspace) (^*get_index(stack, index))
        }
    
    
    get_local(&StackFrame, index: int, $T: type) -> T {
        return *cast() (^*stack[(bp + index)])
    }
    // Polymorphic instances for get_local(&StackFrame, index: int, $T: type) -> T
        /*  */
        /* T = i64 */
        get_local(self: &StackFrame, index: i64) -> i64 {
            return *^*get_index(stack, (bp + index))
        }
        /*  */
        /* T = f64 */
        get_local(self: &StackFrame, index: i64) -> f64 {
            return *cast(^f64) (^*get_index(stack, (bp + index)))
        }
        /*  */
        /* T = bool */
        get_local(self: &StackFrame, index: i64) -> bool {
            return *cast(^bool) (^*get_index(stack, (bp + index)))
        }
        /*  */
        /* T = string */
        get_local(self: &StackFrame, index: i64) -> string {
            return *cast(^string) (^*get_index(stack, (bp + index)))
        }
    
    
    get_arg(&StackFrame, index: int, $T: type) -> T {
        @assert(((index >= 0) and (index < (parameter_indices).length)))
        return *cast() (^*stack[(bp + *parameter_indices[index])])
    }
    // Polymorphic instances for get_arg(&StackFrame, index: int, $T: type) -> T
        /*  */
        /* T = string */
        get_arg(self: &StackFrame, index: i64) -> string {
            @assert(((index >= 0) and (index < (parameter_indices).length)))
            return *cast(^string) (^*get_index(stack, (bp + *get_index(parameter_indices, index))))
        }
    
    
    set_return(&StackFrame, v: $T) {
        *cast() (^*stack[0]) = v
        return_value_slots = ((@sizeof(T) + 7) / 8)
    }
    // Polymorphic instances for set_return(&StackFrame, v: $T)
        /* T = (type, ^Compiler) */
        /*  */
        set_return(self: &StackFrame, v: ^Compiler) {
            *cast(^^Compiler) (^*get_index(stack, 0)) = v
            return_value_slots = ((@sizeof(^Compiler) + 7) / 8)
        }
        /* T = (type, ^String) */
        /*  */
        set_return(self: &StackFrame, v: ^String) {
            *cast(^^String) (^*get_index(stack, 0)) = v
            return_value_slots = ((@sizeof(^String) + 7) / 8)
        }
        /* T = (type, ^Workspace) */
        /*  */
        set_return(self: &StackFrame, v: ^Workspace) {
            *cast(^^Workspace) (^*get_index(stack, 0)) = v
            return_value_slots = ((@sizeof(^Workspace) + 7) / 8)
        }
        /* T = (type, ^CompilationJob) */
        /*  */
        set_return(self: &StackFrame, v: ^CompilationJob) {
            *cast(^^CompilationJob) (^*get_index(stack, 0)) = v
            return_value_slots = ((@sizeof(^CompilationJob) + 7) / 8)
        }
    
    
    dump_stack(self: &StackFrame) -> String {
        str : String = (String).with_capacity(128, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        append_string(&str, "[ ")
        #macro {
            local r : Range[i64] = new Range[i64] { start = 0, end = bp }
            
            rev : bool = ((r).end < (r).start)
            inc : i64 = if rev then -1 else 1
            
            {
                @id((it, it_index)_278) : (i64, i64) = ((r).start, 0)
                it : i64 = @var(@id((it, it_index)_278))[0]
                it_index : i64 = @var(@id((it, it_index)_278))[1]
                loop {
                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                    defer #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                    #link #anonymous {
                        i : i64 = it
                        it_index : i64 = it_index
                        {
                            if (i > 0) {
                                append_string(&str, ", ")
                            } else {}
                            &str.appendf("{}", *get_index(stack, i))
                        }
                    }
                    #anonymous {
                        it_index = (it_index + 1)
                        it = (it + inc)
                    }
                }
            }
        }
        append_string(&str, " | ")
        if ((sp - bp) > 10) {
            append_string(&str, "... ")
        } else {}
        if (sp >= bp) {
            #macro {
                local r : Range[i64] = new Range[i64] { start = max(bp, (sp - 10)), end = sp }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_280) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_280))[0]
                    it_index : i64 = @var(@id((it, it_index)_280))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                &str.appendf("{}", *get_index(stack, i))
                                if (i < (sp - 1)) {
                                    append_string(&str, ", ")
                                } else {}
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
        } else {}
        append_string(&str, " ]")
        return str
    }
}

InterpStepResult :: enum<i64> { // size: 0, alignment: 1
    Continue = 0
    Done = 1
    Error : String = 2
}

Interpreter :: struct { // size: 9175192, alignment: 8
    sp : i64
    fp : i64
    frames : [8192]StackFrame
    stack : [1048576]i64
    strings : StringDatabase
    error_handler : ^ErrorHandler
}

impl Interpreter {
    new(error_handler: ^ErrorHandler) -> ^Interpreter {
        interp : ^Interpreter = (mem).alloc(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        *interp = new Interpreter {
            sp = 0
            fp = -1
            frames = default
            stack = default
            strings = (StringDatabase).new()
            error_handler = error_handler
        }
        return interp
    }
    
    print(format: string, args: []^any = cast([]^any) ([]), category: string = "console") {
        g_logger.log(format, args, "")
    }
    
    top_frame(self: &Interpreter) -> ^StackFrame {
        @assert((fp >= 0))
        return ^*get_index(&frames, fp)
    }
    
    get_stackframes(self: &Interpreter) -> []StackFrame {
        return get_range_to_incl(&frames, new RangeToInclusive[i64] { end = fp })
    }
    
    comp_call(self: &Interpreter, function: &AstFunction) -> bool {
        return self.push_frame((*function).bytecode)
    }
    
    push_frame(self: &Interpreter, func: ^CBCFunction) -> bool {
        if ((fp + 1) >= (frames).length) {
            frame : &StackFrame = get_index(&frames, fp)
            location : Location = &(*(*frame).func).debug_info.get_location_for_ip((*frame).ip_prev)
            g_logger.log("[INTERP] {}:{}:{}: StackOverflow at (fp={}, sp={}, ip={}) {}           {}", cast([]^any) ([cast(^any) (&((*(*frame).func).debug_info).path.slice()), cast(^any) ((location).line), cast(^any) ((location).column), cast(^any) (fp), cast(^any) ((*frame).sp), cast(^any) ((*frame).ip_prev), cast(^any) ((Instruction).pretty_print(get_range_from((*frame).code, new RangeFrom[i64] { start = (*frame).ip_prev }))), cast(^any) (frame.dump_stack())]), "stdout")
            return false
        } else {}
        if ((sp + (*func).local_slots) >= (stack).length) {
            frame : &StackFrame = get_index(&frames, fp)
            location : Location = &(*(*frame).func).debug_info.get_location_for_ip((*frame).ip_prev)
            g_logger.log("[INTERP] {}:{}:{}: StackOverflow at (fp={}, sp={}, ip={}, required={}) {}           {}", cast([]^any) ([cast(^any) (&((*(*frame).func).debug_info).path.slice()), cast(^any) ((location).line), cast(^any) ((location).column), cast(^any) (fp), cast(^any) ((*frame).sp), cast(^any) ((*frame).ip_prev), cast(^any) ((sp + (*func).local_slots)), cast(^any) ((Instruction).pretty_print(get_range_from((*frame).code, new RangeFrom[i64] { start = (*frame).ip_prev }))), cast(^any) (frame.dump_stack())]), "stdout")
            return false
        } else {}
        @id((_fp, _sp)_282) : (i64, i64) = (fp, sp)
        _fp : i64 = @var(@id((_fp, _sp)_282))[0]
        _sp : i64 = @var(@id((_fp, _sp)_282))[1]
        if (fp >= 0) {
            sp = (sp + ((*get_index(&frames, fp)).sp - (*get_index(&frames, fp)).bp))
        } else {}
        fp = (fp + 1)
        if ((sp - (*func).parameter_slots) < 0) {
            g_logger.log("[INTERP] Trying to call function with {} arguments but not enough arguments are on the stack (sp = {})", cast([]^any) ([cast(^any) ((*func).parameter_slots), cast(^any) (sp)]), "")
            return false
        } else {}
        return_value_slots : i64 = 0
        if (cast(^void) ((*func).ast_function) != null) {
            return_value_slots = (((*(*(*func).ast_function).return_type).size + 7) / 8)
        } else {}
        *get_index(&frames, fp) = new StackFrame {
            ip = 0
            sp = ((*func).parameter_slots + (*func).local_slots)
            bp = (*func).parameter_slots
            code = &(*func).instructions.slice()
            stack = get_range_from(&stack, new RangeFrom[i64] { start = (sp - (*func).parameter_slots) })
            func = func
            return_value_slots = return_value_slots
            parameter_indices = &(*func).parameter_indices.slice()
            ip_prev = default
        }
        #anonymous {
            if DEBUG_INTERPRETER {
                g_logger.log("push_frame {} (fp = {} -> {}, sp = {} -> {}, local_slots = {})", cast([]^any) ([cast(^any) ((*func).parameter_slots), cast(^any) (_fp), cast(^any) (fp), cast(^any) (_sp), cast(^any) (sp), cast(^any) ((*func).local_slots)]), "")
            } else {}
        }
        return true
    }
    
    push_native_frame(self: &Interpreter, wrapper: ^NativeFunctionWrapper) -> ^StackFrame {
        if ((fp + 1) >= (frames).length) {
            frame : &StackFrame = get_index(&frames, fp)
            location : Location = &(*(*frame).func).debug_info.get_location_for_ip((*frame).ip_prev)
            g_logger.log("[INTERP] {}:{}:{}: StackOverflow at (fp={}, sp={}, ip={}) {}           {}", cast([]^any) ([cast(^any) (&((*(*frame).func).debug_info).path.slice()), cast(^any) ((location).line), cast(^any) ((location).column), cast(^any) (fp), cast(^any) ((*frame).sp), cast(^any) ((*frame).ip_prev), cast(^any) ((Instruction).pretty_print(get_range_from((*frame).code, new RangeFrom[i64] { start = (*frame).ip_prev }))), cast(^any) (frame.dump_stack())]), "stdout")
            return ^*get_index(&frames, fp)
        } else {}
        @id((_fp, _sp)_283) : (i64, i64) = (fp, sp)
        _fp : i64 = @var(@id((_fp, _sp)_283))[0]
        _sp : i64 = @var(@id((_fp, _sp)_283))[1]
        defer {
            if DEBUG_INTERPRETER then g_logger.log("push_native_frame {} (fp = {} -> {}, sp = {} -> {})", cast([]^any) ([cast(^any) ((*wrapper).arg_slots), cast(^any) (_fp), cast(^any) (fp), cast(^any) (_sp), cast(^any) (sp)]), "") else {}
        }
        if (fp >= 0) {
            sp = (sp + ((*get_index(&frames, fp)).sp - (*get_index(&frames, fp)).bp))
        } else {}
        fp = (fp + 1)
        *get_index(&frames, fp) = new StackFrame {
            ip = 0
            sp = (*wrapper).arg_slots
            bp = (*wrapper).arg_slots
            code = null
            stack = get_range_from(&stack, new RangeFrom[i64] { start = (sp - (*wrapper).arg_slots) })
            func = null
            parameter_indices = (*wrapper).parameter_indices
            ip_prev = default
            return_value_slots = 0
        }
        {
            if DEBUG_INTERPRETER then g_logger.log("push_native_frame {} (fp = {} -> {}, sp = {} -> {})", cast([]^any) ([cast(^any) ((*wrapper).arg_slots), cast(^any) (_fp), cast(^any) (fp), cast(^any) (_sp), cast(^any) (sp)]), "") else {}
        };
        return ^*get_index(&frames, fp)
    }
    
    push_native_frame2(self: &Interpreter, arg_slots: i64) -> ^StackFrame {
        if ((fp + 1) >= (frames).length) {
            frame : &StackFrame = get_index(&frames, fp)
            location : Location = &(*(*frame).func).debug_info.get_location_for_ip((*frame).ip_prev)
            g_logger.log("[INTERP] {}:{}:{}: StackOverflow at (fp={}, sp={}, ip={}) {}           {}", cast([]^any) ([cast(^any) (&((*(*frame).func).debug_info).path.slice()), cast(^any) ((location).line), cast(^any) ((location).column), cast(^any) (fp), cast(^any) ((*frame).sp), cast(^any) ((*frame).ip_prev), cast(^any) ((Instruction).pretty_print(get_range_from((*frame).code, new RangeFrom[i64] { start = (*frame).ip_prev }))), cast(^any) (frame.dump_stack())]), "stdout")
            return ^*get_index(&frames, fp)
        } else {}
        @id((_fp, _sp)_285) : (i64, i64) = (fp, sp)
        _fp : i64 = @var(@id((_fp, _sp)_285))[0]
        _sp : i64 = @var(@id((_fp, _sp)_285))[1]
        defer {
            if DEBUG_INTERPRETER then g_logger.log("push_native_frame2 {} (fp = {} -> {}, sp = {} -> {})", cast([]^any) ([cast(^any) (arg_slots), cast(^any) (_fp), cast(^any) (fp), cast(^any) (_sp), cast(^any) (sp)]), "") else {}
        }
        if (fp >= 0) {
            sp = (sp + ((*get_index(&frames, fp)).sp - (*get_index(&frames, fp)).bp))
        } else {}
        fp = (fp + 1)
        *get_index(&frames, fp) = new StackFrame {
            ip = 0
            sp = arg_slots
            bp = arg_slots
            code = null
            stack = get_range_from(&stack, new RangeFrom[i64] { start = (sp - arg_slots) })
            func = null
            parameter_indices = cast([]i64) ([])
            ip_prev = default
            return_value_slots = 0
        }
        {
            if DEBUG_INTERPRETER then g_logger.log("push_native_frame2 {} (fp = {} -> {}, sp = {} -> {})", cast([]^any) ([cast(^any) (arg_slots), cast(^any) (_fp), cast(^any) (fp), cast(^any) (_sp), cast(^any) (sp)]), "") else {}
        };
        return ^*get_index(&frames, fp)
    }
    
    pop_frame(self: &Interpreter) {
        @id((_fp, _sp)_287) : (i64, i64) = (fp, sp)
        _fp : i64 = @var(@id((_fp, _sp)_287))[0]
        _sp : i64 = @var(@id((_fp, _sp)_287))[1]
        defer {
            if DEBUG_INTERPRETER then g_logger.log("pop_frame (fp = {} -> {}, sp = {} -> {})", cast([]^any) ([cast(^any) (_fp), cast(^any) (fp), cast(^any) (_sp), cast(^any) (sp)]), "") else {}
        }
        fp = (fp - 1)
        if (fp >= 0) {
            sp = (sp - ((*get_index(&frames, fp)).sp - (*get_index(&frames, fp)).bp))
            (@tempvar_613(*get_index(&frames, fp))).sp = ((@tempvar_613(*get_index(&frames, fp))).sp - (*get_index(&frames, (fp + 1))).bp)
        } else {}
        {
            if DEBUG_INTERPRETER then g_logger.log("pop_frame (fp = {} -> {}, sp = {} -> {})", cast([]^any) ([cast(^any) (_fp), cast(^any) (fp), cast(^any) (_sp), cast(^any) (sp)]), "") else {}
        }
    }
    
    step(self: &Interpreter) -> InterpStepResult {
        @assert((fp >= 0))
        frame : &StackFrame = get_index(&frames, fp)
        arg :: arg(T: type) #macro {
            val :  = *cast() (^*(frame).code[(frame).ip])
            (frame).ip = 1
            val
        }
        push : (val: $T) : push(val: $T) {
            *(frame).stack[(frame).sp] = *cast() (^val)
            (frame).sp = 1
        }
        // Polymorphic instances for push(val: $T)
            /* T = (type, i64) */
            /*  */
            push(val: i64) #macro {
                *(frame).stack[(frame).sp] = *cast() (^val)
                (frame).sp = 1
            }
            /* T = (type, f64) */
            /*  */
            push(val: f64) #macro {
                *(frame).stack[(frame).sp] = *cast() (^val)
                (frame).sp = 1
            }
            /* T = (type, bool) */
            /*  */
            push(val: bool) #macro {
                *(frame).stack[(frame).sp] = *cast() (^val)
                (frame).sp = 1
            }
        
        pop :: pop(T: type) #macro {
            @assert(((frame).sp > 0))
            (frame).sp = 1
            *cast() (^*(frame).stack[(frame).sp])
        }
        peek :: peek(T: type, offset: i64) #macro {
            @assert(((frame).sp > 0))
            @assert((offset <= 0))
            *cast() (^*(frame).stack[(((frame).sp + offset) - 1)])
        }
        set : ($T: type, offset: int, val: T) : set($T: type, offset: int, val: T) {
            @assert(((frame).sp > 0))
            @assert((offset <= 0))
            *cast() (^*(frame).stack[(((frame).sp + offset) - 1)]) = val
        }
        // Polymorphic instances for set($T: type, offset: int, val: T)
            /*  */
            /* T = f64 */
            set(offset: i64, val: f64) #macro {
                @assert(((frame).sp > 0))
                @assert((offset <= 0))
                *cast() (^*(frame).stack[(((frame).sp + offset) - 1)]) = val
            }
            /*  */
            /* T = f32 */
            set(offset: i64, val: f32) #macro {
                @assert(((frame).sp > 0))
                @assert((offset <= 0))
                *cast() (^*(frame).stack[(((frame).sp + offset) - 1)]) = val
            }
            /*  */
            /* T = i64 */
            set(offset: i64, val: i64) #macro {
                @assert(((frame).sp > 0))
                @assert((offset <= 0))
                *cast() (^*(frame).stack[(((frame).sp + offset) - 1)]) = val
            }
            /*  */
            /* T = u64 */
            set(offset: i64, val: u64) #macro {
                @assert(((frame).sp > 0))
                @assert((offset <= 0))
                *cast() (^*(frame).stack[(((frame).sp + offset) - 1)]) = val
            }
            /*  */
            /* T = i8 */
            set(offset: i64, val: i8) #macro {
                @assert(((frame).sp > 0))
                @assert((offset <= 0))
                *cast() (^*(frame).stack[(((frame).sp + offset) - 1)]) = val
            }
            /*  */
            /* T = i16 */
            set(offset: i64, val: i16) #macro {
                @assert(((frame).sp > 0))
                @assert((offset <= 0))
                *cast() (^*(frame).stack[(((frame).sp + offset) - 1)]) = val
            }
            /*  */
            /* T = i32 */
            set(offset: i64, val: i32) #macro {
                @assert(((frame).sp > 0))
                @assert((offset <= 0))
                *cast() (^*(frame).stack[(((frame).sp + offset) - 1)]) = val
            }
            /*  */
            /* T = u8 */
            set(offset: i64, val: u8) #macro {
                @assert(((frame).sp > 0))
                @assert((offset <= 0))
                *cast() (^*(frame).stack[(((frame).sp + offset) - 1)]) = val
            }
            /*  */
            /* T = u16 */
            set(offset: i64, val: u16) #macro {
                @assert(((frame).sp > 0))
                @assert((offset <= 0))
                *cast() (^*(frame).stack[(((frame).sp + offset) - 1)]) = val
            }
            /*  */
            /* T = u32 */
            set(offset: i64, val: u32) #macro {
                @assert(((frame).sp > 0))
                @assert((offset <= 0))
                *cast() (^*(frame).stack[(((frame).sp + offset) - 1)]) = val
            }
            /*  */
            /* T = bool */
            set(offset: i64, val: bool) #macro {
                @assert(((frame).sp > 0))
                @assert((offset <= 0))
                *cast() (^*(frame).stack[(((frame).sp + offset) - 1)]) = val
            }
        
        (*frame).ip_prev = (*frame).ip
        opcode : u64 = *get_index((*frame).code, (*frame).ip)
        #anonymous {
            if DEBUG_INTERPRETER {
                g_logger.log("{}{}{}{}{}{}{}{}{}{}{}", cast([]^any) ([cast(^any) ((&(*(*frame).func).debug_info.get_location_for_ip((*frame).ip)).line), cast(^any) ((fmt).align(6)), cast(^any) (fp), cast(^any) ((fmt).align(11)), cast(^any) ((*frame).sp), cast(^any) ((fmt).align(17)), cast(^any) ((*frame).ip), cast(^any) ((fmt).align(25)), cast(^any) ((Instruction).pretty_print(get_range_from((*frame).code, new RangeFrom[i64] { start = (*frame).ip }))), cast(^any) ((fmt).align(45)), cast(^any) (frame.dump_stack())]), "stdout")
            } else {}
        }
        (@tempvar_614(*frame)).ip = ((@tempvar_614(*frame)).ip + 1)
        match @tempvar_615(cast(Instruction) (opcode)) {
            Instruction.Noop -> {}
            Instruction.Push -> {
                slots : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_616(*frame)).ip = ((@tempvar_616(*frame)).ip + 1)
                    val
                }
                index : i64 = ((*frame).sp - (*frame).bp)
                (@tempvar_617(*frame)).sp = ((@tempvar_617(*frame)).sp + slots)
                #macro {
                    local val : i64 = index
                    *get_index((*frame).stack, (*frame).sp) = *^val
                    (@tempvar_618(*frame)).sp = ((@tempvar_618(*frame)).sp + 1)
                }
            }
            Instruction.Pop -> {
                slots : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_619(*frame)).ip = ((@tempvar_619(*frame)).ip + 1)
                    val
                }
                (@tempvar_620(*frame)).sp = ((@tempvar_620(*frame)).sp - slots)
            }
            Instruction.Dup -> {
                slots : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_621(*frame)).ip = ((@tempvar_621(*frame)).ip + 1)
                    val
                }
                (C).memcpy(cast(^void) (^*get_index((*frame).stack, (*frame).sp)), cast(^void) (^*get_index((*frame).stack, ((*frame).sp - slots))), cast ((slots * @sizeof(u64))))
                (@tempvar_622(*frame)).sp = ((@tempvar_622(*frame)).sp + slots)
            }
            Instruction.ConstInt -> {
                val : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_623(*frame)).ip = ((@tempvar_623(*frame)).ip + 1)
                    val
                }
                #macro {
                    local val : i64 = val
                    *get_index((*frame).stack, (*frame).sp) = *^val
                    (@tempvar_624(*frame)).sp = ((@tempvar_624(*frame)).sp + 1)
                }
            }
            Instruction.ConstFloat -> {
                val : f64 = #macro {
                    local T :: f64 = f64
                    val : f64 = *cast(^f64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_625(*frame)).ip = ((@tempvar_625(*frame)).ip + 1)
                    val
                }
                #macro {
                    local val : f64 = val
                    *get_index((*frame).stack, (*frame).sp) = *cast(^i64) (^val)
                    (@tempvar_626(*frame)).sp = ((@tempvar_626(*frame)).sp + 1)
                }
            }
            Instruction.LoadAddress -> {
                index : i64 = #macro {
                    local T :: int = i64
                    @assert(((*frame).sp > 0))
                    (@tempvar_627(*frame)).sp = ((@tempvar_627(*frame)).sp - 1)
                    *^*get_index((*frame).stack, (*frame).sp)
                }
                address : i64 = cast(i64) (^*get_index((*frame).stack, ((*frame).bp + index)))
                #macro {
                    local val : i64 = address
                    *get_index((*frame).stack, (*frame).sp) = *^val
                    (@tempvar_628(*frame)).sp = ((@tempvar_628(*frame)).sp + 1)
                }
            }
            Instruction.AddressOf -> {
                index : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_629(*frame)).ip = ((@tempvar_629(*frame)).ip + 1)
                    val
                }
                address : i64 = cast(i64) (^*get_index((*frame).stack, ((*frame).bp + index)))
                #macro {
                    local val : i64 = address
                    *get_index((*frame).stack, (*frame).sp) = *^val
                    (@tempvar_630(*frame)).sp = ((@tempvar_630(*frame)).sp + 1)
                }
            }
            Instruction.Load -> {
                slots : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_631(*frame)).ip = ((@tempvar_631(*frame)).ip + 1)
                    val
                }
                address : ^i64 = #macro {
                    local T :: ^int = ^i64
                    @assert(((*frame).sp > 0))
                    (@tempvar_632(*frame)).sp = ((@tempvar_632(*frame)).sp - 1)
                    *cast(^^i64) (^*get_index((*frame).stack, (*frame).sp))
                }
                (C).memcpy(cast(^void) (^*get_index((*frame).stack, (*frame).sp)), cast(^void) (address), cast ((slots * @sizeof(u64))))
                (@tempvar_633(*frame)).sp = ((@tempvar_633(*frame)).sp + slots)
            }
            Instruction.Store -> {
                slots : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_634(*frame)).ip = ((@tempvar_634(*frame)).ip + 1)
                    val
                }
                (@tempvar_635(*frame)).sp = ((@tempvar_635(*frame)).sp - slots)
                address : ^void = #macro {
                    local T :: ^void = ^void
                    @assert(((*frame).sp > 0))
                    (@tempvar_636(*frame)).sp = ((@tempvar_636(*frame)).sp - 1)
                    *cast(^^void) (^*get_index((*frame).stack, (*frame).sp))
                }
                (C).memcpy(address, cast(^void) (^*get_index((*frame).stack, ((*frame).sp + 1))), cast ((slots * @sizeof(u64))))
            }
            Instruction.LoadLocal -> {
                index : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_637(*frame)).ip = ((@tempvar_637(*frame)).ip + 1)
                    val
                }
                slots : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_638(*frame)).ip = ((@tempvar_638(*frame)).ip + 1)
                    val
                }
                (C).memmove(cast(^void) (^*get_index((*frame).stack, (*frame).sp)), cast(^void) (^*get_index((*frame).stack, ((*frame).bp + index))), cast ((slots * @sizeof(u64))))
                (@tempvar_639(*frame)).sp = ((@tempvar_639(*frame)).sp + slots)
            }
            Instruction.StoreLocal -> {
                index : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_640(*frame)).ip = ((@tempvar_640(*frame)).ip + 1)
                    val
                }
                slots : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_641(*frame)).ip = ((@tempvar_641(*frame)).ip + 1)
                    val
                }
                (C).memmove(cast(^void) (^*get_index((*frame).stack, ((*frame).bp + index))), cast(^void) (^*get_index((*frame).stack, ((*frame).sp - slots))), cast ((slots * @sizeof(u64))))
                (@tempvar_642(*frame)).sp = ((@tempvar_642(*frame)).sp - slots)
            }
            Instruction.StoreStack -> {
                index : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_643(*frame)).ip = ((@tempvar_643(*frame)).ip + 1)
                    val
                }
                slots : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_644(*frame)).ip = ((@tempvar_644(*frame)).ip + 1)
                    val
                }
                (C).memmove(cast(^void) (^*get_index((*frame).stack, index)), cast(^void) (^*get_index((*frame).stack, ((*frame).sp - slots))), cast ((slots * @sizeof(u64))))
                (@tempvar_645(*frame)).sp = ((@tempvar_645(*frame)).sp - slots)
            }
            Instruction.CastFD -> #macro {
                local offset : i64 : 0
                local val : f64 = cast(f64) (#macro {
                    local T :: f32 = f32
                    local offset : i64 : 0
                    @assert(((*frame).sp > 0))
                    @assert((offset <= 0))
                    *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                })
                @assert(((*frame).sp > 0))
                @assert((offset <= 0))
                *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
            }
            Instruction.CastDF -> #macro {
                local offset : i64 : 0
                local val : f32 = cast(f32) (#macro {
                    local T :: f64 = f64
                    local offset : i64 : 0
                    @assert(((*frame).sp > 0))
                    @assert((offset <= 0))
                    *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                })
                @assert(((*frame).sp > 0))
                @assert((offset <= 0))
                *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
            }
            Instruction.CastDS -> #macro {
                local offset : i64 : 0
                local val : i64 = cast(i64) (#macro {
                    local T :: f64 = f64
                    local offset : i64 : 0
                    @assert(((*frame).sp > 0))
                    @assert((offset <= 0))
                    *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                })
                @assert(((*frame).sp > 0))
                @assert((offset <= 0))
                *^*get_index((*frame).stack, (((*frame).sp + offset) - 1)) = val
            }
            Instruction.CastDU -> #macro {
                local offset : i64 : 0
                local val : u64 = cast(u64) (#macro {
                    local T :: f64 = f64
                    local offset : i64 : 0
                    @assert(((*frame).sp > 0))
                    @assert((offset <= 0))
                    *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                })
                @assert(((*frame).sp > 0))
                @assert((offset <= 0))
                *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
            }
            Instruction.CastSD -> #macro {
                local offset : i64 : 0
                local val : f64 = cast(f64) (#macro {
                    local T :: i64 = i64
                    local offset : i64 : 0
                    @assert(((*frame).sp > 0))
                    @assert((offset <= 0))
                    *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                })
                @assert(((*frame).sp > 0))
                @assert((offset <= 0))
                *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
            }
            Instruction.CastUD -> #macro {
                local offset : i64 : 0
                local val : f64 = cast(f64) (#macro {
                    local T :: u64 = u64
                    local offset : i64 : 0
                    @assert(((*frame).sp > 0))
                    @assert((offset <= 0))
                    *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                })
                @assert(((*frame).sp > 0))
                @assert((offset <= 0))
                *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
            }
            Instruction.CastSU -> #macro {
                local offset : i64 : 0
                local val : u64 = cast(u64) (#macro {
                    local T :: i64 = i64
                    local offset : i64 : 0
                    @assert(((*frame).sp > 0))
                    @assert((offset <= 0))
                    *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                })
                @assert(((*frame).sp > 0))
                @assert((offset <= 0))
                *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
            }
            Instruction.CastUS -> #macro {
                local offset : i64 : 0
                local val : i64 = cast(i64) (#macro {
                    local T :: u64 = u64
                    local offset : i64 : 0
                    @assert(((*frame).sp > 0))
                    @assert((offset <= 0))
                    *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                })
                @assert(((*frame).sp > 0))
                @assert((offset <= 0))
                *^*get_index((*frame).stack, (((*frame).sp + offset) - 1)) = val
            }
            Instruction.CastSigned -> {
                from : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_646(*frame)).ip = ((@tempvar_646(*frame)).ip + 1)
                    val
                }
                to : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_647(*frame)).ip = ((@tempvar_647(*frame)).ip + 1)
                    val
                }
                match @tempvar_648((from, to)) {
                    use InstNumTyp
                    (InstNumTyp.I8, InstNumTyp.I8) -> #macro {
                        local offset : i64 : 0
                        local val : i8 = #macro #link #anonymous {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.I8, InstNumTyp.I16) -> #macro {
                        local offset : i64 : 0
                        local val : i16 = cast(i16) (#macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.I8, InstNumTyp.I32) -> #macro {
                        local offset : i64 : 0
                        local val : i32 = cast(i32) (#macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.I8, InstNumTyp.I64) -> #macro {
                        local offset : i64 : 0
                        local val : i64 = cast(i64) (#macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *^*get_index((*frame).stack, (((*frame).sp + offset) - 1)) = val
                    }
                    (InstNumTyp.I16, InstNumTyp.I8) -> #macro {
                        local offset : i64 : 0
                        local val : i8 = cast(i8) (#macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.I16, InstNumTyp.I16) -> #macro {
                        local offset : i64 : 0
                        local val : i16 = #macro #link #anonymous {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.I16, InstNumTyp.I32) -> #macro {
                        local offset : i64 : 0
                        local val : i32 = cast(i32) (#macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.I16, InstNumTyp.I64) -> #macro {
                        local offset : i64 : 0
                        local val : i64 = cast(i64) (#macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *^*get_index((*frame).stack, (((*frame).sp + offset) - 1)) = val
                    }
                    (InstNumTyp.I32, InstNumTyp.I8) -> #macro {
                        local offset : i64 : 0
                        local val : i8 = cast(i8) (#macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.I32, InstNumTyp.I16) -> #macro {
                        local offset : i64 : 0
                        local val : i16 = cast(i16) (#macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.I32, InstNumTyp.I32) -> #macro {
                        local offset : i64 : 0
                        local val : i32 = #macro #link #anonymous {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.I32, InstNumTyp.I64) -> #macro {
                        local offset : i64 : 0
                        local val : i64 = cast(i64) (#macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *^*get_index((*frame).stack, (((*frame).sp + offset) - 1)) = val
                    }
                    (InstNumTyp.I64, InstNumTyp.I8) -> #macro {
                        local offset : i64 : 0
                        local val : i8 = cast(i8) (#macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.I64, InstNumTyp.I16) -> #macro {
                        local offset : i64 : 0
                        local val : i16 = cast(i16) (#macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.I64, InstNumTyp.I32) -> #macro {
                        local offset : i64 : 0
                        local val : i32 = cast(i32) (#macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.I64, InstNumTyp.I64) -> #macro {
                        local offset : i64 : 0
                        local val : i64 = #macro #link #anonymous {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *^*get_index((*frame).stack, (((*frame).sp + offset) - 1)) = val
                    }
                    _ -> @assert(false)
                }
            }
            Instruction.CastUnsigned -> {
                from : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_649(*frame)).ip = ((@tempvar_649(*frame)).ip + 1)
                    val
                }
                to : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_650(*frame)).ip = ((@tempvar_650(*frame)).ip + 1)
                    val
                }
                match @tempvar_651((from, to)) {
                    use InstNumTyp
                    (InstNumTyp.U8, InstNumTyp.U8) -> #macro {
                        local offset : i64 : 0
                        local val : u8 = #macro #link #anonymous {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U8, InstNumTyp.U16) -> #macro {
                        local offset : i64 : 0
                        local val : u16 = cast(u16) (#macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U8, InstNumTyp.U32) -> #macro {
                        local offset : i64 : 0
                        local val : u32 = cast(u32) (#macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U8, InstNumTyp.U64) -> #macro {
                        local offset : i64 : 0
                        local val : u64 = cast(u64) (#macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U16, InstNumTyp.U8) -> #macro {
                        local offset : i64 : 0
                        local val : u8 = cast(u8) (#macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U16, InstNumTyp.U16) -> #macro {
                        local offset : i64 : 0
                        local val : u16 = #macro #link #anonymous {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U16, InstNumTyp.U32) -> #macro {
                        local offset : i64 : 0
                        local val : u32 = cast(u32) (#macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U16, InstNumTyp.U64) -> #macro {
                        local offset : i64 : 0
                        local val : u64 = cast(u64) (#macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U32, InstNumTyp.U8) -> #macro {
                        local offset : i64 : 0
                        local val : u8 = cast(u8) (#macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U32, InstNumTyp.U16) -> #macro {
                        local offset : i64 : 0
                        local val : u16 = cast(u16) (#macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U32, InstNumTyp.U32) -> #macro {
                        local offset : i64 : 0
                        local val : u32 = #macro #link #anonymous {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U32, InstNumTyp.U64) -> #macro {
                        local offset : i64 : 0
                        local val : u64 = cast(u64) (#macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U64, InstNumTyp.U8) -> #macro {
                        local offset : i64 : 0
                        local val : u8 = cast(u8) (#macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U64, InstNumTyp.U16) -> #macro {
                        local offset : i64 : 0
                        local val : u16 = cast(u16) (#macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U64, InstNumTyp.U32) -> #macro {
                        local offset : i64 : 0
                        local val : u32 = cast(u32) (#macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    (InstNumTyp.U64, InstNumTyp.U64) -> #macro {
                        local offset : i64 : 0
                        local val : u64 = #macro #link #anonymous {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    _ -> @assert(false)
                }
            }
            Instruction.Add -> {
                typ : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_652(*frame)).ip = ((@tempvar_652(*frame)).ip + 1)
                    val
                }
                match @tempvar_653(typ) {
                    InstNumTyp.F32 -> #macro {
                        local offset : i64 : -1
                        local val : f32 = (#macro {
                            local T :: f32 = f32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } + #macro {
                            local T :: f32 = f32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.F64 -> #macro {
                        local offset : i64 : -1
                        local val : f64 = (#macro {
                            local T :: f64 = f64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } + #macro {
                            local T :: f64 = f64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I8 -> #macro {
                        local offset : i64 : -1
                        local val : i8 = (#macro {
                            local T :: i8 = i8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } + #macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I16 -> #macro {
                        local offset : i64 : -1
                        local val : i16 = (#macro {
                            local T :: i16 = i16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } + #macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I32 -> #macro {
                        local offset : i64 : -1
                        local val : i32 = (#macro {
                            local T :: i32 = i32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } + #macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I64 -> #macro {
                        local offset : i64 : -1
                        local val : i64 = (#macro {
                            local T :: i64 = i64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        } + #macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *^*get_index((*frame).stack, (((*frame).sp + offset) - 1)) = val
                    }
                    InstNumTyp.U8 -> #macro {
                        local offset : i64 : -1
                        local val : u8 = (#macro {
                            local T :: u8 = u8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } + #macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U16 -> #macro {
                        local offset : i64 : -1
                        local val : u16 = (#macro {
                            local T :: u16 = u16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } + #macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U32 -> #macro {
                        local offset : i64 : -1
                        local val : u32 = (#macro {
                            local T :: u32 = u32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } + #macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U64 -> #macro {
                        local offset : i64 : -1
                        local val : u64 = (#macro {
                            local T :: u64 = u64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } + #macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                }
                (@tempvar_654(*frame)).sp = ((@tempvar_654(*frame)).sp - 1)
            }
            Instruction.Sub -> {
                typ : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_655(*frame)).ip = ((@tempvar_655(*frame)).ip + 1)
                    val
                }
                match @tempvar_656(typ) {
                    InstNumTyp.F32 -> #macro {
                        local offset : i64 : -1
                        local val : f32 = (#macro {
                            local T :: f32 = f32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } - #macro {
                            local T :: f32 = f32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.F64 -> #macro {
                        local offset : i64 : -1
                        local val : f64 = (#macro {
                            local T :: f64 = f64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } - #macro {
                            local T :: f64 = f64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I8 -> #macro {
                        local offset : i64 : -1
                        local val : i8 = (#macro {
                            local T :: i8 = i8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } - #macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I16 -> #macro {
                        local offset : i64 : -1
                        local val : i16 = (#macro {
                            local T :: i16 = i16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } - #macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I32 -> #macro {
                        local offset : i64 : -1
                        local val : i32 = (#macro {
                            local T :: i32 = i32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } - #macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I64 -> #macro {
                        local offset : i64 : -1
                        local val : i64 = (#macro {
                            local T :: i64 = i64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        } - #macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *^*get_index((*frame).stack, (((*frame).sp + offset) - 1)) = val
                    }
                    InstNumTyp.U8 -> #macro {
                        local offset : i64 : -1
                        local val : u8 = (#macro {
                            local T :: u8 = u8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } - #macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U16 -> #macro {
                        local offset : i64 : -1
                        local val : u16 = (#macro {
                            local T :: u16 = u16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } - #macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U32 -> #macro {
                        local offset : i64 : -1
                        local val : u32 = (#macro {
                            local T :: u32 = u32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } - #macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U64 -> #macro {
                        local offset : i64 : -1
                        local val : u64 = (#macro {
                            local T :: u64 = u64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } - #macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                }
                (@tempvar_657(*frame)).sp = ((@tempvar_657(*frame)).sp - 1)
            }
            Instruction.Mul -> {
                typ : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_658(*frame)).ip = ((@tempvar_658(*frame)).ip + 1)
                    val
                }
                match @tempvar_659(typ) {
                    InstNumTyp.F32 -> #macro {
                        local offset : i64 : -1
                        local val : f32 = (#macro {
                            local T :: f32 = f32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } * #macro {
                            local T :: f32 = f32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.F64 -> #macro {
                        local offset : i64 : -1
                        local val : f64 = (#macro {
                            local T :: f64 = f64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } * #macro {
                            local T :: f64 = f64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I8 -> #macro {
                        local offset : i64 : -1
                        local val : i8 = (#macro {
                            local T :: i8 = i8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } * #macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I16 -> #macro {
                        local offset : i64 : -1
                        local val : i16 = (#macro {
                            local T :: i16 = i16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } * #macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I32 -> #macro {
                        local offset : i64 : -1
                        local val : i32 = (#macro {
                            local T :: i32 = i32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } * #macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I64 -> #macro {
                        local offset : i64 : -1
                        local val : i64 = (#macro {
                            local T :: i64 = i64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        } * #macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *^*get_index((*frame).stack, (((*frame).sp + offset) - 1)) = val
                    }
                    InstNumTyp.U8 -> #macro {
                        local offset : i64 : -1
                        local val : u8 = (#macro {
                            local T :: u8 = u8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } * #macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U16 -> #macro {
                        local offset : i64 : -1
                        local val : u16 = (#macro {
                            local T :: u16 = u16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } * #macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U32 -> #macro {
                        local offset : i64 : -1
                        local val : u32 = (#macro {
                            local T :: u32 = u32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } * #macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U64 -> #macro {
                        local offset : i64 : -1
                        local val : u64 = (#macro {
                            local T :: u64 = u64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } * #macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                }
                (@tempvar_660(*frame)).sp = ((@tempvar_660(*frame)).sp - 1)
            }
            Instruction.Div -> {
                typ : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_661(*frame)).ip = ((@tempvar_661(*frame)).ip + 1)
                    val
                }
                match @tempvar_662(typ) {
                    InstNumTyp.F32 -> #macro {
                        local offset : i64 : -1
                        local val : f32 = (#macro {
                            local T :: f32 = f32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } / #macro {
                            local T :: f32 = f32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.F64 -> #macro {
                        local offset : i64 : -1
                        local val : f64 = (#macro {
                            local T :: f64 = f64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } / #macro {
                            local T :: f64 = f64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I8 -> #macro {
                        local offset : i64 : -1
                        local val : i8 = (#macro {
                            local T :: i8 = i8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } / #macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I16 -> #macro {
                        local offset : i64 : -1
                        local val : i16 = (#macro {
                            local T :: i16 = i16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } / #macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I32 -> #macro {
                        local offset : i64 : -1
                        local val : i32 = (#macro {
                            local T :: i32 = i32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } / #macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I64 -> #macro {
                        local offset : i64 : -1
                        local val : i64 = (#macro {
                            local T :: i64 = i64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        } / #macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *^*get_index((*frame).stack, (((*frame).sp + offset) - 1)) = val
                    }
                    InstNumTyp.U8 -> #macro {
                        local offset : i64 : -1
                        local val : u8 = (#macro {
                            local T :: u8 = u8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } / #macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U16 -> #macro {
                        local offset : i64 : -1
                        local val : u16 = (#macro {
                            local T :: u16 = u16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } / #macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U32 -> #macro {
                        local offset : i64 : -1
                        local val : u32 = (#macro {
                            local T :: u32 = u32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } / #macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U64 -> #macro {
                        local offset : i64 : -1
                        local val : u64 = (#macro {
                            local T :: u64 = u64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } / #macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                }
                (@tempvar_663(*frame)).sp = ((@tempvar_663(*frame)).sp - 1)
            }
            Instruction.Mod -> {
                typ : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_664(*frame)).ip = ((@tempvar_664(*frame)).ip + 1)
                    val
                }
                match @tempvar_665(typ) {
                    InstNumTyp.F32 -> #macro {
                        local offset : i64 : -1
                        local val : f32 = cast(f32) ((cast(i64) (#macro {
                            local T :: f32 = f32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }) % cast(i64) (#macro {
                            local T :: f32 = f32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })))
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.F64 -> #macro {
                        local offset : i64 : -1
                        local val : f64 = cast(f64) ((cast(i64) (#macro {
                            local T :: f64 = f64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }) % cast(i64) (#macro {
                            local T :: f64 = f64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })))
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I8 -> #macro {
                        local offset : i64 : -1
                        local val : i8 = (#macro {
                            local T :: i8 = i8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } % #macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I16 -> #macro {
                        local offset : i64 : -1
                        local val : i16 = (#macro {
                            local T :: i16 = i16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } % #macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I32 -> #macro {
                        local offset : i64 : -1
                        local val : i32 = (#macro {
                            local T :: i32 = i32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } % #macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I64 -> #macro {
                        local offset : i64 : -1
                        local val : i64 = (#macro {
                            local T :: i64 = i64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        } % #macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *^*get_index((*frame).stack, (((*frame).sp + offset) - 1)) = val
                    }
                    InstNumTyp.U8 -> #macro {
                        local offset : i64 : -1
                        local val : u8 = (#macro {
                            local T :: u8 = u8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } % #macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U16 -> #macro {
                        local offset : i64 : -1
                        local val : u16 = (#macro {
                            local T :: u16 = u16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } % #macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U32 -> #macro {
                        local offset : i64 : -1
                        local val : u32 = (#macro {
                            local T :: u32 = u32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } % #macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U64 -> #macro {
                        local offset : i64 : -1
                        local val : u64 = (#macro {
                            local T :: u64 = u64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } % #macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                }
                (@tempvar_666(*frame)).sp = ((@tempvar_666(*frame)).sp - 1)
            }
            Instruction.Not -> {
                v : bool = #macro {
                    local T :: bool = bool
                    @assert(((*frame).sp > 0))
                    (@tempvar_667(*frame)).sp = ((@tempvar_667(*frame)).sp - 1)
                    *cast(^bool) (^*get_index((*frame).stack, (*frame).sp))
                }
                #macro {
                    local val : bool = !v
                    *get_index((*frame).stack, (*frame).sp) = *cast(^i64) (^val)
                    (@tempvar_668(*frame)).sp = ((@tempvar_668(*frame)).sp + 1)
                }
            }
            Instruction.Neg -> {
                typ : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_669(*frame)).ip = ((@tempvar_669(*frame)).ip + 1)
                    val
                }
                match @tempvar_670(typ) {
                    InstNumTyp.F32 -> #macro {
                        local offset : i64 : 0
                        local val : f32 = -#macro {
                            local T :: f32 = f32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.F64 -> #macro {
                        local offset : i64 : 0
                        local val : f64 = -#macro {
                            local T :: f64 = f64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I8 -> #macro {
                        local offset : i64 : 0
                        local val : i8 = -#macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I16 -> #macro {
                        local offset : i64 : 0
                        local val : i16 = -#macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I32 -> #macro {
                        local offset : i64 : 0
                        local val : i32 = -#macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I64 -> #macro {
                        local offset : i64 : 0
                        local val : i64 = -#macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *^*get_index((*frame).stack, (((*frame).sp + offset) - 1)) = val
                    }
                    InstNumTyp.U8 -> #macro {
                        local offset : i64 : 0
                        local val : u8 = -#macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U16 -> #macro {
                        local offset : i64 : 0
                        local val : u16 = -#macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U32 -> #macro {
                        local offset : i64 : 0
                        local val : u32 = -#macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U64 -> #macro {
                        local offset : i64 : 0
                        local val : u64 = -#macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        }
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                }
            }
            Instruction.Ieq -> {
                typ : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_671(*frame)).ip = ((@tempvar_671(*frame)).ip + 1)
                    val
                }
                match @tempvar_672(typ) {
                    InstNumTyp.F32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: f32 = f32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } == #macro {
                            local T :: f32 = f32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.F64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: f64 = f64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } == #macro {
                            local T :: f64 = f64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I8 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i8 = i8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } == #macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I16 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i16 = i16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } == #macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i32 = i32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } == #macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i64 = i64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        } == #macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U8 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u8 = u8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } == #macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U16 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u16 = u16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } == #macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u32 = u32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } == #macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u64 = u64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } == #macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                }
                (@tempvar_673(*frame)).sp = ((@tempvar_673(*frame)).sp - 1)
            }
            Instruction.Ine -> {
                typ : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_674(*frame)).ip = ((@tempvar_674(*frame)).ip + 1)
                    val
                }
                match @tempvar_675(typ) {
                    InstNumTyp.F32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: f32 = f32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } != #macro {
                            local T :: f32 = f32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.F64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: f64 = f64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } != #macro {
                            local T :: f64 = f64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I8 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i8 = i8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } != #macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I16 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i16 = i16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } != #macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i32 = i32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } != #macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i64 = i64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        } != #macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U8 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u8 = u8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } != #macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U16 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u16 = u16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } != #macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u32 = u32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } != #macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u64 = u64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } != #macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                }
                (@tempvar_676(*frame)).sp = ((@tempvar_676(*frame)).sp - 1)
            }
            Instruction.Ilt -> {
                typ : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_677(*frame)).ip = ((@tempvar_677(*frame)).ip + 1)
                    val
                }
                match @tempvar_678(typ) {
                    InstNumTyp.F32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: f32 = f32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } < #macro {
                            local T :: f32 = f32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.F64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: f64 = f64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } < #macro {
                            local T :: f64 = f64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I8 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i8 = i8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } < #macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I16 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i16 = i16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } < #macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i32 = i32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } < #macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i64 = i64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        } < #macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U8 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u8 = u8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } < #macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U16 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u16 = u16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } < #macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u32 = u32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } < #macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u64 = u64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } < #macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                }
                (@tempvar_679(*frame)).sp = ((@tempvar_679(*frame)).sp - 1)
            }
            Instruction.Ile -> {
                typ : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_680(*frame)).ip = ((@tempvar_680(*frame)).ip + 1)
                    val
                }
                match @tempvar_681(typ) {
                    InstNumTyp.F32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: f32 = f32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } <= #macro {
                            local T :: f32 = f32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.F64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: f64 = f64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } <= #macro {
                            local T :: f64 = f64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I8 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i8 = i8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } <= #macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I16 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i16 = i16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } <= #macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i32 = i32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } <= #macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i64 = i64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        } <= #macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U8 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u8 = u8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } <= #macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U16 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u16 = u16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } <= #macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u32 = u32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } <= #macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u64 = u64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } <= #macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                }
                (@tempvar_682(*frame)).sp = ((@tempvar_682(*frame)).sp - 1)
            }
            Instruction.Igt -> {
                typ : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_683(*frame)).ip = ((@tempvar_683(*frame)).ip + 1)
                    val
                }
                match @tempvar_684(typ) {
                    InstNumTyp.F32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: f32 = f32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } > #macro {
                            local T :: f32 = f32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.F64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: f64 = f64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } > #macro {
                            local T :: f64 = f64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I8 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i8 = i8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } > #macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I16 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i16 = i16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } > #macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i32 = i32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } > #macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i64 = i64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        } > #macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U8 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u8 = u8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } > #macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U16 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u16 = u16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } > #macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u32 = u32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } > #macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u64 = u64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } > #macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                }
                (@tempvar_685(*frame)).sp = ((@tempvar_685(*frame)).sp - 1)
            }
            Instruction.Ige -> {
                typ : InstNumTyp = #macro {
                    local T :: InstNumTyp = InstNumTyp
                    val : InstNumTyp = *cast(^InstNumTyp) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_686(*frame)).ip = ((@tempvar_686(*frame)).ip + 1)
                    val
                }
                match @tempvar_687(typ) {
                    InstNumTyp.F32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: f32 = f32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } >= #macro {
                            local T :: f32 = f32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.F64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: f64 = f64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } >= #macro {
                            local T :: f64 = f64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^f64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I8 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i8 = i8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } >= #macro {
                            local T :: i8 = i8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I16 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i16 = i16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } >= #macro {
                            local T :: i16 = i16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i32 = i32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } >= #macro {
                            local T :: i32 = i32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^i32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.I64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: i64 = i64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        } >= #macro {
                            local T :: i64 = i64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U8 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u8 = u8
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } >= #macro {
                            local T :: u8 = u8
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u8) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U16 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u16 = u16
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } >= #macro {
                            local T :: u16 = u16
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u16) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U32 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u32 = u32
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } >= #macro {
                            local T :: u32 = u32
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u32) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                    InstNumTyp.U64 -> #macro {
                        local offset : i64 : -1
                        local val : bool = (#macro {
                            local T :: u64 = u64
                            local offset : i64 : -1
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        } >= #macro {
                            local T :: u64 = u64
                            local offset : i64 : 0
                            @assert(((*frame).sp > 0))
                            @assert((offset <= 0))
                            *cast(^u64) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1)))
                        })
                        @assert(((*frame).sp > 0))
                        @assert((offset <= 0))
                        *cast(^bool) (^*get_index((*frame).stack, (((*frame).sp + offset) - 1))) = val
                    }
                }
                (@tempvar_688(*frame)).sp = ((@tempvar_688(*frame)).sp - 1)
            }
            Instruction.And -> {
                @id((b, a)_289) : (bool, bool) = (#macro {
                    local T :: bool = bool
                    @assert(((*frame).sp > 0))
                    (@tempvar_689(*frame)).sp = ((@tempvar_689(*frame)).sp - 1)
                    *cast(^bool) (^*get_index((*frame).stack, (*frame).sp))
                }, #macro {
                    local T :: bool = bool
                    @assert(((*frame).sp > 0))
                    (@tempvar_690(*frame)).sp = ((@tempvar_690(*frame)).sp - 1)
                    *cast(^bool) (^*get_index((*frame).stack, (*frame).sp))
                })
                b : bool = @var(@id((b, a)_289))[0]
                a : bool = @var(@id((b, a)_289))[1]
                #macro {
                    local val : bool = (a and b)
                    *get_index((*frame).stack, (*frame).sp) = *cast(^i64) (^val)
                    (@tempvar_691(*frame)).sp = ((@tempvar_691(*frame)).sp + 1)
                }
            }
            Instruction.Or -> {
                @id((b, a)_290) : (bool, bool) = (#macro {
                    local T :: bool = bool
                    @assert(((*frame).sp > 0))
                    (@tempvar_692(*frame)).sp = ((@tempvar_692(*frame)).sp - 1)
                    *cast(^bool) (^*get_index((*frame).stack, (*frame).sp))
                }, #macro {
                    local T :: bool = bool
                    @assert(((*frame).sp > 0))
                    (@tempvar_693(*frame)).sp = ((@tempvar_693(*frame)).sp - 1)
                    *cast(^bool) (^*get_index((*frame).stack, (*frame).sp))
                })
                b : bool = @var(@id((b, a)_290))[0]
                a : bool = @var(@id((b, a)_290))[1]
                #macro {
                    local val : bool = (a or b)
                    *get_index((*frame).stack, (*frame).sp) = *cast(^i64) (^val)
                    (@tempvar_694(*frame)).sp = ((@tempvar_694(*frame)).sp + 1)
                }
            }
            Instruction.Branch -> {
                (*frame).ip = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_695(*frame)).ip = ((@tempvar_695(*frame)).ip + 1)
                    val
                }
            }
            Instruction.BranchIf -> {
                address : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_696(*frame)).ip = ((@tempvar_696(*frame)).ip + 1)
                    val
                }
                if #macro {
                    local T :: bool = bool
                    @assert(((*frame).sp > 0))
                    (@tempvar_697(*frame)).sp = ((@tempvar_697(*frame)).sp - 1)
                    *cast(^bool) (^*get_index((*frame).stack, (*frame).sp))
                } {
                    (*frame).ip = address
                } else {}
            }
            Instruction.NativeCall2 -> {
                wrapper : fn(fn(), ^Interpreter) = #macro {
                    local T :: NativeFunctionWrapper2 = fn(fn(), ^Interpreter)
                    val : fn(fn(), ^Interpreter) = *cast(^fn(fn(), ^Interpreter)) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_698(*frame)).ip = ((@tempvar_698(*frame)).ip + 1)
                    val
                }
                func : fn() = #macro {
                    local T :: fn() = fn()
                    val : fn() = *cast(^fn()) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_699(*frame)).ip = ((@tempvar_699(*frame)).ip + 1)
                    val
                }
                arg_slots : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_700(*frame)).ip = ((@tempvar_700(*frame)).ip + 1)
                    val
                }
                native_frame : ^StackFrame = self.push_native_frame2(arg_slots)
                #anonymous {
                    if DEBUG_INTERPRETER {
                        frame : ^StackFrame = self.top_frame()
                        g_logger.log("{}{}{}{}{}{}{}{}", cast([]^any) ([cast(^any) ((fmt).align(0)), cast(^any) (fp), cast(^any) ((fmt).align(5)), cast(^any) ((*frame).sp), cast(^any) ((fmt).align(10)), cast(^any) ("EnterNativeFunction"), cast(^any) ((fmt).align(35)), cast(^any) (&*frame.dump_stack())]), "stdout")
                    } else {}
                }
                wrapper(func, cast(^Interpreter) (self))
                #anonymous {
                    if DEBUG_INTERPRETER {
                        frame : ^StackFrame = self.top_frame()
                        g_logger.log("ret_slots: {}{}{}{}{}{}{}{}{}", cast([]^any) ([cast(^any) ((*native_frame).return_value_slots), cast(^any) ((fmt).align(20)), cast(^any) (fp), cast(^any) ((fmt).align(25)), cast(^any) ((*frame).sp), cast(^any) ((fmt).align(30)), cast(^any) ("ExitNativeFunction"), cast(^any) ((fmt).align(55)), cast(^any) (&*frame.dump_stack())]), "stdout")
                    } else {}
                }
                self.pop_frame()
                if (fp >= 0) {
                    (@tempvar_701(*get_index(&frames, fp))).sp = ((@tempvar_701(*get_index(&frames, fp))).sp + (*native_frame).return_value_slots)
                } else {
                    return InterpStepResult.Done
                }
            }
            Instruction.NativeCall -> {
                wrapper : ^NativeFunctionWrapper = #macro {
                    local T :: ^NativeFunctionWrapper = ^NativeFunctionWrapper
                    val : ^NativeFunctionWrapper = *cast(^^NativeFunctionWrapper) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_702(*frame)).ip = ((@tempvar_702(*frame)).ip + 1)
                    val
                }
                native_frame : ^StackFrame = self.push_native_frame(wrapper)
                #anonymous {
                    if DEBUG_INTERPRETER {
                        frame : ^StackFrame = self.top_frame()
                        g_logger.log("{}{}{}{}{}{}{}{}", cast([]^any) ([cast(^any) ((fmt).align(0)), cast(^any) (fp), cast(^any) ((fmt).align(5)), cast(^any) ((*frame).sp), cast(^any) ((fmt).align(10)), cast(^any) ("EnterNativeFunction"), cast(^any) ((fmt).align(35)), cast(^any) (&*frame.dump_stack())]), "stdout")
                    } else {}
                }
                (*wrapper).function(cast(^Interpreter) (self))
                #anonymous {
                    if DEBUG_INTERPRETER {
                        frame : ^StackFrame = self.top_frame()
                        g_logger.log("ret_slots: {}{}{}{}{}{}{}{}{}", cast([]^any) ([cast(^any) ((*native_frame).return_value_slots), cast(^any) ((fmt).align(20)), cast(^any) (fp), cast(^any) ((fmt).align(25)), cast(^any) ((*frame).sp), cast(^any) ((fmt).align(30)), cast(^any) ("ExitNativeFunction"), cast(^any) ((fmt).align(55)), cast(^any) (&*frame.dump_stack())]), "stdout")
                    } else {}
                }
                self.pop_frame()
                if (fp >= 0) {
                    (@tempvar_703(*get_index(&frames, fp))).sp = ((@tempvar_703(*get_index(&frames, fp))).sp + (*native_frame).return_value_slots)
                } else {
                    return InterpStepResult.Done
                }
            }
            Instruction.CompCall -> {
                func : ^AstFunction = #macro {
                    local T :: ^AstFunction = ^AstFunction
                    val : ^AstFunction = *cast(^^AstFunction) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_704(*frame)).ip = ((@tempvar_704(*frame)).ip + 1)
                    val
                }
                _ : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_705(*frame)).ip = ((@tempvar_705(*frame)).ip + 1)
                    val
                }
                _ : i64 = #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_706(*frame)).ip = ((@tempvar_706(*frame)).ip + 1)
                    val
                }
                #macro {
                    
                    
                    
                    
                    fiber_context : ^FiberContext = (Fiber).user_data()
                    if (*(*fiber_context).job).cancelled {
                        #link #anonymous {}
                        loop {
                            (Fiber).yield()
                        }
                    } else {}
                    (*(*fiber_context).job).progressed = true
                    loop {
                        if (cast(^void) ((*func).bytecode) != null) then break else {}
                        if DEBUG_WAIT then g_logger.log("suspending on {}", cast([]^any) ([cast(^any) (@expr_to_string((cast(^void) ((*func).bytecode) != null)))]), (*fiber_context).job.get_name()) else {}
                        #link #anonymous {}
                        (Fiber).yield()
                        #link #anonymous {}
                        if DEBUG_WAIT then g_logger.log("resuming on {}", cast([]^any) ([cast(^any) (@expr_to_string((cast(^void) ((*func).bytecode) != null)))]), (*fiber_context).job.get_name()) else {}
                        (*(*fiber_context).job).progressed = false
                        if (*(*fiber_context).job).cancelled {
                            #link #anonymous {}
                            loop {
                                (Fiber).yield()
                            }
                        } else {}
                    }
                    if DEBUG_WAIT then g_logger.log("done on {}", cast([]^any) ([cast(^any) (@expr_to_string((cast(^void) ((*func).bytecode) != null)))]), (*fiber_context).job.get_name()) else {}
                    (*(*fiber_context).job).progressed = true
                }
                if !self.push_frame((*func).bytecode) {
                    return InterpStepResult.Done
                } else {}
            }
            Instruction.Return -> {
                @assert(((*frame).sp > 0))
                (C).memmove(cast(^void) (^*get_index((*frame).stack, 0)), cast(^void) (^*get_index((*frame).stack, ((*frame).sp - (*frame).return_value_slots))), cast (((*frame).return_value_slots * @sizeof(u64))))
                self.pop_frame()
                if (fp >= 0) {
                    (@tempvar_707(*get_index(&frames, fp))).sp = ((@tempvar_707(*get_index(&frames, fp))).sp + (*frame).return_value_slots)
                } else {
                    return InterpStepResult.Done
                }
            }
            Instruction.ReturnVoid -> {
                self.pop_frame()
                if (fp < 0) {
                    return InterpStepResult.Done
                } else {}
            }
            Instruction.CheckRange -> {
                max : i64 = #macro {
                    local T :: int = i64
                    @assert(((*frame).sp > 0))
                    (@tempvar_708(*frame)).sp = ((@tempvar_708(*frame)).sp - 1)
                    *^*get_index((*frame).stack, (*frame).sp)
                }
                min : i64 = #macro {
                    local T :: int = i64
                    @assert(((*frame).sp > 0))
                    (@tempvar_709(*frame)).sp = ((@tempvar_709(*frame)).sp - 1)
                    *^*get_index((*frame).stack, (*frame).sp)
                }
                value : i64 = #macro {
                    local T :: int = i64
                    local offset : i64 : 0
                    @assert(((*frame).sp > 0))
                    @assert((offset <= 0))
                    *^*get_index((*frame).stack, (((*frame).sp + offset) - 1))
                }
                if ((value < min) or (value >= max)) {
                    return InterpStepResult.Error((fmt).format("Range check failed: {} not in {}..{}", cast([]^any) ([cast(^any) (value), cast(^any) (min), cast(^any) (max)])))
                } else {}
            }
            Instruction.CheckNull -> {
                value : i64 = #macro {
                    local T :: int = i64
                    @assert(((*frame).sp > 0))
                    (@tempvar_710(*frame)).sp = ((@tempvar_710(*frame)).sp - 1)
                    *^*get_index((*frame).stack, (*frame).sp)
                }
                if (value == 0) {
                    return InterpStepResult.Error((fmt).format("Null check failed", cast([]^any) ([])))
                } else {}
            }
            Instruction.Panic -> {
                str : string = @string_from_ptr_and_length(#macro {
                    local T :: ^u8 = ^u8
                    val : ^u8 = *cast(^^u8) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_711(*frame)).ip = ((@tempvar_711(*frame)).ip + 1)
                    val
                }, #macro {
                    local T :: int = i64
                    val : i64 = *cast(^i64) (^*get_index((*frame).code, (*frame).ip))
                    (@tempvar_712(*frame)).ip = ((@tempvar_712(*frame)).ip + 1)
                    val
                })
                return InterpStepResult.Error((fmt).format("[PANIC] {}", cast([]^any) ([cast(^any) (str)])))
            }
            Instruction.Halt -> {
                return InterpStepResult.Done
            }
            $unknown -> {
                g_logger.log("{}: Unknown Instruction '{}'", cast([]^any) ([cast(^any) (&(*(*frame).func).debug_info.get_location_for_ip((*frame).ip_prev)), cast(^any) ((Instruction).pretty_print(get_range_from((*frame).code, new RangeFrom[i64] { start = (*frame).ip_prev })))]), "stdout")
            }
        }
        return InterpStepResult.Continue
    }
    
    run(self: &Interpreter) -> InterpStepResult {
        @assert((fp >= 0))
        loop {
            result : InterpStepResult = self.step()
            if (result != InterpStepResult.Continue) {
                return result
            } else {}
            @destruct(result)
        }
        return InterpStepResult.Done
    }
}

InstNumTyp :: enum<i64> { // size: 0, alignment: 1
    F32 = 0
    F64 = 1
    I8 = 2
    I16 = 3
    I32 = 4
    I64 = 5
    U8 = 6
    U16 = 7
    U32 = 8
    U64 = 9
}

Instruction :: enum<u64> { // size: 0, alignment: 1
    Noop = 0
    Pop = 1
    Push = 2
    Dup = 3
    ConstInt = 4
    ConstFloat = 5
    LoadAddress = 6
    AddressOf = 7
    Load = 8
    Store = 9
    LoadLocal = 10
    StoreLocal = 11
    StoreStack = 12
    CastFD = 13
    CastDF = 14
    CastDS = 15
    CastDU = 16
    CastSD = 17
    CastUD = 18
    CastSU = 19
    CastUS = 20
    CastSigned = 21
    CastUnsigned = 22
    Add = 23
    Sub = 24
    Mul = 25
    Div = 26
    Mod = 27
    Ieq = 28
    Ine = 29
    Ilt = 30
    Ile = 31
    Igt = 32
    Ige = 33
    Neg = 34
    Not = 35
    And = 36
    Or = 37
    Branch = 38
    BranchIf = 39
    Call = 40
    NativeCall = 41
    NativeCall2 = 42
    CompCall = 43
    Return = 44
    ReturnVoid = 45
    CheckRange = 46
    CheckNull = 47
    Panic = 48
    Halt = 49
}

impl Instruction {
    pretty_print(code: []u64) -> String {
        @assert(((code).length > 0))
        arg :: arg(T: type, index: i64) #macro {
            *cast() (^*code[(index + 1)])
        }
        return match @tempvar_713(cast(Instruction) (*get_index(code, 0))) {
            Instruction.Noop -> (fmt).format("Noop", cast([]^any) ([]))
            Instruction.Push -> (fmt).format("Push {}", cast([]^any) ([cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 0
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Pop -> (fmt).format("Pop {}", cast([]^any) ([cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 0
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Dup -> (fmt).format("Dup {}", cast([]^any) ([cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 0
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.ConstInt -> (fmt).format("ConstInt {}", cast([]^any) ([cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 0
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.ConstFloat -> (fmt).format("ConstFloat {}", cast([]^any) ([cast(^any) (#macro {
                local T :: f64 = f64
                local index : i64 : 0
                *cast(^f64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.LoadAddress -> (fmt).format("LoadAddress", cast([]^any) ([]))
            Instruction.AddressOf -> (fmt).format("AddressOf {}", cast([]^any) ([cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 0
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Load -> (fmt).format("Load {}", cast([]^any) ([cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 0
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Store -> (fmt).format("Store {}", cast([]^any) ([cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 0
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.LoadLocal -> (fmt).format("LoadLocal {} {}", cast([]^any) ([cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 0
                *cast(^i64) (^*get_index(code, (index + 1)))
            }), cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 1
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.StoreLocal -> (fmt).format("StoreLocal {} {}", cast([]^any) ([cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 0
                *cast(^i64) (^*get_index(code, (index + 1)))
            }), cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 1
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.StoreStack -> (fmt).format("StoreStack {} {}", cast([]^any) ([cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 0
                *cast(^i64) (^*get_index(code, (index + 1)))
            }), cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 1
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.CastFD -> (fmt).format("CastFD", cast([]^any) ([]))
            Instruction.CastDF -> (fmt).format("CastDF", cast([]^any) ([]))
            Instruction.CastDS -> (fmt).format("CastDS", cast([]^any) ([]))
            Instruction.CastDU -> (fmt).format("CastDU", cast([]^any) ([]))
            Instruction.CastSD -> (fmt).format("CastSD", cast([]^any) ([]))
            Instruction.CastUD -> (fmt).format("CastUD", cast([]^any) ([]))
            Instruction.CastSU -> (fmt).format("CastSU", cast([]^any) ([]))
            Instruction.CastUS -> (fmt).format("CastUS", cast([]^any) ([]))
            Instruction.CastSigned -> (fmt).format("CastSigned {} {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            }), cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 1
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.CastUnsigned -> (fmt).format("CastUnsigned {} {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            }), cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 1
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Add -> (fmt).format("Add {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Sub -> (fmt).format("Sub {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Mul -> (fmt).format("Mul {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Div -> (fmt).format("Div {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Mod -> (fmt).format("Mod {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Not -> (fmt).format("Not", cast([]^any) ([]))
            Instruction.Neg -> (fmt).format("Neg {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Ieq -> (fmt).format("Ieq {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Ine -> (fmt).format("Ine {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Ilt -> (fmt).format("Ilt {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Ile -> (fmt).format("Ile {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Igt -> (fmt).format("Igt {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Ige -> (fmt).format("Ige {}", cast([]^any) ([cast(^any) (#macro {
                local T :: InstNumTyp = InstNumTyp
                local index : i64 : 0
                *cast(^InstNumTyp) (^*get_index(code, (index + 1)))
            })]))
            Instruction.And -> (fmt).format("And", cast([]^any) ([]))
            Instruction.Or -> (fmt).format("Or", cast([]^any) ([]))
            Instruction.Branch -> (fmt).format("Branch {}", cast([]^any) ([cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 0
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.BranchIf -> (fmt).format("BranchIf {}", cast([]^any) ([cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 0
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.Call -> (fmt).format("Call {} {}", cast([]^any) ([cast(^any) (@string_from_ptr_and_length(#macro {
                local T :: ^u8 = ^u8
                local index : i64 : 0
                *cast(^^u8) (^*get_index(code, (index + 1)))
            }, #macro {
                local T :: int = i64
                local index : i64 : 1
                *cast(^i64) (^*get_index(code, (index + 1)))
            })), cast(^any) (#macro {
                local T :: int = i64
                local index : i64 : 2
                *cast(^i64) (^*get_index(code, (index + 1)))
            })]))
            Instruction.NativeCall -> {
                wrapper : ^NativeFunctionWrapper = #macro {
                    local T :: ^NativeFunctionWrapper = ^NativeFunctionWrapper
                    local index : i64 : 0
                    *cast(^^NativeFunctionWrapper) (^*get_index(code, (index + 1)))
                }
                @tempvar_714((fmt).format("NativeCall {}", cast([]^any) ([cast(^any) ((*wrapper).function_type)])))
            }
            Instruction.NativeCall2 -> {
                wrapper : fn(fn(), ^Interpreter) = #macro {
                    local T :: NativeFunctionWrapper2 = fn(fn(), ^Interpreter)
                    local index : i64 : 0
                    *cast(^fn(fn(), ^Interpreter)) (^*get_index(code, (index + 1)))
                }
                func : fn() = #macro {
                    local T :: fn() = fn()
                    local index : i64 : 1
                    *cast(^fn()) (^*get_index(code, (index + 1)))
                }
                args : i64 = #macro {
                    local T :: int = i64
                    local index : i64 : 2
                    *cast(^i64) (^*get_index(code, (index + 1)))
                }
                @tempvar_715((fmt).format("NativeCall2 {}, {}, {}", cast([]^any) ([cast(^any) (*cast(^^i64) (^wrapper)), cast(^any) (*cast(^^i64) (^func)), cast(^any) (args)])))
            }
            Instruction.CompCall -> {
                func : ^AstFunction = #macro {
                    local T :: ^AstFunction = ^AstFunction
                    local index : i64 : 0
                    *cast(^^AstFunction) (^*get_index(code, (index + 1)))
                }
                @tempvar_716((fmt).format("CompCall {}#{}", cast([]^any) ([cast(^any) ((*func).name), cast(^any) ((*func).id)])))
            }
            Instruction.Return -> (fmt).format("Return", cast([]^any) ([]))
            Instruction.ReturnVoid -> (fmt).format("ReturnVoid", cast([]^any) ([]))
            Instruction.CheckRange -> (fmt).format("CheckRange", cast([]^any) ([]))
            Instruction.CheckNull -> (fmt).format("CheckNull", cast([]^any) ([]))
            Instruction.Halt -> (fmt).format("Halt", cast([]^any) ([]))
            Instruction.Panic -> (fmt).format("Panic `"{}`"", cast([]^any) ([cast(^any) (@string_from_ptr_and_length(#macro {
                local T :: ^u8 = ^u8
                local index : i64 : 0
                *cast(^^u8) (^*get_index(code, (index + 1)))
            }, #macro {
                local T :: int = i64
                local index : i64 : 1
                *cast(^i64) (^*get_index(code, (index + 1)))
            }))]))
            _ -> (fmt).format("Unknown {}", cast([]^any) ([cast(^any) (get_index(code, 0))]))
        }
    }
}

#file types.che
use import std.printable

use import std.string

TypeInfoError :: struct type { // size: 48, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
}

__ti_type_info_error : ^TypeInfo = @type_info(TypeInfoError)

TypeInfoPoly :: struct type { // size: 48, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
}

__ti_type_info_poly : ^TypeInfo = @type_info(TypeInfoPoly)

TypeInfoModule :: struct type { // size: 48, alignment: 8
    size : i64
    alignment : i64
    traits : []TypeInfoTraitImpl
    impl_funcs : []TypeInfoImplFunction
}

__ti_type_info_module : ^TypeInfo = @type_info(TypeInfoModule)

impl Printable for TypeInfoError {
    print(self: &TypeInfoError, str: &String, format: string) {
        append_string(str, "error")
    }
}

impl Printable for TypeInfoPoly {
    print(self: &TypeInfoPoly, str: &String, format: string) {
        append_string(str, "poly")
    }
}

impl Printable for TypeInfoModule {
    print(self: &TypeInfoModule, str: &String, format: string) {
        append_string(str, "module")
    }
}

#file math.che
sqrtf :: sqrtf(f: f32) -> f32 

sqrt :: sqrt(f: f64) -> f64 

abs : (i: $T) -> T : abs(i: $T) -> T {
    return if (i < 0) {
        -i
    } else {
        i
    }
}

fabsf :: fabsf(f: f32) -> f32 

fabs :: fabs(f: f64) -> f64 

fmaxf :: fmaxf(f1: f32, f2: f32) -> f32 

fmax :: fmax(f1: f64, f2: f64) -> f64 

fminf :: fminf(f1: f32, f2: f32) -> f32 

fmin :: fmin(f1: f64, f2: f64) -> f64 

sinf :: sinf(f: f32) -> f32 

sin :: sin(f: f64) -> f64 

sinh :: sinh(f: f64) -> f64 

cosf :: cosf(f: f32) -> f32 

cos :: cos(f: f64) -> f64 

cosh :: cosh(f: f64) -> f64 

tanf :: tanf(f: f32) -> f32 

tan :: tan(f: f64) -> f64 

atan2 :: atan2(a: f64, b: f64) -> f64 

pow :: pow(a: f64, b: f64) -> f64 

powf :: powf(a: f32, b: f32) -> f32 

exp :: exp(a: f64) -> f64 

logf :: logf(f: f32) -> f32 

log :: log(f: f64) -> f64 

floorf :: floorf(f32) -> f32 

floor :: floor(f64) -> f64 

ceilf :: ceilf(f32) -> f32 

ceil :: ceil(f64) -> f64 

fract : (v: $T) -> T : fract(v: $T) -> T {
    return (v - T(i64(v)))
}

mod_pos : (a: $T, b: T) -> T : mod_pos(a: $T, b: T) -> T {
    return (((a % b) + b) % b)
}

clamp : (value: $T, min: T, max: T) -> T : clamp(value: $T, min: T, max: T) -> T {
    if (value < min) {
        return min
    }
    if (value > max) {
        return max
    }
    return value
}

count_digits : (value: $T, base: int = 10) -> int : count_digits(value: $T, base: int) -> int {
    return if (value == 0) then 1 else {
        digits :  = 0
        loop {
            if !(value > 0) then break
            value = T(base)
            digits = 1
        }
        digits
    }
}
// Polymorphic instances for count_digits(value: $T, base: int) -> int
    /* T = (type, i64) */
    /*  */
    count_digits(value: i64, base: i64 = 10) -> i64 {
        return if (value == 0) then 1 else {
            digits : i64 = 0
            loop {
                if !(value > 0) then break else {}
                value = (value / base)
                digits = (digits + 1)
            }
            digits
        }
    }


Vector2 :: struct(T: type) {
    x :  = default
    y :  = default
}

Vector3 :: struct(T: type) {
    x :  = default
    y :  = default
    z :  = default
}

Vector4 :: struct(T: type) {
    x :  = default
    y :  = default
    z :  = default
    w :  = default
}

impl(T: type) Cheez.Types.Abstract.GenericStructType {
    
}

impl(T: type) Cheez.Types.Abstract.GenericStructType {
    
}

impl(T: type) Cheez.Types.Abstract.GenericStructType {
    
}

Complex :: struct { // size: 16, alignment: 8
    r : f64 = 0.0
    i : f64 = 0.0
}

impl Complex {
    real(r: f64) -> Complex {
        return new Complex { r = r, i = 0 }
    }
    
    imaginary(i: f64) -> Complex {
        return new Complex { r = 0, i = i }
    }
    
    from_polar(m: f64, p: f64) -> Complex {
        return new Complex { r = (m * cos(p)), i = (m * sin(p)) }
    }
    
    add(a: Complex, b: Complex) -> Complex #operator("+") {
        return new Complex { r = ((a).r + (b).r), i = ((a).i + (b).i) }
    }
    
    add2(a: Complex, b: f64) -> Complex #operator("+") {
        return new Complex { r = ((a).r + b), i = (a).i }
    }
    
    sub(a: Complex, b: Complex) -> Complex #operator("-") {
        return new Complex { r = ((a).r - (b).r), i = ((a).i - (b).i) }
    }
    
    sub2(a: Complex, b: f64) -> Complex #operator("-") {
        return new Complex { r = ((a).r - b), i = (a).i }
    }
    
    neg(a: Complex) -> Complex #operator("-") {
        return new Complex { r = -(a).r, i = -(a).i }
    }
    
    conj(a: Complex) -> Complex #operator("!") {
        return new Complex { r = (a).r, i = -(a).i }
    }
    
    mul(a: Complex, b: Complex) -> Complex #operator("*") {
        return new Complex { r = (((a).r * (b).r) - ((a).i * (b).i)), i = (((a).r * (b).i) + ((a).i * (b).r)) }
    }
    
    mul2(a: Complex, b: f64) -> Complex #operator("*") {
        return new Complex { r = ((a).r * b), i = ((a).i * b) }
    }
    
    div(a: Complex, b: Complex) -> Complex #operator("/") {
        fac : f64 = (1 / (((b).r * (b).r) + ((b).i * (b).i)))
        return new Complex { r = (fac * (((a).r * (b).r) + ((a).i * (b).i))), i = (fac * (((a).r * (b).i) - ((a).i * (b).r))) }
    }
    
    div2(a: Complex, b: f64) -> Complex #operator("/") {
        return new Complex { r = ((a).r / b), i = ((a).i / b) }
    }
    
    poww(a: Complex, e: f64) -> Complex {
        if (((a).r == 0) and ((a).i == 0)) {
            return a
        } else {}
        r : f64 = sqrt((((a).r * (a).r) + ((a).i * (a).i)))
        p : f64 = atan2((a).i, (a).r)
        r = pow(r, e)
        p = (p * e)
        return new Complex { r = (r * cos(p)), i = (r * sin(p)) }
    }
    
    polar(self: Complex) -> (m: f64, p: f64) {
        m = sqrt((((self).r * (self).r) + ((self).i * (self).i)))
        p = atan2((self).i, (self).r)
        return
    }
}

impl f64 {
    map(self: f64, from: (f64, f64), to: (f64, f64)) -> f64 {
        return ((((self - from[0]) / (from[1] - from[0])) * (to[1] - to[0])) + to[0])
    }
}

#file ast_cloner.che
use import std.array

use import std.string

use import ast

use import ast_dumper

mem :  : import std.mem.allocator

fmt :  : import std.fmt

use import logging.logger

AstCloner :: struct { // size: 24, alignment: 8
    _next_id : i64
    allocator : ^Allocator
}

impl AstCloner {
    new_ast(&AstCloner, ast: $T) -> ^AstNode {
        result :  = (mem).alloc(T, allocator)
        *result = ast
        (result).id = _next_id
        _next_id = 1
        return result
    }
    // Polymorphic instances for new_ast(&AstCloner, ast: $T) -> ^AstNode
        /* T = (type, AstBinary) */
        /*  */
        new_ast(self: &AstCloner, ast: AstBinary) -> ^AstNode {
            result : ^AstBinary = (mem).alloc(allocator)
            *result = ast
            (*result).id = _next_id
            _next_id = (_next_id + 1)
            return cast(^AstNode) (result)
        }
        /* T = (type, AstDecl) */
        /*  */
        new_ast(self: &AstCloner, ast: AstDecl) -> ^AstNode {
            result : ^AstDecl = (mem).alloc(allocator)
            *result = ast
            (*result).id = _next_id
            _next_id = (_next_id + 1)
            return cast(^AstNode) (result)
        }
        /* T = (type, AstIdentifier) */
        /*  */
        new_ast(self: &AstCloner, ast: AstIdentifier) -> ^AstNode {
            result : ^AstIdentifier = (mem).alloc(allocator)
            *result = ast
            (*result).id = _next_id
            _next_id = (_next_id + 1)
            return cast(^AstNode) (result)
        }
        /* T = (type, AstNumberLiteral) */
        /*  */
        new_ast(self: &AstCloner, ast: AstNumberLiteral) -> ^AstNode {
            result : ^AstNumberLiteral = (mem).alloc(allocator)
            *result = ast
            (*result).id = _next_id
            _next_id = (_next_id + 1)
            return cast(^AstNode) (result)
        }
        /* T = (type, AstStruct) */
        /*  */
        new_ast(self: &AstCloner, ast: AstStruct) -> ^AstNode {
            result : ^AstStruct = (mem).alloc(allocator)
            *result = ast
            (*result).id = _next_id
            _next_id = (_next_id + 1)
            return cast(^AstNode) (result)
        }
    
    
    clone_array(self: &AstCloner, arr: []^AstNode) -> Array[^AstNode] {
        result : Array[^AstNode] = (Array[^AstNode]).create((arr).length, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
        #macro {
            local arr : []^AstNode = arr
            
            local reverse : bool : false
            local by_ref : bool : false
            {
                it_index : i64 = 0
                loop {
                    if !(it_index < (arr).length) then break else {}
                    defer it_index = (it_index + 1)
                    #anonymous {
                        it : ^AstNode = *get_index(arr, it_index)
                        #link #anonymous {
                            node : ^AstNode = it
                            it_index : i64 = it_index
                            {
                                &result.add(node)
                            }
                        }
                    }
                    it_index = (it_index + 1)
                }
            }
        }
        return result
    }
    
    clone(self: &AstCloner, node: ^AstNode) -> ^AstNode {
        if (cast(^void) (node) == null) {
            return null
        } else {}
        return match @tempvar_717(node) {
            AstBinary($node) -> self.new_ast(new AstBinary {
                location = (*node).location
                operator = (*node).operator
                left = &*self.clone(^*(*node).left)
                right = &*self.clone(^*(*node).right)
                id = -1
                scope = null
                typ = null
                value = Value.None
                flags = 0
            })
            AstDecl($node) -> self.new_ast(new AstDecl {
                location = (*node).location
                pattern = self.clone((*node).pattern)
                type_expr = self.clone((*node).type_expr)
                value_expr = self.clone((*node).value_expr)
                mutable = (*node).mutable
                id = -1
                scope = null
                typ = null
                value = Value.None
                flags = 0
                public = false
                name = "_"
                var_type = null
            })
            AstIdentifier($node) -> self.new_ast(new AstIdentifier {
                location = (*node).location
                name = (*node).name
                id = -1
                scope = null
                typ = null
                value = Value.None
                flags = 0
                symbol = Symbol.NotFound
            })
            AstNumberLiteral($node) -> self.new_ast(new AstNumberLiteral {
                location = (*node).location
                value = (*node).value
                id = -1
                scope = null
                typ = null
                flags = 0
            })
            AstStruct($node) -> self.new_ast(new AstStruct {
                location = (*node).location
                name = (*node).name
                trait_expr = self.clone((*node).trait_expr)
                children = self.clone_array(&(*node).children.slice())
                id = -1
                scope = null
                typ = null
                value = Value.None
                flags = 0
                sub_scope = null
                struct_type = null
                members = (Array[^AstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                constants = (Array[^AstConstDecl]).create(10, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
                members_done = false
            })
            $node -> {
                dump : String = dump_ast(&*node, true)
                g_logger.log("[ERROR] clone ast: node type not implemented: {}`n", cast([]^any) ([cast(^any) (dump)]), "")
                null
                @destruct(dump)
            }
        }
    }
}

#file ast_pretty_printer.che
use import std.array

use import std.string

fmt :  : import std.fmt

use import logging.logger

use import ast

use import ast_dumper

pretty_print_ast :: pretty_print_ast(node: &AstNode) -> String {
    result : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    pretty_print_ast_helper(&result, node)
    return result
}

pretty_print_typed_ast :: pretty_print_typed_ast(node: &AstNode) -> String {
    result : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
    pretty_print_typed_ast_helper(&result, node)
    return result
}

append_indented :: append_indented(result: &String, str: &String, indent: i64) {
    #macro {
        local self : StringSplitCharIterator = str.slice().split_at_char('`n', false)
        
        it_index : i64 = 0
        loop {
            if !((((self).remaining).bytes).length > 0) then break else {}
            index : i64 = (self).remaining.index_of((self).split_at)
            it : string = if (index < 0) {
                (self).remaining <- ""
            } else {
                tmp : string = get_range_to((self).remaining, new RangeTo[i64] { end = index })
                (self).remaining = get_range_from((self).remaining, new RangeFrom[i64] { start = (index + 1) })
                tmp
            }
            if (((it).bytes).length != 0) {
                #link #anonymous {
                    line : string = it
                    it_index : i64 = it_index
                    {
                        #macro {
                            local r : Range[i64] = new Range[i64] { start = 0, end = indent }
                            
                            rev : bool = ((r).end < (r).start)
                            inc : i64 = if rev then -1 else 1
                            
                            {
                                @id((it, it_index)_64) : (i64, i64) = ((r).start, 0)
                                it : i64 = @var(@id((it, it_index)_64))[0]
                                it_index : i64 = @var(@id((it, it_index)_64))[1]
                                loop {
                                    if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                                    defer #anonymous {
                                        it_index = (it_index + 1)
                                        it = (it + inc)
                                    }
                                    #link #anonymous {
                                        it : i64 = it
                                        it_index : i64 = it_index
                                        {
                                            append_string(result, " ")
                                        }
                                    }
                                    #anonymous {
                                        it_index = (it_index + 1)
                                        it = (it + inc)
                                    }
                                }
                            }
                        }
                        append_string(result, line)
                        append_string(result, "`n")
                    }
                }
                it_index = (it_index + 1)
            } else {}
        }
    }
}

pretty_print_ast_helper :: pretty_print_ast_helper(result: &String, node: &AstNode) {
    match @tempvar_100(node) {
        AstStruct($node) -> {
            (fmt).format_into(result, "struct {} ``{`n", cast([]^any) ([cast(^any) ((*node).name)]))
            r : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : &Array[^AstNode] = &(*node).children
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                child : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    &r.clear()
                                    pretty_print_ast_helper(&r, &**child)
                                    append_indented(result, &r, 4)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            (fmt).format_into(result, "``}", cast([]^any) ([]))
            @destruct(r)
        }
        AstTrait($node) -> {
            (fmt).format_into(result, "trait {} ``{`n", cast([]^any) ([cast(^any) ((*node).name)]))
            r : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : &Array[^AstNode] = &(*node).children
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                child : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    &r.clear()
                                    pretty_print_ast_helper(&r, &**child)
                                    append_indented(result, &r, 4)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            (fmt).format_into(result, "``}", cast([]^any) ([]))
            @destruct(r)
        }
        AstEnum($node) -> {
            (fmt).format_into(result, "enum {} ``{`n", cast([]^any) ([cast(^any) ((*node).name)]))
            r : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : &Array[^AstNode] = &(*node).children
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                child : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    &r.clear()
                                    pretty_print_ast_helper(&r, &**child)
                                    append_indented(result, &r, 4)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            (fmt).format_into(result, "``}", cast([]^any) ([]))
            @destruct(r)
        }
        AstImpl($imp) -> {
            append_string(result, "impl ")
            if (cast(^void) ((*imp).trait_expr) != null) {
                pretty_print_ast_helper(result, &*(*imp).trait_expr)
                append_string(result, " for ")
            } else {}
            pretty_print_ast_helper(result, (*imp).target_expr)
            append_string(result, " {`n")
            r : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : &Array[^AstNode] = &(*imp).children
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                child : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    &r.clear()
                                    pretty_print_ast_helper(&r, &**child)
                                    append_indented(result, &r, 4)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            (fmt).format_into(result, "``}", cast([]^any) ([]))
            @destruct(r)
        }
        AstFunction($func) -> {
            append_string(result, "(")
            #macro {
                local arr : &Array[^AstDecl] = &(*func).params
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstDecl = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                param : &^AstDecl = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) then result.append_string(", ") else {}
                                    pretty_print_ast_helper(result, cast(&AstNode) (&**param))
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, ") ")
            if (cast(^void) ((*func).return_type_expr) != null) {
                pretty_print_ast_helper(result, &*(*func).return_type_expr)
            } else {}
            if (cast(^void) ((*func).body) != null) {
                pretty_print_ast_helper(result, &*(*func).body)
            } else {}
        }
        AstTuple($tuple) -> {
            append_string(result, "(")
            #macro {
                local arr : &Array[^AstNode] = &(*tuple).values
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                value : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) then result.append_string(", ") else {}
                                    pretty_print_ast_helper(result, &**value)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, ")")
        }
        AstConstDecl($decl) -> {
            pretty_print_ast_helper(result, (*decl).pattern)
            append_string(result, " :")
            if (cast(^void) ((*decl).type_expr) != null) {
                append_string(result, " ")
                pretty_print_ast_helper(result, &*(*decl).type_expr)
                append_string(result, " ")
            } else {}
            append_string(result, ": ")
            pretty_print_ast_helper(result, (*decl).value_expr)
        }
        AstDecl($decl) -> {
            if (*decl).mutable {
                append_string(result, "mut ")
            } else {}
            if (cast(^void) ((*decl).pattern) != null) {
                pretty_print_ast_helper(result, &*(*decl).pattern)
            } else {
                append_string(result, "_")
            }
            append_string(result, " :")
            if (cast(^void) ((*decl).type_expr) != null) {
                append_string(result, " ")
                pretty_print_ast_helper(result, &*(*decl).type_expr)
                if (cast(^void) ((*decl).value_expr) != null) {
                    append_string(result, " ")
                } else {}
            } else {}
            if (cast(^void) ((*decl).value_expr) != null) {
                append_string(result, "= ")
                pretty_print_ast_helper(result, &*(*decl).value_expr)
            } else {}
        }
        AstAssignment($ass) -> {
            pretty_print_ast_helper(result, (*ass).pattern)
            append_string(result, " = ")
            pretty_print_ast_helper(result, (*ass).value_expr)
        }
        AstBlock($block) -> {
            r : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            append_string(result, "{`n")
            #macro {
                local arr : &Array[^AstNode] = &(*block).children
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                child : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    &r.clear()
                                    pretty_print_ast_helper(&r, &**child)
                                    append_indented(result, &r, 4)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, "}")
            @destruct(r)
        }
        AstIdentifier($id) -> {
            append_string(result, (*id).name)
        }
        AstNumberLiteral($num) -> {
            (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) ((*num).value)]))
        }
        AstString($str) -> {
            (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) ((*str).string_value)]))
        }
        AstBool($bol) -> {
            (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) ((*bol).bool_value)]))
        }
        AstNull($nul) -> {
            append_string(result, "null")
        }
        AstBinary($bin) -> {
            append_string(result, "(")
            pretty_print_ast_helper(result, (*bin).left)
            (fmt).format_into(result, " {} ", cast([]^any) ([cast(^any) ((*bin).operator.lexeme())]))
            pretty_print_ast_helper(result, (*bin).right)
            append_string(result, ")")
        }
        AstUfc($ufc) -> {
            pretty_print_ast_helper(result, (*ufc).value_expr)
        }
        AstUse($us) -> {
            append_string(result, "use ")
            pretty_print_ast_helper(result, (*us).value_expr)
        }
        AstUnary($un) -> {
            append_string(result, "(")
            (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) ((*un).operator.lexeme())]))
            pretty_print_ast_helper(result, (*un).sub)
            append_string(result, ")")
        }
        AstArgument($arg) -> {
            if (cast(^void) ((*arg).name) != null) {
                pretty_print_ast_helper(result, cast(&AstNode) (&*(*arg).name))
                append_string(result, " = ")
            } else {}
            pretty_print_ast_helper(result, (*arg).value_expr)
        }
        AstCall($call) -> {
            pretty_print_ast_helper(result, (*call).function)
            append_string(result, "(")
            #macro {
                local arr : &Array[^AstArgument] = &(*call).arguments
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstArgument = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                arg : &^AstArgument = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(result, ", ")
                                    } else {}
                                    pretty_print_ast_helper(result, cast(&AstNode) (&**arg))
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, ")")
        }
        AstCast($cst) -> {
            append_string(result, "cast")
            if (cast(^void) ((*cst).type_expr) != null) {
                append_string(result, "(")
                pretty_print_ast_helper(result, &*(*cst).type_expr)
                append_string(result, ")")
            } else {}
            append_string(result, " ")
            pretty_print_ast_helper(result, (*cst).value_expr)
        }
        AstIf($iff) -> {
            append_string(result, "if ")
            pretty_print_ast_helper(result, (*iff).condition)
            append_string(result, " then ")
            pretty_print_ast_helper(result, (*iff).true_case)
            if (cast(^void) ((*iff).false_case) != null) {
                append_string(result, " else ")
                pretty_print_ast_helper(result, &*(*iff).false_case)
            } else {}
        }
        AstIndex($node) -> {
            pretty_print_ast_helper(result, (*node).sub)
            append_string(result, "[")
            #macro {
                local arr : &Array[^AstArgument] = &(*node).arguments
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstArgument = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                arg : &^AstArgument = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(result, ", ")
                                    } else {}
                                    pretty_print_ast_helper(result, cast(&AstNode) (&**arg))
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, "]")
        }
        AstLoop($lop) -> {
            append_string(result, "loop ")
            pretty_print_ast_helper(result, (*lop).body)
        }
        AstFor($forr) -> {
            append_string(result, "for ")
            if (cast(^void) ((*forr).it_pattern) != null) then pretty_print_ast_helper(result, &*(*forr).it_pattern) else {}
            if (cast(^void) ((*forr).index_name) != null) {
                if (cast(^void) ((*forr).it_pattern) != null) {
                    append_string(result, ", ")
                } else {}
                pretty_print_ast_helper(result, cast(&AstNode) (&*(*forr).index_name))
            } else {}
            if ((cast(^void) ((*forr).it_pattern) != null) or (cast(^void) ((*forr).index_name) != null)) {
                append_string(result, " in ")
            } else {}
            pretty_print_ast_helper(result, (*forr).collection)
            append_string(result, " do ")
            pretty_print_ast_helper(result, (*forr).body)
        }
        AstBreak($brake) -> {
            append_string(result, "break")
            if (cast(^void) ((*brake).label) != null) {
                append_string(result, " ")
                pretty_print_ast_helper(result, cast(&AstNode) (&*(*brake).label))
            } else {}
            if (cast(^void) ((*brake).value_expr) != null) {
                append_string(result, " with ")
                pretty_print_ast_helper(result, &*(*brake).value_expr)
            } else {}
        }
        AstContinue($cont) -> {
            append_string(result, "continue")
            if (cast(^void) ((*cont).label) != null) {
                append_string(result, " ")
                pretty_print_ast_helper(result, cast(&AstNode) (&*(*cont).label))
            } else {}
        }
        AstReturn($ret) -> {
            append_string(result, "return")
            if (cast(^void) ((*ret).value_expr) != null) {
                append_string(result, " ")
                pretty_print_ast_helper(result, &*(*ret).value_expr)
            } else {}
        }
        AstDefer($def) -> {
            append_string(result, "deref ")
            pretty_print_ast_helper(result, (*def).sub)
        }
        AstImport($imp) -> {
            append_string(result, "import ")
            pretty_print_ast_helper(result, (*imp).path)
        }
        AstMatch($mat) -> {
            append_string(result, "match ")
            if (cast(^void) ((*mat).value_expr) != null) then pretty_print_ast_helper(result, &*(*mat).value_expr) else {}
            append_string(result, " {`n")
            r : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : &Array[^AstMatchCase] = &(*mat).cases
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstMatchCase = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                case : &^AstMatchCase = it
                                it_index : i64 = it_index
                                {
                                    &r.clear()
                                    pretty_print_ast_helper(&r, (**case).pattern)
                                    if (cast(^void) ((**case).condition) != null) {
                                        append_string(&r, " if")
                                        pretty_print_ast_helper(&r, &*(**case).condition)
                                    } else {}
                                    append_string(&r, " -> ")
                                    pretty_print_ast_helper(&r, (**case).body)
                                    append_indented(result, &r, 4)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, "}")
            @destruct(r)
        }
        AstPoly($poly) -> {
            append_string(result, "(")
            #macro {
                local arr : &Array[^AstDecl] = &(*poly).params
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstDecl = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                param : &^AstDecl = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(result, ", ")
                                    } else {}
                                    pretty_print_ast_helper(result, cast(&AstNode) (&**param))
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, ") ")
            match @tempvar_134((*poly).value_expr) {
                AstEnum(_) -> {}
                AstStruct(_) -> {}
                AstTrait(_) -> {}
                _ -> {
                    append_string(result, "const ")
                }
            }
            pretty_print_ast_helper(result, (*poly).value_expr)
        }
        AstTuple($tuple) -> {
            append_string(result, "(")
            #macro {
                local arr : &Array[^AstNode] = &(*tuple).values
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                v : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    pretty_print_ast_helper(result, &**v)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, ")")
        }
        AstArray($array) -> {
            append_string(result, "[")
            #macro {
                local arr : &Array[^AstNode] = &(*array).values
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                v : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(result, ", ")
                                    } else {}
                                    pretty_print_ast_helper(result, &**v)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, "]")
        }
        AstArrayType($array_type) -> {
            append_string(result, "[")
            if (cast(^void) ((*array_type).count) != null) {
                pretty_print_ast_helper(result, &*(*array_type).count)
            } else {}
            append_string(result, "]")
            pretty_print_ast_helper(result, (*array_type).target)
        }
        AstDot($dot) -> {
            if (cast(^void) ((*dot).sub) != null) then pretty_print_ast_helper(result, &*(*dot).sub) else {}
            append_string(result, ".")
            pretty_print_ast_helper(result, cast(&AstNode) ((*dot).name))
        }
        $node -> {
            dump : String = dump_ast(node, true)
            g_logger.log("[ERROR] pretty_print_ast: node type not implemented: {}`n", cast([]^any) ([cast(^any) (dump)]), "")
            @destruct(dump)
        }
    }
}

pretty_print_typed_ast_helper :: pretty_print_typed_ast_helper(result: &String, node: &AstNode) {
    match @tempvar_142(node) {
        AstStruct($str) -> {
            (fmt).format_into(result, "struct {} ``{ // size: {}, alignment: {}`n", cast([]^any) ([cast(^any) ((*str).name), cast(^any) ((*(*str).struct_type).size), cast(^any) ((*(*str).struct_type).alignment)]))
            r : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : &Array[^AstDecl] = &(*str).members
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstDecl = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                mem : &^AstDecl = it
                                it_index : i64 = it_index
                                {
                                    &r.clear()
                                    pretty_print_typed_ast_helper(&r, cast(&AstNode) (&**mem))
                                    append_indented(result, &r, 4)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            (fmt).format_into(result, "``}", cast([]^any) ([]))
            @destruct(r)
        }
        AstTrait($str) -> {
            (fmt).format_into(result, "trait ``{", cast([]^any) ([]))
            (fmt).format_into(result, "``}", cast([]^any) ([]))
        }
        AstEnum($str) -> {
            (fmt).format_into(result, "enum ``{", cast([]^any) ([]))
            (fmt).format_into(result, "``}", cast([]^any) ([]))
        }
        AstFunction($func) -> {
            append_string(result, "(")
            #macro {
                local arr : &Array[^AstDecl] = &(*func).params
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstDecl = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                param : &^AstDecl = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) then result.append_string(", ") else {}
                                    pretty_print_typed_ast_helper(result, cast(&AstNode) (&**param))
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, ") ")
            if (cast(^void) ((*func).return_type) != null) {
                (fmt).format_into(result, "-> {} ", cast([]^any) ([cast(^any) ((*func).return_type)]))
            } else {}
            pretty_print_typed_ast_helper(result, &*(*func).body)
        }
        AstTuple($tuple) -> {
            append_string(result, "(")
            #macro {
                local arr : &Array[^AstNode] = &(*tuple).values
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                value : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) then result.append_string(", ") else {}
                                    pretty_print_typed_ast_helper(result, &**value)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, ")")
        }
        AstConstDecl($decl) -> {
            pretty_print_typed_ast_helper(result, (*decl).pattern)
            (fmt).format_into(result, " : {} : ", cast([]^any) ([cast(^any) ((*decl).var_type)]))
            match @tempvar_149((*decl).value) {
                Value.Int($i) -> (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) (i)]))
                Value.Float($f) -> (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) (f)]))
                Value.Bool($b) -> (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) (b)]))
                Value.String($s) -> (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) (s)]))
                _ -> pretty_print_typed_ast_helper(result, (*decl).value_expr)
            }
        }
        AstDecl($decl) -> {
            if (*decl).mutable {
                append_string(result, "mut ")
            } else {}
            if (cast(^void) ((*decl).pattern) != null) {
                pretty_print_typed_ast_helper(result, &*(*decl).pattern)
            } else {
                append_string(result, "_")
            }
            (fmt).format_into(result, " : {}", cast([]^any) ([cast(^any) ((*decl).var_type)]))
            if (cast(^void) ((*decl).value_expr) != null) {
                append_string(result, " = ")
                pretty_print_typed_ast_helper(result, &*(*decl).value_expr)
            } else {}
        }
        AstAssignment($ass) -> {
            pretty_print_typed_ast_helper(result, (*ass).pattern)
            append_string(result, " = ")
            pretty_print_typed_ast_helper(result, (*ass).value_expr)
        }
        AstBlock($block) -> {
            r : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            append_string(result, "{`n")
            #macro {
                local arr : &Array[^AstNode] = &(*block).children
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                child : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    &r.clear()
                                    pretty_print_typed_ast_helper(&r, &**child)
                                    append_indented(result, &r, 4)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, "}")
            @destruct(r)
        }
        AstIdentifier($id) -> {
            append_string(result, (*id).name)
        }
        AstNumberLiteral($num) -> {
            (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) ((*num).value)]))
        }
        AstString($str) -> {
            (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) ((*str).string_value)]))
        }
        AstBool($bol) -> {
            (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) ((*bol).bool_value)]))
        }
        AstNull($nul) -> {
            append_string(result, "null")
        }
        AstBinary($bin) -> {
            append_string(result, "(")
            pretty_print_typed_ast_helper(result, (*bin).left)
            (fmt).format_into(result, " {} ", cast([]^any) ([cast(^any) ((*bin).operator.lexeme())]))
            pretty_print_typed_ast_helper(result, (*bin).right)
            append_string(result, ")")
        }
        AstUfc($ufc) -> {
            (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) ((*ufc).symbol)]))
        }
        AstUse($us) -> {
            append_string(result, "use ")
            pretty_print_typed_ast_helper(result, (*us).value_expr)
        }
        AstUnary($un) -> {
            append_string(result, "(")
            (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) ((*un).operator.lexeme())]))
            pretty_print_typed_ast_helper(result, (*un).sub)
            append_string(result, ")")
        }
        AstArgument($arg) -> {
            if (cast(^void) ((*arg).name) != null) {
                pretty_print_typed_ast_helper(result, cast(&AstNode) (&*(*arg).name))
                append_string(result, " = ")
            } else {}
            pretty_print_typed_ast_helper(result, (*arg).value_expr)
        }
        AstCall($call) -> {
            pretty_print_typed_ast_helper(result, (*call).function)
            append_string(result, "(")
            #macro {
                local arr : &Array[^AstArgument] = &(*call).arguments
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstArgument = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                arg : &^AstArgument = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(result, ", ")
                                    } else {}
                                    pretty_print_typed_ast_helper(result, cast(&AstNode) (&**arg))
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, ")")
        }
        AstCast($cst) -> {
            (fmt).format_into(result, "cast({}) ", cast([]^any) ([cast(^any) ((*cst).typ)]))
            pretty_print_typed_ast_helper(result, (*cst).value_expr)
        }
        AstIf($iff) -> {
            append_string(result, "if ")
            pretty_print_typed_ast_helper(result, (*iff).condition)
            append_string(result, " then ")
            pretty_print_typed_ast_helper(result, (*iff).true_case)
            if (cast(^void) ((*iff).false_case) != null) {
                append_string(result, " else ")
                pretty_print_typed_ast_helper(result, &*(*iff).false_case)
            } else {}
        }
        AstIndex($node) -> {
            pretty_print_typed_ast_helper(result, (*node).sub)
            append_string(result, "[")
            #macro {
                local arr : &Array[^AstArgument] = &(*node).arguments
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstArgument = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                arg : &^AstArgument = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(result, ", ")
                                    } else {}
                                    pretty_print_typed_ast_helper(result, cast(&AstNode) (&**arg))
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, "]")
        }
        AstLoop($lop) -> {
            append_string(result, "loop ")
            pretty_print_typed_ast_helper(result, (*lop).body)
        }
        AstFor($forr) -> {
            append_string(result, "for ")
            if (cast(^void) ((*forr).it_pattern) != null) then pretty_print_typed_ast_helper(result, &*(*forr).it_pattern) else {}
            if (cast(^void) ((*forr).index_name) != null) {
                if (cast(^void) ((*forr).it_pattern) != null) {
                    append_string(result, ", ")
                } else {}
                pretty_print_typed_ast_helper(result, cast(&AstNode) (&*(*forr).index_name))
            } else {}
            if ((cast(^void) ((*forr).it_pattern) != null) or (cast(^void) ((*forr).index_name) != null)) {
                append_string(result, " in ")
            } else {}
            pretty_print_typed_ast_helper(result, (*forr).collection)
            append_string(result, " do ")
            pretty_print_typed_ast_helper(result, (*forr).body)
        }
        AstBreak($brake) -> {
            append_string(result, "break")
            if (cast(^void) ((*brake).label) != null) {
                append_string(result, " ")
                pretty_print_typed_ast_helper(result, cast(&AstNode) (&*(*brake).label))
            } else {}
            if (cast(^void) ((*brake).value_expr) != null) {
                append_string(result, " with ")
                pretty_print_typed_ast_helper(result, &*(*brake).value_expr)
            } else {}
        }
        AstContinue($cont) -> {
            append_string(result, "continue")
            if (cast(^void) ((*cont).label) != null) {
                append_string(result, " ")
                pretty_print_typed_ast_helper(result, cast(&AstNode) (&*(*cont).label))
            } else {}
        }
        AstReturn($ret) -> {
            append_string(result, "return")
            if (cast(^void) ((*ret).value_expr) != null) {
                append_string(result, " ")
                pretty_print_typed_ast_helper(result, &*(*ret).value_expr)
            } else {}
        }
        AstDefer($def) -> {
            append_string(result, "deref ")
            pretty_print_typed_ast_helper(result, (*def).sub)
        }
        AstImport($imp) -> {
            append_string(result, "import ")
            pretty_print_typed_ast_helper(result, (*imp).path)
        }
        AstMatch($mat) -> {
            append_string(result, "match ")
            if (cast(^void) ((*mat).value_expr) != null) then pretty_print_typed_ast_helper(result, &*(*mat).value_expr) else {}
            append_string(result, " {`n")
            r : String = (String).empty(cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            #macro {
                local arr : &Array[^AstMatchCase] = &(*mat).cases
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstMatchCase = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                case : &^AstMatchCase = it
                                it_index : i64 = it_index
                                {
                                    &r.clear()
                                    pretty_print_typed_ast_helper(&r, (**case).pattern)
                                    if (cast(^void) ((**case).condition) != null) {
                                        append_string(&r, " if")
                                        pretty_print_typed_ast_helper(&r, &*(**case).condition)
                                    } else {}
                                    append_string(&r, " -> ")
                                    pretty_print_typed_ast_helper(&r, (**case).body)
                                    append_indented(result, &r, 4)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, "}")
            @destruct(r)
        }
        AstPoly($poly) -> {
            append_string(result, "(")
            #macro {
                local arr : &Array[^AstDecl] = &(*poly).params
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstDecl = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                param : &^AstDecl = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(result, ", ")
                                    } else {}
                                    pretty_print_typed_ast_helper(result, cast(&AstNode) (&**param))
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, ") ")
            match @tempvar_176((*poly).value_expr) {
                AstEnum(_) -> {}
                AstStruct(_) -> {}
                AstTrait(_) -> {}
                _ -> {
                    append_string(result, "const ")
                }
            }
            pretty_print_ast_helper(result, (*poly).value_expr)
        }
        AstTuple($tuple) -> {
            append_string(result, "(")
            #macro {
                local arr : &Array[^AstNode] = &(*tuple).values
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                v : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    pretty_print_typed_ast_helper(result, &**v)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, ")")
        }
        AstArray($array) -> {
            append_string(result, "[")
            #macro {
                local arr : &Array[^AstNode] = &(*array).values
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                v : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    if (it_index > 0) {
                                        append_string(result, ", ")
                                    } else {}
                                    pretty_print_typed_ast_helper(result, &**v)
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            append_string(result, "]")
        }
        AstArrayType($array_type) -> {
            (fmt).format_into(result, "{}", cast([]^any) ([cast(^any) (((*array_type).value).Type)]))
        }
        AstDot($dot) -> {
            if (cast(^void) ((*dot).sub) != null) then pretty_print_typed_ast_helper(result, &*(*dot).sub) else {}
            append_string(result, ".")
            pretty_print_typed_ast_helper(result, cast(&AstNode) ((*dot).name))
        }
        $node -> {
            dump : String = dump_ast(node, true)
            g_logger.log("[ERROR] pretty_print_typed_ast: node type not implemented: {}`n", cast([]^any) ([cast(^any) (dump)]), "")
            @destruct(dump)
        }
    }
}

#file validator.che
use import std.array

use import std.fiber

use import std.mem.std_heap_allocator

use import std.string

fmt :  : import std.fmt

fs :  : import std.io.fs

io :  : import std.io

use import logging.logger

use import ast

use import ast_dumper

use import ast_pretty_printer

use import bytecode_generator

use import compiler

use import config

use import error_handler

use import lexer

use import parser

use import scope

use import value

validate_node :: validate_node(node: &AstNode, error_handler: ^ErrorHandler) -> bool {
    match @tempvar_184(node) {
        AstArgument($node) -> {
            #macro {
                local name : string : "AstArgument"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            #macro {
                local name : string : "AstArgument"
                
                if !(cast(^void) ((*node).typ) == cast(^void) ((*(*node).value_expr).typ)) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) == cast(^void) ((*(*node).value_expr).typ))))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if !validate_node((*node).value_expr, error_handler) {
                return false
            } else {}
        }
        AstArray($node) -> {
            #macro {
                local name : string : "AstArray"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
        }
        AstArrayType($node) -> {
            #macro {
                local name : string : "AstArray"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if ((cast(^void) ((*node).count) != null) and !validate_node(&*(*node).count, error_handler)) {
                return false
            } else {}
            if !validate_node((*node).target, error_handler) {
                return false
            } else {}
        }
        AstAssignment($node) -> {
            #macro {
                local name : string : "AstAssignment"
                
                if !(cast(^void) ((*node).typ) == cast(^void) (@type_info(void))) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) == cast(^void) (@type_info(void)))))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if !validate_node((*node).pattern, error_handler) {
                return false
            } else {}
            if !validate_node((*node).value_expr, error_handler) {
                return false
            } else {}
        }
        AstBinary($node) -> {
            #macro {
                local name : string : "AstBinary"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if !validate_node((*node).left, error_handler) {
                return false
            } else {}
            if !validate_node((*node).right, error_handler) {
                return false
            } else {}
        }
        AstBlock($node) -> {
            #macro {
                local name : string : "AstBlock"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            #macro {
                local arr : &Array[^AstNode] = &(*node).children
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                child : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    if !validate_node(&**child, error_handler) {
                                        it_index = (it_index + 1);
                                        return false
                                    } else {}
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
        }
        AstBool($node) -> {
            #macro {
                local name : string : "AstBool"
                
                if !(cast(^void) ((*node).typ) == cast(^void) (@type_info(bool))) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) == cast(^void) (@type_info(bool)))))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
        }
        AstBreak($node) -> {
            #macro {
                local name : string : "AstBreak"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if ((cast(^void) ((*node).label) != null) and !validate_node(cast(&AstNode) (&*(*node).label), error_handler)) {
                return false
            } else {}
            if ((cast(^void) ((*node).value_expr) != null) and !validate_node(&*(*node).value_expr, error_handler)) {
                return false
            } else {}
        }
        AstCall($node) -> {
            #macro {
                local name : string : "AstCall"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if !validate_node((*node).function, error_handler) {
                return false
            } else {}
            #macro {
                local arr : &Array[^AstArgument] = &(*node).arguments
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstArgument = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                arg : &^AstArgument = it
                                it_index : i64 = it_index
                                {
                                    if !validate_node(cast(&AstNode) (&**arg), error_handler) {
                                        it_index = (it_index + 1);
                                        return false
                                    } else {}
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
        }
        AstCast($node) -> {
            #macro {
                local name : string : "AstCast"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if ((cast(^void) ((*node).type_expr) != null) and !validate_node(&*(*node).type_expr, error_handler)) {
                return false
            } else {}
            if !validate_node((*node).value_expr, error_handler) {
                return false
            } else {}
        }
        AstConstDecl($node) -> {
            #macro {
                local name : string : "AstConstDecl"
                
                if !(cast(^void) ((*node).typ) == cast(^void) (@type_info(void))) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) == cast(^void) (@type_info(void)))))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            #macro {
                local name : string : "AstConstDecl"
                
                if !(cast(^void) ((*node).var_type) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).var_type) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if ((cast(^void) ((*node).type_expr) != null) and !validate_node(&*(*node).type_expr, error_handler)) {
                return false
            } else {}
            if !validate_node((*node).value_expr, error_handler) {
                return false
            } else {}
        }
        AstContinue($node) -> {
            #macro {
                local name : string : "AstContinue"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if ((cast(^void) ((*node).label) != null) and !validate_node(cast(&AstNode) (&*(*node).label), error_handler)) {
                return false
            } else {}
        }
        AstDecl($node) -> {
            #macro {
                local name : string : "AstDecl"
                
                if !(cast(^void) ((*node).typ) == cast(^void) (@type_info(void))) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) == cast(^void) (@type_info(void)))))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            #macro {
                local name : string : "AstDecl"
                
                if !(cast(^void) ((*node).var_type) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).var_type) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if ((cast(^void) ((*node).type_expr) != null) and !validate_node(&*(*node).type_expr, error_handler)) {
                return false
            } else {}
            if ((cast(^void) ((*node).value_expr) != null) and !validate_node(&*(*node).value_expr, error_handler)) {
                return false
            } else {}
        }
        AstDefer($node) -> {
            #macro {
                local name : string : "AstDefer"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if !validate_node((*node).sub, error_handler) {
                return false
            } else {}
        }
        AstDot($node) -> {
            #macro {
                local name : string : "AstDot"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if ((cast(^void) ((*node).sub) != null) and !validate_node(&*(*node).sub, error_handler)) {
                return false
            } else {}
        }
        AstFunction($node) -> {
            if ((cast(^void) ((*node).body) != null) and !validate_node(&*(*node).body, error_handler)) {
                return false
            } else {}
        }
        AstIdentifier($node) -> {
            #macro {
                local name : string : "AstIdentifier"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
        }
        AstIf($node) -> {
            #macro {
                local name : string : "AstIf"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if !validate_node((*node).condition, error_handler) {
                return false
            } else {}
            if !validate_node((*node).true_case, error_handler) {
                return false
            } else {}
            if ((cast(^void) ((*node).false_case) != null) and !validate_node(&*(*node).false_case, error_handler)) {
                return false
            } else {}
        }
        AstImport($node) -> {
            #macro {
                local name : string : "AstImport"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
        }
        AstIndex($node) -> {
            #macro {
                local name : string : "AstIndex"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if !validate_node((*node).sub, error_handler) {
                return false
            } else {}
            #macro {
                local arr : &Array[^AstArgument] = &(*node).arguments
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstArgument = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                arg : &^AstArgument = it
                                it_index : i64 = it_index
                                {
                                    if !validate_node(cast(&AstNode) (&**arg), error_handler) {
                                        it_index = (it_index + 1);
                                        return false
                                    } else {}
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
        }
        AstNumberLiteral($node) -> {
            #macro {
                local name : string : "AstNumberLiteral"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
        }
        AstPoly($node) -> {
            #macro {
                local name : string : "AstPoly"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
        }
        AstReturn($node) -> {
            #macro {
                local name : string : "AstReturn"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if ((cast(^void) ((*node).value_expr) != null) and !validate_node(&*(*node).value_expr, error_handler)) {
                return false
            } else {}
        }
        AstString($node) -> {
            #macro {
                local name : string : "AstString"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
        }
        AstStruct($node) -> {
            #macro {
                local name : string : "AstStruct"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            #macro {
                local arr : &Array[^AstNode] = &(*node).children
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < arr.get_length()) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            #anonymous {
                                it : &^AstNode = access(&*arr, it_index)
                            }
                            #link #anonymous {
                                child : &^AstNode = it
                                it_index : i64 = it_index
                                {
                                    if !validate_node(&**child, error_handler) {
                                        it_index = (it_index + 1);
                                        return false
                                    } else {}
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
        }
        AstUfc($node) -> {
            #macro {
                local name : string : "AstUfc"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
        }
        AstUnary($node) -> {
            #macro {
                local name : string : "AstUnary"
                
                if !(cast(^void) ((*node).typ) != null) {
                    error_handler.report_error_at((*node).location, "Validation failed for {}: {}", cast([]^any) ([cast(^any) (name), cast(^any) (@expr_to_string((cast(^void) ((*node).typ) != null)))]), "", cast([](fmt: string, args: []^any)) ([]))
                    return false
                } else {}
            }
            if !validate_node((*node).sub, error_handler) {
                return false
            } else {}
        }
        _ -> {
            error_handler.report_error_at((*node).location, "Validation for node not implemented", cast([]^any) ([]), "", cast([](fmt: string, args: []^any)) ([]))
            return false
        }
    }
    return true
}

assert :: assert(name: string, cond: Code) #macro #transparent {
    if !@insert(cond) {
        (error_handler).report_error_at((node).location, "Validation failed for {}: {}", [name, @expr_to_string(@insert(cond))])
        return false
    }
}

validate_const_decl :: validate_const_decl(decl: ^AstConstDecl) {}

#file hash_table.che
use import std.mem.allocator

use import std.mem.std_heap_allocator

use import std.hash

use import std.iterator

C :  : import std.c

Table :: struct(K: type, V: type) {
    max_load : 
    count : 
    entries : 
    allocator : 
    comparer : 
}
// Polymorphic instances for struct(K: type, V: type)
    // K = string, V = string
    struct { // size: 56, alignment: 8
        max_load : f64
        count : u64
        entries : []Entry[string, string]
        allocator : ^Allocator
        comparer : fn(string, string) -> bool
    }


Entry :: struct(K: type, V: type) {
    key : 
    value : 
    filled : 
    is_tombstone : 
}
// Polymorphic instances for struct(K: type, V: type)
    // K = string, V = string
    struct { // size: 48, alignment: 8
        key : string
        value : Option[string]
        filled : bool
        is_tombstone : bool
    }


impl(K: type, V: type) Drop for Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(K: type, V: type) Drop for Cheez.Types.Abstract.GenericStructType
    // K = (type, string), V = (type, string)
    impl(K: type, V: type) Drop for Table[string, string] {
        drop(self: &Table[string, string]) {
            if (cast(^void) ((entries).data) != null) {
                #macro {
                    local arr : []Entry[string, string] = entries
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &Entry[string, string] = get_index(arr, it_index)
                                #link #anonymous {
                                    e : &Entry[string, string] = it
                                    _ : i64 = it_index
                                    {
                                        if (*e).filled then (Memory).drop((*e).value <- Option[string].None) else {}
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
        }
    }


impl(K: type, V: type) Cheez.Types.Abstract.GenericStructType {
    
}
// Polymorphic instances for impl(K: type, V: type) Cheez.Types.Abstract.GenericStructType
    // K = (type, string), V = (type, string)
    impl(K: type, V: type) Table[string, string] {
        create(comp: fn(string, string) -> bool, allocator: ^Allocator = cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR)) -> Table[string, string] {
            return new Table[string, string] {
                allocator = allocator
                comparer = comp
                max_load = 0.75
                count = 0
                entries = null
            }
        }
        
        clear(self: &Table[string, string]) {
            #macro {
                local arr : []Entry[string, string] = entries
                
                local reverse : bool : false
                local by_ref : bool : true
                {
                    it_index : i64 = 0
                    loop {
                        if !(it_index < (arr).length) then break else {}
                        defer it_index = (it_index + 1)
                        #anonymous {
                            it : &Entry[string, string] = get_index(arr, it_index)
                            #link #anonymous {
                                entry : &Entry[string, string] = it
                                it_index : i64 = it_index
                                {
                                    (*entry).filled = false
                                    (*entry).is_tombstone = false
                                    (*entry).value = Option[string].None
                                }
                            }
                        }
                        it_index = (it_index + 1)
                    }
                }
            }
            count = 0
        }
        
        empty(self: &Table[string, string]) -> bool {
            return (count == 0)
        }
        
        get_count(self: &Table[string, string]) -> i64 {
            return cast (count)
        }
        
        get_entries(self: &Table[string, string]) -> []Entry[string, string] {
            return entries
        }
        
        find_entry(self: &Table[string, string], the_entries: []Entry[string, string], key: string) -> ^Entry[string, string] {
            index : u64 = ((string).hash(&key) % cast(u64) ((the_entries).length))
            tombstone : ^Entry[string, string] = null
            loop {
                if !true then break else {}
                entry : &Entry[string, string] = get_index(the_entries, cast(i64) (index))
                if !(*entry).filled {
                    if !(*entry).is_tombstone {
                        if (cast(^void) (tombstone) != null) {
                            return tombstone
                        } else {
                            return ^*entry
                        }
                    } else if (cast(^void) (tombstone) == null) {
                        tombstone = ^*entry
                    } else {}
                } else if comparer((*entry).key, key) {
                    return ^*entry
                } else {}
                index = ((index + 1) % cast(u64) ((the_entries).length))
            }
            return null
        }
        
        set(self: &Table[string, string], key: string, value: string) -> bool #operator("set[]") {
            if (cast(^void) ((entries).data) == null) {
                self.adjust_capacity(13)
            } else {}
            if (cast(f64) ((count + 1)) > (cast(f64) ((entries).length) * max_load)) {
                self.adjust_capacity(cast(u64) (((entries).length * 2)))
            } else {}
            entry : ^Entry[string, string] = self.find_entry(entries, key)
            is_new_key : bool = !(*entry).filled
            (*entry).key = key
            (*entry).value = Option[string].Some(value)
            (*entry).filled = true
            (*entry).is_tombstone = false
            if is_new_key {
                count = (count + 1)
            } else {}
            return is_new_key
        }
        
        get(self: &Table[string, string], key: string) -> Option[&string] {
            if (cast(^void) ((entries).data) == null) {
                return Option[&string].None
            } else {}
            entry : ^Entry[string, string] = self.find_entry(entries, key)
            if !(*entry).filled {
                return Option[&string].None
            } else {}
            return match @tempvar_735(&(*entry).value) {
                Option[string].Some($val) -> Option[&string].Some(val)
                Option[string].None -> Option[&string].None
            }
        }
        
        get_or_insert(self: &Table[string, string], key: string, value: fn() -> string) -> &string {
            if (cast(^void) ((entries).data) == null) {
                self.adjust_capacity(13)
            } else {}
            entry : ^Entry[string, string] = self.find_entry(entries, key)
            if !(*entry).filled {
                (*entry).key = key
                (*entry).value = Option[string].Some(value())
                (*entry).filled = true
                (*entry).is_tombstone = false
                count = (count + 1)
            } else {}
            return match @tempvar_736(&(*entry).value) {
                Option[string].Some($val) -> val
                Option[string].None -> @assert(false)
            }
        }
        
        get_unchecked(self: &Table[string, string], key: string) -> &string #operator("[]") {
            entry : ^Entry[string, string] = self.find_entry(entries, key)
            @assert((*entry).filled)
            return &((*entry).value).Some
        }
        
        at(self: &Table[string, string], key: string) -> &string {
            entry : ^Entry[string, string] = self.find_entry(entries, key)
            @assert((*entry).filled)
            return &((*entry).value).Some
        }
        
        delete(self: &Table[string, string], key: string) -> bool {
            if ((count == 0) or (cast(^void) ((entries).data) == null)) {
                return false
            } else {}
            entry : ^Entry[string, string] = self.find_entry(entries, key)
            if !(*entry).filled {
                return false
            } else {}
            (*entry).filled = false
            (*entry).value = Option[string].None
            (*entry).is_tombstone = true
            count = (count - 1)
            return true
        }
        
        adjust_capacity(self: &Table[string, string], cap: u64) {
            entries_new : []Entry[string, string] = alloc_n(cap, allocator)
            #macro {
                local r : Range[i64] = new Range[i64] { start = 0, end = (entries_new).length }
                
                rev : bool = ((r).end < (r).start)
                inc : i64 = if rev then -1 else 1
                
                {
                    @id((it, it_index)_449) : (i64, i64) = ((r).start, 0)
                    it : i64 = @var(@id((it, it_index)_449))[0]
                    it_index : i64 = @var(@id((it, it_index)_449))[1]
                    loop {
                        if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                        defer #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                        #link #anonymous {
                            i : i64 = it
                            it_index : i64 = it_index
                            {
                                (*get_index(entries_new, i)).filled = false
                                (*get_index(entries_new, i)).is_tombstone = false
                            }
                        }
                        #anonymous {
                            it_index = (it_index + 1)
                            it = (it + inc)
                        }
                    }
                }
            }
            if (cast(^void) ((entries).data) != null) {
                count = 0
                #macro {
                    local r : Range[i64] = new Range[i64] { start = 0, end = (entries).length }
                    
                    rev : bool = ((r).end < (r).start)
                    inc : i64 = if rev then -1 else 1
                    
                    {
                        @id((it, it_index)_451) : (i64, i64) = ((r).start, 0)
                        it : i64 = @var(@id((it, it_index)_451))[0]
                        it_index : i64 = @var(@id((it, it_index)_451))[1]
                        loop {
                            if !if rev then (it > (r).end) else (it < (r).end) then break else {}
                            defer #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                            #link #anonymous {
                                i : i64 = it
                                it_index : i64 = it_index
                                {
                                    entry : &Entry[string, string] = get_index(entries, i)
                                    if (*entry).filled {
                                        dest : ^Entry[string, string] = self.find_entry(entries_new, (*entry).key)
                                        (*dest).key = (*entry).key
                                        (*dest).value = (*entry).value <- Option[string].None
                                        (*dest).filled = true
                                        count = (count + 1)
                                    } else {}
                                }
                            }
                            #anonymous {
                                it_index = (it_index + 1)
                                it = (it + inc)
                            }
                        }
                    }
                }
                free_n(entries, allocator)
            } else {}
            entries = entries_new
        }
        
        contains(self: &Self, key: $K2) -> bool {
            if ((count == 0) or ((entries).data == null)) {
                return false
            }
            entry :  = find_entry(entries, key)
            if !(entry).filled {
                return false
            }
            return true
        }
        
        iterator(self: &Table[string, string]) -> TableIterator[string, string] {
            return new TableIterator[string, string] { table = self, index = 0 }
        }
    }


impl(K: type, V: type) Clone for Cheez.Types.Abstract.GenericStructType if K : Clone, V : Clone {
    
}
// Polymorphic instances for impl(K: type, V: type) Clone for Cheez.Types.Abstract.GenericStructType if K : Clone, V : Clone
    // K = (type, string), V = (type, string)
    impl(K: type, V: type) Clone for Table[string, string] {
        clone(self: &Table[string, string]) -> Table[string, string] {
            result : Table[string, string] = (Table[string, string]).create((*self).comparer, cast(^Allocator) (^DEFAULT_STD_HEAP_ALLOCATOR))
            &result.adjust_capacity(cast (((*self).entries).length))
            #macro {
                local r : &Table[string, string] = self
                
                it_index : i64 = 0
                #macro {
                    local arr : []Entry[string, string] = r.get_entries()
                    
                    local reverse : bool : false
                    local by_ref : bool : true
                    {
                        it_index : i64 = 0
                        loop {
                            if !(it_index < (arr).length) then break else {}
                            defer it_index = (it_index + 1)
                            #anonymous {
                                it : &Entry[string, string] = get_index(arr, it_index)
                                #link #anonymous {
                                    e : &Entry[string, string] = it
                                    _ : i64 = it_index
                                    {
                                        if !(*e).filled then it_index = (it_index + 1);
                                        continue else {}
                                        it : (name: string, value: &string) = ((*e).key, &((*e).value).Some)
                                        #link #anonymous {
                                            kv : (name: string, value: &string) = it
                                            it_index : i64 = it_index
                                            {
                                                set(&result, &(kv).name.clone(), (kv).value.clone())
                                            }
                                        }
                                        it_index = (it_index + 1)
                                    }
                                }
                            }
                            it_index = (it_index + 1)
                        }
                    }
                }
            }
            return result
        }
    }


for_extension_table : (r: &Table[$K, $V], code: Code) : for_extension_table(r: &Table[$K, $V], code: Code) {
    it_index :  = 0
    for(by_ref = true) e, _ : (r).get_entries() {
        if !(e).filled then continue
        it :  = ((e).key, &((e).value).Some)
        @insert(code, _break = @link(break), _continue = @link(continue))
        it_index = 1
    }
}
// Polymorphic instances for for_extension_table(r: &Table[$K, $V], code: Code)
    /* K = (type, string), V = (type, string) */
    /*  */
    for_extension_table(r: &Table[string, string], code: Code) #for {
        it_index :  = 0
        for(by_ref = true) e, _ : (r).get_entries() {
            if !(e).filled then continue
            it :  = ((e).key, &((e).value).Some)
            @insert(code, _break = @link(break), _continue = @link(continue))
            it_index = 1
        }
    }


TableIterator :: struct(K: type, V: type) {
    table : 
    index : 
}
// Polymorphic instances for struct(K: type, V: type)
    // K = string, V = string
    struct { // size: 16, alignment: 8
        table : &Table[string, string]
        index : i64
    }


#file box.che
use import std.mem.allocator

Box :: struct(T: type) {
    value : 
}

impl(T: type) Cheez.Types.Abstract.GenericStructType {
    
}

impl(T: type) Drop for Cheez.Types.Abstract.GenericStructType {
    
}

#file windows_macros.che
GetFiberData :: GetFiberData() -> ^void #linkname("winmacro_GetFiberData") 

GetCurrentFiber :: GetCurrentFiber() -> ^void #linkname("winmacro_GetCurrentFiber") 

